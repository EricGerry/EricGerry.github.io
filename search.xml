<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring常见面试题</title>
      <link href="/2020/07/17/Spring%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/07/17/Spring%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1、Spring是什么"><a href="#1、Spring是什么" class="headerlink" title="1、Spring是什么"></a>1、Spring是什么</h2><p>用于简化企业应用程序的开发，它使得开发者只需要关心业务需求。常见的配置方式有三种：基于XML的配置、基于注解的配置、基于Java的配置。</p><p>主要由以下几个模块组成：</p><ul><li><p>Spring Core：核心类库，提供IOC服务；</p></li><li><p>Spring Context：提供框架式的Bean访问方式，以及企业级功能（JNDI、定时任务等）；</p></li><li><p>Spring AOP：AOP服务；</p></li><li><p>Spring DAO：对JDBC的抽象，简化了数据访问异常的处理；</p></li><li><p>Spring ORM：对现有的ORM框架的支持；</p></li><li><p>Spring Web：提供了基本的面向Web的综合特性，例如多方文件上传；</p></li><li><p>Spring MVC：提供面向Web应用的Model-View-Controller实现。</p></li></ul><h2 id="2、Spring-的优点"><a href="#2、Spring-的优点" class="headerlink" title="2、Spring 的优点"></a>2、Spring 的优点</h2><ul><li><p>（1）spring属于低侵入式设计，代码的污染极低；</p></li><li><p>（2）spring的DI机制将对象之间的依赖关系交由框架处理，减低组件的耦合性；</p></li><li><p>（3）Spring提供了AOP技术，支持将一些通用任务，如安全、事务、日志、权限等进行集中式管理，从而提供更好的复用。</p></li><li><p>（4）spring对于主流的应用框架提供了集成支持。</p></li></ul><h2 id="3、Spring的AOP理解"><a href="#3、Spring的AOP理解" class="headerlink" title="3、Spring的AOP理解"></a>3、Spring的AOP理解</h2><p>OOP面向对象，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p><p>AOP，一般称为面向切面，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理。</p><p>AOP实现的关键在于 代理模式，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。</p><ul><li><p>（1）AspectJ是静态代理的增强，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。</p></li><li><p>（2）Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。<br>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：</p><pre><code>①JDK动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例,  生成目标类的代理对象。②如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</code></pre></li><li><p>（3）静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。</p></li></ul><blockquote><p>InvocationHandler 的 invoke(Object  proxy,Method  method,Object[] args)：proxy是最终生成的代理实例;  method 是被代理目标实例的某个具体方法;  args 是被代理目标实例某个方法的具体入参, 在方法反射调用时使用。</p></blockquote><h2 id="4、Spring的IOC理解"><a href="#4、Spring的IOC理解" class="headerlink" title="4、Spring的IOC理解"></a>4、Spring的IOC理解</h2><ul><li><p>（1）IOC就是控制反转，是指创建对象的控制权的转移，以前创建对象的主动权和时机是由自己把控的，而现在这种权力转移到Spring容器中，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系，对象与对象之间松散耦合，也利于功能的复用。DI依赖注入，和控制反转是同一个概念的不同角度的描述，即 应用程序在运行时依赖IoC容器来动态注入对象需要的外部资源。</p></li><li><p>（2）最直观的表达就是，IOC让对象的创建不用去new了，可以由spring自动生产，使用java的反射机制，根据配置文件在运行时动态的去创建对象以及管理对象，并调用对象的方法的。</p></li><li><p>（3）Spring的IOC有三种注入方式 ：构造器注入、setter方法注入、根据注解注入。</p></li></ul><blockquote><p>IOC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。</p></blockquote><h2 id="5、BeanFactory和ApplicationContext有什么区别"><a href="#5、BeanFactory和ApplicationContext有什么区别" class="headerlink" title="5、BeanFactory和ApplicationContext有什么区别"></a>5、BeanFactory和ApplicationContext有什么区别</h2><blockquote><p>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。</p></blockquote><ul><li>（1）BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：</li></ul><p>①继承MessageSource，因此支持国际化。</p><p>②统一的资源文件访问方式。</p><p>③提供在监听器中注册bean的事件。</p><p>④同时加载多个配置文件。</p><p>⑤载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</p><ul><li><p>（2）①BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</p><pre><code>②ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。③相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</code></pre></li><li><p>（3）BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</p></li><li><p>（4）BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p></li></ul><h2 id="6、请解释Spring-Bean的生命周期"><a href="#6、请解释Spring-Bean的生命周期" class="headerlink" title="6、请解释Spring Bean的生命周期"></a>6、请解释Spring Bean的生命周期</h2><p> 首先说一下Servlet的生命周期：实例化，初始init，接收请求service，销毁destroy；</p><p> Spring上下文中的Bean生命周期也类似，如下：</p><ul><li>（1）实例化Bean：</li></ul><p>对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。对于ApplicationContext容器，当容器启动结束后，通过获取BeanDefinition对象中的信息，实例化所有的bean。</p><ul><li>（2）设置对象属性（依赖注入）：</li></ul><p>实例化后的对象被封装在BeanWrapper对象中，紧接着，Spring根据BeanDefinition中的信息 以及 通过BeanWrapper提供的设置属性的接口完成依赖注入。</p><ul><li>（3）处理Aware接口：</li></ul><p>接着，Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给Bean：</p><p>①如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String beanId)方法，此处传递的就是Spring配置文件中Bean的id值；</p><p>②如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory()方法，传递的是Spring工厂自身。</p><p>③如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文；</p><ul><li>（4）BeanPostProcessor：</li></ul><p>如果想对Bean进行一些自定义的处理，那么可以让Bean实现了BeanPostProcessor接口，那将会调用postProcessBeforeInitialization(Object obj, String s)方法。</p><ul><li>（5）InitializingBean 与 init-method：</li></ul><p>如果Bean在Spring配置文件中配置了 init-method 属性，则会自动调用其配置的初始化方法。</p><ul><li>（6）如果这个Bean实现了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法；由于这个方法是在Bean初始化结束时调用的，所以可以被应用于内存或缓存技术；</li></ul><blockquote><p>以上几个步骤完成后，Bean就已经被正确创建了，之后就可以使用这个Bean了。</p></blockquote><ul><li>（7）DisposableBean：</li></ul><p>当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用其实现的destroy()方法；</p><ul><li>（8）destroy-method：</li></ul><p>最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。</p><h2 id="7、-解释Spring支持的几种bean的作用域"><a href="#7、-解释Spring支持的几种bean的作用域" class="headerlink" title="7、 解释Spring支持的几种bean的作用域"></a>7、 解释Spring支持的几种bean的作用域</h2><p>Spring容器中的bean可以分为5个范围：</p><ul><li><p>（1）singleton：默认，每个容器中只有一个bean的实例，单例的模式由BeanFactory自身来维护。</p></li><li><p>（2）prototype：为每一个bean请求提供一个实例。</p></li><li><p>（3）request：为每一个网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。</p></li><li><p>（4）session：与request范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。</p></li><li><p>（5）global-session：全局作用域，global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。全局作用域与Servlet中的session作用域效果相同。</p></li></ul><h2 id="8、Spring框架中的单例Beans是线程安全的么"><a href="#8、Spring框架中的单例Beans是线程安全的么" class="headerlink" title="8、Spring框架中的单例Beans是线程安全的么"></a>8、Spring框架中的单例Beans是线程安全的么</h2><p>Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的Spring bean并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。最浅显的解决办法就是将多态bean的作用域由“singleton”变更为“prototype”。</p><h2 id="9、Spring如何处理线程并发问题"><a href="#9、Spring如何处理线程并发问题" class="headerlink" title="9、Spring如何处理线程并发问题"></a>9、Spring如何处理线程并发问题</h2><p>在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域，因为Spring对一些Bean中非线程安全状态采用ThreadLocal进行处理，解决线程安全问题。</p><p>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。</p><p>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p><h2 id="10-1、Spring基于xml注入bean的几种方式"><a href="#10-1、Spring基于xml注入bean的几种方式" class="headerlink" title="10-1、Spring基于xml注入bean的几种方式"></a>10-1、Spring基于xml注入bean的几种方式</h2><ul><li><p>（1）Set方法注入；</p></li><li><p>（2）构造器注入：①通过index设置参数的位置；②通过type设置参数类型；</p></li><li><p>（3）静态工厂注入；</p></li><li><p>（4）实例工厂；</p></li></ul><h2 id="10-2、Spring的自动装配"><a href="#10-2、Spring的自动装配" class="headerlink" title="10-2、Spring的自动装配"></a>10-2、Spring的自动装配</h2><p>在spring中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象，使用autowire来配置自动装载模式。</p><p>在Spring框架xml配置中共有5种自动装配：</p><ul><li><p>（1）no：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配bean。</p></li><li><p>（2）byName：通过bean的名称进行自动装配，如果一个bean的 property 与另一bean 的name 相同，就进行自动装配。</p></li><li><p>（3）byType：通过参数的数据类型进行自动装配。</p></li><li><p>（4）constructor：利用构造函数进行装配，并且构造函数的参数通过byType进行装配。</p></li><li><p>（5）autodetect：自动探测，如果有构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。<br>基于注解的方式：<br>使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，&lt;context:annotation-config /&gt;。在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：<br>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；<br>如果查询的结果不止一个，那么@Autowired会根据名称来查找；<br>如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required=false。</p></li></ul><blockquote><p>@Autowired可用于：构造函数、成员变量、Setter方法</p></blockquote><p>注：@Autowired和@Resource之间的区别</p><p>(1) @Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。</p><p>(2) @Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。</p><h2 id="11、Spring-框架中都用到了哪些设计模式"><a href="#11、Spring-框架中都用到了哪些设计模式" class="headerlink" title="11、Spring 框架中都用到了哪些设计模式"></a>11、Spring 框架中都用到了哪些设计模式</h2><ul><li><p>（1）工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；</p></li><li><p>（2）单例模式：Bean默认为单例模式。</p></li><li><p>（3）代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；</p></li><li><p>（4）模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</p></li><li><p>（5）观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。</p></li></ul><h2 id="12、Spring事务的实现方式和实现原理"><a href="#12、Spring事务的实现方式和实现原理" class="headerlink" title="12、Spring事务的实现方式和实现原理"></a>12、Spring事务的实现方式和实现原理</h2><p>Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的。</p><ul><li>（1）Spring事务的种类：</li></ul><p>spring支持编程式事务管理和声明式事务管理两种方式：</p><p>①编程式事务管理使用TransactionTemplate。</p><p>②声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p><blockquote><p>声明式事务最大的优点就是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明或通过@Transactional注解的方式，便可以将事务规则应用到业务逻辑中。</p></blockquote><p>声明式事务管理要优于编程式事务管理，这正是spring倡导的非侵入式的开发方式，使业务代码不受污染，只要加上注解就可以获得完全的事务支持。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</p><ul><li>（2）spring的事务传播行为</li></ul><p>spring事务的传播行为说的是，当多个事务同时存在的时候，spring如何处理这些事务的行为。</p><blockquote><p>① PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。<br>② PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。‘<br>③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。<br>④ PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。<br>⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br>⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。<br>⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</p></blockquote><ul><li>（3）Spring中的隔离级别</li></ul><p>① ISOLATION_DEFAULT：这是个 PlatfromTransactionManager 默认的隔离级别，使用数据库默认的事务隔离级别。</p><p>② ISOLATION_READ_UNCOMMITTED：读未提交，允许另外一个事务可以看到这个事务未提交的数据。</p><p>③ ISOLATION_READ_COMMITTED：读已提交，保证一个事务修改的数据提交后才能被另一事务读取，而且能看到该事务对已有记录的更新。</p><p>④ ISOLATION_REPEATABLE_READ：可重复读，保证一个事务修改的数据提交后才能被另一事务读取，但是不能看到该事务对已有记录的更新。</p><p>⑤ ISOLATION_SERIALIZABLE：一个事务在执行的过程中完全看不到其他事务对数据库所做的更新。</p><h2 id="13、Spring框架中有哪些不同类型的事件"><a href="#13、Spring框架中有哪些不同类型的事件" class="headerlink" title="13、Spring框架中有哪些不同类型的事件"></a>13、Spring框架中有哪些不同类型的事件</h2><p>Spring 提供了以下5种标准的事件：</p><ul><li><p>（1）上下文更新事件（ContextRefreshedEvent）：在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。</p></li><li><p>（2）上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始/重新开始容器时触发该事件。</p></li><li><p>（3）上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。</p></li><li><p>（4）上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。</p></li><li><p>（5）请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。</p></li></ul><p>如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知。</p><h2 id="14、解释一下Spring-AOP里面的几个名词"><a href="#14、解释一下Spring-AOP里面的几个名词" class="headerlink" title="14、解释一下Spring AOP里面的几个名词"></a>14、解释一下Spring AOP里面的几个名词</h2><ul><li><p>(1）切面（Aspect）：被抽取的公共模块，可能会横切多个对象。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。</p></li><li><p>（2）连接点（Join point）：指方法，在Spring AOP中，一个连接点 总是 代表一个方法的执行。</p></li><li><p>（3）通知（Advice）：在切面的某个特定的连接点（Join point）上执行的动作。通知有各种类型，其中包括“around”、“before”和“after”等通知。许多AOP框架，包括Spring，都是以拦截器做通知模型， 并维护一个以连接点为中心的拦截器链。</p></li><li><p>（4）切入点（Pointcut）：切入点是指 我们要对哪些Join point进行拦截的定义。通过切入点表达式，指定拦截的方法，比如指定拦截add<em>、search</em>。</p></li><li><p>（5）引入（Introduction）：（也被称为内部类型声明（inter-type declaration））。声明额外的方法或者某个类型的字段。Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。例如，你可以使用一个引入来使bean实现 IsModified 接口，以便简化缓存机制。</p></li><li><p>（6）目标对象（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。也有人把它叫做 被通知（adviced） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。</p></li><li><p>（7）织入（Weaving）：指把增强应用到目标对象来创建新的代理对象的过程。Spring是在运行时完成织入。</p></li></ul><p>切入点（pointcut）和连接点（join point）匹配的概念是AOP的关键，这使得AOP不同于其它仅仅提供拦截功能的旧技术。 切入点使得定位通知（advice）可独立于OO层次。 例如，一个提供声明式事务管理的around通知可以被应用到一组横跨多个对象中的方法上（例如服务层的所有业务操作）。</p><p><img src="/2020/07/17/Spring%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/Spring%E5%90%8D%E8%AF%8D.png" alt=" "></p><h2 id="15、Spring通知有哪些类型"><a href="#15、Spring通知有哪些类型" class="headerlink" title="15、Spring通知有哪些类型"></a>15、Spring通知有哪些类型</h2><ul><li><p>（1）前置通知（Before advice）：在某连接点（join point）之前执行的通知，但这个通知不能阻止连接点前的执行（除非它抛出一个异常）。</p></li><li><p>（2）返回后通知（After returning advice）：在某连接点（join point）正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。</p></li><li><p>（3）抛出异常后通知（After throwing advice）：在方法抛出异常退出时执行的通知。</p></li><li><p>（4）后通知（After (finally) advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。</p></li><li><p>（5）环绕通知（Around Advice）：包围一个连接点（join point）的通知，如方法调用。这是最强大的一种通知类型。 环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它们自己的返回值或抛出异常来结束执行。 环绕通知是最常用的一种通知类型。大部分基于拦截的AOP框架，例如Nanning和JBoss4，都只提供环绕通知。</p></li></ul><blockquote><p>同一个aspect，不同advice的执行顺序：<br>①没有异常情况下的执行顺序：<br>around before advice<br>before advice<br>target method 执行<br>around after advice<br>after advice<br>afterReturning<br>②有异常情况下的执行顺序：<br>around before advice<br>before advice<br>target method 执行<br>around after advice<br>after advice<br>afterThrowing:异常发生<br>java.lang.RuntimeException: 异常发生</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Spring </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC常见面试题</title>
      <link href="/2020/07/17/SpringMVC%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/07/17/SpringMVC%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1、什么是Spring-MVC-？简单介绍下你对springMVC的理解"><a href="#1、什么是Spring-MVC-？简单介绍下你对springMVC的理解" class="headerlink" title="1、什么是Spring MVC ？简单介绍下你对springMVC的理解"></a>1、什么是Spring MVC ？简单介绍下你对springMVC的理解</h2><p>Spring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把Model，View，Controller分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。</p><h2 id="2、SpringMVC的流程"><a href="#2、SpringMVC的流程" class="headerlink" title="2、SpringMVC的流程"></a>2、SpringMVC的流程</h2><ul><li>（1）用户发送请求至前端控制器DispatcherServlet；</li><li>（2） DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handle；</li><li>（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；</li><li>（4）DispatcherServlet 调用 HandlerAdapter处理器适配器；</li><li>（5）HandlerAdapter 经过适配调用 具体处理器(Handler，也叫后端控制器)；</li><li>（6）Handler执行完成返回ModelAndView；</li><li>（7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；</li><li>（8）DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析；</li><li>（9）ViewResolver解析后返回具体View；</li><li>（10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）</li><li>（11）DispatcherServlet响应用户。</li></ul><p><img src="/2020/07/17/SpringMVC%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/SpringMVC%E6%B5%81%E7%A8%8B.png" alt=" "></p><h2 id="3、Springmvc的优点"><a href="#3、Springmvc的优点" class="headerlink" title="3、Springmvc的优点"></a>3、Springmvc的优点</h2><ul><li><p>（1）可以支持各种视图技术,而不仅仅局限于JSP；</p></li><li><p>（2）与Spring框架集成（如IoC容器、AOP等）；</p></li><li><p>（3）清晰的角色分配：前端控制器(dispatcherServlet) , 请求到处理器映射（handlerMapping), 处理器适配器（HandlerAdapter), 视图解析器（ViewResolver）。</p></li><li><p>（4） 支持各种请求资源的映射策略。</p></li></ul><h2 id="4、Spring-MVC的主要组件"><a href="#4、Spring-MVC的主要组件" class="headerlink" title="4、Spring MVC的主要组件"></a>4、Spring MVC的主要组件</h2><ul><li>（1）前端控制器 DispatcherServlet（不需要程序员开发）</li></ul><p>作用：接收请求、响应结果，相当于转发器，有了DispatcherServlet 就减少了其它组件之间的耦合度。</p><ul><li>（2）处理器映射器HandlerMapping（不需要程序员开发）</li></ul><p>作用：根据请求的URL来查找Handler</p><ul><li>（3）处理器适配器HandlerAdapter</li></ul><p>注意：在编写Handler的时候要按照HandlerAdapter要求的规则去编写，这样适配器HandlerAdapter才可以正确的去执行Handler。</p><ul><li><p>（4）处理器Handler（需要程序员开发）</p></li><li><p>（5）视图解析器 ViewResolver（不需要程序员开发）</p></li></ul><p>作用：进行视图的解析，根据视图逻辑名解析成真正的视图（view）</p><ul><li>（6）视图View（需要程序员开发jsp）</li></ul><p>View是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf等等）</p><h2 id="5、springMVC和struts2的区别有哪些"><a href="#5、springMVC和struts2的区别有哪些" class="headerlink" title="5、springMVC和struts2的区别有哪些"></a>5、springMVC和struts2的区别有哪些</h2><ul><li><p>（1）springmvc的入口是一个servlet即前端控制器（DispatchServlet），而struts2入口是一个filter过虑器（StrutsPrepareAndExecuteFilter）。</p></li><li><p>（2）springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。</p></li><li><p>（3）Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。</p></li></ul><h2 id="6、SpringMVC怎么样设定重定向和转发的"><a href="#6、SpringMVC怎么样设定重定向和转发的" class="headerlink" title="6、SpringMVC怎么样设定重定向和转发的"></a>6、SpringMVC怎么样设定重定向和转发的</h2><ul><li><p>（1）转发：在返回值前面加”forward:”，譬如”forward:user.do?name=method4”</p></li><li><p>（2）重定向：在返回值前面加”redirect:”，譬如”redirect:[<a href="http://www.baidu.com]&quot;">http://www.baidu.com]&quot;</a></p></li></ul><h2 id="7、SpringMvc怎么和AJAX相互调用的"><a href="#7、SpringMvc怎么和AJAX相互调用的" class="headerlink" title="7、SpringMvc怎么和AJAX相互调用的"></a>7、SpringMvc怎么和AJAX相互调用的</h2><p>通过Jackson框架就可以把Java里面的对象直接转化成Js可以识别的Json对象。具体步骤如下 ：</p><ul><li><p>（1）加入Jackson.jar</p></li><li><p>（2）在配置文件中配置json的映射</p></li><li><p>（3）在接受Ajax方法里面可以直接返回Object,List等,但方法前面要加上@ResponseBody注解。</p></li></ul><h2 id="8、如何解决POST请求中文乱码问题，GET的又如何处理呢"><a href="#8、如何解决POST请求中文乱码问题，GET的又如何处理呢" class="headerlink" title="8、如何解决POST请求中文乱码问题，GET的又如何处理呢"></a>8、如何解决POST请求中文乱码问题，GET的又如何处理呢</h2><ul><li>（1）解决post请求乱码问题：</li></ul><p>在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf-8；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>（2）get请求中文参数出现乱码解决方法有两个：</li></ul><p>①修改tomcat配置文件添加编码与工程编码一致，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ConnectorURIEncoding=<span class="string">"utf-8"</span> connectionTimeout=<span class="string">"20000"</span> port=<span class="string">"8080"</span> protocol=<span class="string">"HTTP/1.1"</span> redirectPort=<span class="string">"8443"</span>/&gt;</span><br></pre></td></tr></table></figure><p>②另外一种方法对参数进行重新编码：</p><p>String userName = new String(request.getParamter(“userName”).getBytes(“ISO8859-1”),”utf-8”)</p><p>ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码。</p><h2 id="9、Spring-MVC的异常处理"><a href="#9、Spring-MVC的异常处理" class="headerlink" title="9、Spring MVC的异常处理"></a>9、Spring MVC的异常处理</h2><p>可以将异常抛给Spring框架，由Spring框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。</p><h2 id="10、SpringMvc的控制器是不是单例模式-如果是-有什么问题-怎么解决"><a href="#10、SpringMvc的控制器是不是单例模式-如果是-有什么问题-怎么解决" class="headerlink" title="10、SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决"></a>10、SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决</h2><p>是单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的,解决方案是在控制器里面不能写字段。</p><h2 id="11、-SpringMVC常用的注解有哪些"><a href="#11、-SpringMVC常用的注解有哪些" class="headerlink" title="11、 SpringMVC常用的注解有哪些"></a>11、 SpringMVC常用的注解有哪些</h2><p>@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p>@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。</p><p>@ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。</p><h2 id="12、SpingMvc中的控制器的注解一般用那个-有没有别的注解可以替代"><a href="#12、SpingMvc中的控制器的注解一般用那个-有没有别的注解可以替代" class="headerlink" title="12、SpingMvc中的控制器的注解一般用那个,有没有别的注解可以替代"></a>12、SpingMvc中的控制器的注解一般用那个,有没有别的注解可以替代</h2><p>一般用@Controller注解,也可以使用@RestController,@RestController注解相当于@ResponseBody ＋ @Controller,表示是表现层,除此之外，一般不用别的注解代替。</p><h2 id="13、如果在拦截请求中，我想拦截get方式提交的方法-怎么配置"><a href="#13、如果在拦截请求中，我想拦截get方式提交的方法-怎么配置" class="headerlink" title="13、如果在拦截请求中，我想拦截get方式提交的方法,怎么配置"></a>13、如果在拦截请求中，我想拦截get方式提交的方法,怎么配置</h2><p>可以在@RequestMapping注解里面加上method=RequestMethod.GET。</p><h2 id="14、怎样在方法里面得到Request-或者Session"><a href="#14、怎样在方法里面得到Request-或者Session" class="headerlink" title="14、怎样在方法里面得到Request,或者Session"></a>14、怎样在方法里面得到Request,或者Session</h2><p>直接在方法的形参中声明request,SpringMvc就自动把request对象传入。</p><h2 id="15、如果想在拦截的方法里面得到从前台传入的参数-怎么得到"><a href="#15、如果想在拦截的方法里面得到从前台传入的参数-怎么得到" class="headerlink" title="15、如果想在拦截的方法里面得到从前台传入的参数,怎么得到"></a>15、如果想在拦截的方法里面得到从前台传入的参数,怎么得到</h2><p>直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样。</p><h2 id="16、如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象"><a href="#16、如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象" class="headerlink" title="16、如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象"></a>16、如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象</h2><p>答：直接在方法中声明这个对象,SpringMvc就自动会把属性赋值到这个对象里面。</p><h2 id="17、SpringMvc中函数的返回值是什么"><a href="#17、SpringMvc中函数的返回值是什么" class="headerlink" title="17、SpringMvc中函数的返回值是什么"></a>17、SpringMvc中函数的返回值是什么</h2><p>返回值可以有很多类型,有String, ModelAndView。ModelAndView类把视图和数据都合并的一起的，但一般用String比较好。</p><h2 id="18、SpringMvc用什么对象从后台向前台传递数据的"><a href="#18、SpringMvc用什么对象从后台向前台传递数据的" class="headerlink" title="18、SpringMvc用什么对象从后台向前台传递数据的"></a>18、SpringMvc用什么对象从后台向前台传递数据的</h2><p>通过ModelMap对象,可以在这个对象里面调用put方法,把对象加到里面,前台就可以通过el表达式拿到。</p><h2 id="19、怎么样把ModelMap里面的数据放入Session里面"><a href="#19、怎么样把ModelMap里面的数据放入Session里面" class="headerlink" title="19、怎么样把ModelMap里面的数据放入Session里面"></a>19、怎么样把ModelMap里面的数据放入Session里面</h2><p>可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key。</p><h2 id="20、SpringMvc里面拦截器是怎么写的"><a href="#20、SpringMvc里面拦截器是怎么写的" class="headerlink" title="20、SpringMvc里面拦截器是怎么写的"></a>20、SpringMvc里面拦截器是怎么写的</h2><p>有两种写法,一种是实现HandlerInterceptor接口，另外一种是继承适配器类，接着在接口方法当中，实现处理逻辑；然后在SpringMvc的配置文件中配置拦截器即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">&lt;!-- 配置SpringMvc的拦截器 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置一个拦截器的Bean就可以了 默认是对所有请求都拦截 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myInterceptor"</span> <span class="attr">class</span>=<span class="string">"com.zwp.action.MyHandlerInterceptor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 只针对部分请求拦截 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/modelMap.do"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.zwp.action.MyHandlerInterceptorAdapter"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="21、注解原理"><a href="#21、注解原理" class="headerlink" title="21、注解原理"></a>21、注解原理</h2><p>注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis常见面试题</title>
      <link href="/2020/07/17/Mybatis%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/07/17/Mybatis%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1、什么是Mybatis"><a href="#1、什么是Mybatis" class="headerlink" title="1、什么是Mybatis"></a>1、什么是Mybatis</h2><ul><li><p>（1）Mybatis是一个半ORM（对象关系映射）框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。程序员直接编写原生态sql，可以严格控制sql执行性能，灵活度高。</p></li><li><p>（2）MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</p></li><li><p>（3）通过xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过java对象和 statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。（从执行sql到返回result的过程）。</p></li></ul><h2 id="2、Mybaits的优点"><a href="#2、Mybaits的优点" class="headerlink" title="2、Mybaits的优点"></a>2、Mybaits的优点</h2><ul><li><p>（1）基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用。</p></li><li><p>（2）与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；</p></li><li><p>（3）很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）。</p></li><li><p>（4）能够与Spring很好的集成；</p></li><li><p>（5）提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护。</p></li></ul><h2 id="3、MyBatis框架的缺点"><a href="#3、MyBatis框架的缺点" class="headerlink" title="3、MyBatis框架的缺点"></a>3、MyBatis框架的缺点</h2><ul><li><p>（1）SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。</p></li><li><p>（2）SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p></li></ul><h2 id="4、MyBatis框架适用场合"><a href="#4、MyBatis框架适用场合" class="headerlink" title="4、MyBatis框架适用场合"></a>4、MyBatis框架适用场合</h2><ul><li><p>（1）MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案。</p></li><li><p>（2）对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis将是不错的选择。</p></li></ul><h2 id="5、MyBatis与Hibernate有哪些不同"><a href="#5、MyBatis与Hibernate有哪些不同" class="headerlink" title="5、MyBatis与Hibernate有哪些不同"></a>5、MyBatis与Hibernate有哪些不同</h2><ul><li><p>（1）Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。</p></li><li><p>（2）Mybatis直接编写原生态sql，可以严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套sql映射文件，工作量大。</p></li><li><p>（3）Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用hibernate开发可以节省很多代码，提高效率。</p></li></ul><h2 id="6、-和-的区别是什么"><a href="#6、-和-的区别是什么" class="headerlink" title="6、#{}和${}的区别是什么"></a>6、#{}和${}的区别是什么</h2><p> #{}是预编译处理，${}是字符串替换。</p><p>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</p><p>Mybatis在处理${}时，就是把${}替换成变量的值。</p><p>使用#{}可以有效的防止SQL注入，提高系统安全性。</p><h2 id="7、当实体类中的属性名和表中的字段名不一样-，怎么办"><a href="#7、当实体类中的属性名和表中的字段名不一样-，怎么办" class="headerlink" title="7、当实体类中的属性名和表中的字段名不一样 ，怎么办"></a>7、当实体类中的属性名和表中的字段名不一样 ，怎么办</h2><p>第1种： 通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">”selectorder”</span> <span class="attr">parametertype</span>=<span class="string">”int”</span> <span class="attr">resultetype</span>=<span class="string">”me.gacl.domain.order”</span>&gt;</span></span><br><span class="line">   select order_id id, order_no orderno ,order_price price form orders where order_id=#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第2种： 通过&lt; resultMap &gt;来映射字段名和实体类属性名的一一对应的关系。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getOrder"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"orderresultmap"</span>&gt;</span></span><br><span class="line">       select * from orders where order_id=#&#123;id&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">”me.gacl.domain.order”</span> <span class="attr">id</span>=<span class="string">”orderresultmap”</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">!–用id属性来映射主键字段–</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">”id”</span> <span class="attr">column</span>=<span class="string">”order_id”</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">!–用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性–</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span> = <span class="string">“orderno”</span> <span class="attr">column</span> =<span class="string">”order_no”/</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">”price”</span> <span class="attr">column</span>=<span class="string">”order_price”</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">reslutMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="8、-模糊查询like语句该怎么写"><a href="#8、-模糊查询like语句该怎么写" class="headerlink" title="8、 模糊查询like语句该怎么写"></a>8、 模糊查询like语句该怎么写</h2><p>第1种：在Java代码中添加sql通配符。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string wildcardname = “%smi%”;</span><br><span class="line">list<span class="tag">&lt;<span class="name">name</span>&gt;</span> names = mapper.selectlike(wildcardname);</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">”selectlike”</span>&gt;</span></span><br><span class="line"> select * from foo where bar like #&#123;value&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第2种：在sql语句中拼接通配符，会引起sql注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string wildcardname = “smi”;</span><br><span class="line">list<span class="tag">&lt;<span class="name">name</span>&gt;</span> names = mapper.selectlike(wildcardname);</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">”selectlike”</span>&gt;</span></span><br><span class="line">     select * from foo where bar like "%"$&#123;value&#125;"%"</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="9、通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗"><a href="#9、通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗" class="headerlink" title="9、通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗"></a>9、通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗</h2><p>Dao接口即Mapper接口。接口的全限名，就是映射文件中的namespace的值；接口的方法名，就是映射文件中Mapper的Statement的id值；接口方法内的参数，就是传递给sql的参数。</p><p>Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MapperStatement。在Mybatis中，每一个&lt; select &gt;、&lt; insert &gt;、&lt; update &gt;、&lt; delete &gt;标签，都会被解析为一个MapperStatement对象。</p><p>Mapper接口里的方法，是不能重载的，因为是使用 全限名+方法名 的保存和寻找策略。Mapper 接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Mapper接口生成代理对象proxy，代理对象会拦截接口方法，转而执行MapperStatement所代表的sql，然后将sql执行结果返回。</p><h2 id="10、Mybatis是如何进行分页的？分页插件的原理是什么"><a href="#10、Mybatis是如何进行分页的？分页插件的原理是什么" class="headerlink" title="10、Mybatis是如何进行分页的？分页插件的原理是什么"></a>10、Mybatis是如何进行分页的？分页插件的原理是什么</h2><p>Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页。可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p><pre><code>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</code></pre><h2 id="11、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式"><a href="#11、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式" class="headerlink" title="11、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式"></a>11、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式</h2><p>第一种是使用&lt; resultMap &gt;标签，逐一定义数据库列名和对象属性名之间的映射关系。</p><p>第二种是使用sql列的别名功能，将列的别名书写为对象属性名。</p><p>有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p><h2 id="12、如何执行批量插入"><a href="#12、如何执行批量插入" class="headerlink" title="12、如何执行批量插入"></a>12、如何执行批量插入</h2><p>首先,创建一个简单的insert语句:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">”insertname”</span>&gt;</span></span><br><span class="line">     insert into names (name) values (#&#123;value&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在java代码中像下面这样执行批处理插入:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; names = <span class="keyword">new</span> arraylist();</span><br><span class="line">  names.add(“fred”);</span><br><span class="line">  names.add(“barney”);</span><br><span class="line">  names.add(“betty”);</span><br><span class="line">  names.add(“wilma”);</span><br><span class="line">  <span class="comment">// 注意这里 executortype.batch</span></span><br><span class="line">  sqlsession sqlsession = sqlsessionfactory.opensession(executortype.batch);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   namemapper mapper = sqlsession.getmapper(namemapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   <span class="keyword">for</span> (string name : names) &#123;</span><br><span class="line">       mapper.insertname(name);</span><br><span class="line">   &#125;</span><br><span class="line">   sqlsession.commit();</span><br><span class="line">  &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">   sqlSession.rollback();</span><br><span class="line">   <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">finally</span> &#123;</span><br><span class="line">       sqlsession.close();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="13、如何获取自动生成的-主-键值"><a href="#13、如何获取自动生成的-主-键值" class="headerlink" title="13、如何获取自动生成的(主)键值"></a>13、如何获取自动生成的(主)键值</h2><p>insert 方法总是返回一个int值 ，这个值代表的是插入的行数。</p><p>如果采用自增长策略，自动生成的键值在 insert 方法执行完后可以被设置到传入的参数对象中。</p><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">”insertname”</span> <span class="attr">usegeneratedkeys</span>=<span class="string">”true”</span> <span class="attr">keyproperty</span>=<span class="string">”id”</span>&gt;</span></span><br><span class="line">     insert into names (name) values (#&#123;name&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    name name = <span class="keyword">new</span> name();</span><br><span class="line">name.setname(“fred”);</span><br><span class="line"><span class="keyword">int</span> rows = mapper.insertname(name);</span><br><span class="line"><span class="comment">// 完成后,id已经被设置到对象中</span></span><br><span class="line">system.out.println(“rows inserted = ” + rows);</span><br><span class="line">system.out.println(“generated key value = ” + name.getid());</span><br></pre></td></tr></table></figure><p>14、在mapper中如何传递多个参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）第一种：</span><br><span class="line"><span class="comment">//DAO层的函数</span></span><br><span class="line"><span class="function">Public <span class="title">UserselectUser</span><span class="params">(String name,String area)</span></span>;  </span><br><span class="line"><span class="comment">//对应的xml,#&#123;0&#125;代表接收的是dao层中的第一个参数，#&#123;1&#125;代表dao层中第二参数，更多参数一致往后加即可。</span></span><br><span class="line">&lt;select id=<span class="string">"selectUser"</span>resultMap=<span class="string">"BaseResultMap"</span>&gt;  </span><br><span class="line">    select *  fromuser_user_t   whereuser_name = #&#123;0&#125; anduser_area=#&#123;1&#125;  </span><br><span class="line">&lt;/select&gt;  </span><br><span class="line">（<span class="number">2</span>）第二种： 使用 <span class="meta">@param</span> 注解:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">usermapper</span> </span>&#123;</span><br><span class="line">   <span class="function">user <span class="title">selectuser</span><span class="params">(@param(“username”)</span> string username,@<span class="title">param</span><span class="params">(“hashedpassword”)</span> string hashedpassword)</span>;</span><br><span class="line">&#125;</span><br><span class="line">然后,就可以在xml像下面这样使用(推荐封装为一个map,作为单个参数传递给mapper):</span><br><span class="line">&lt;select id=”selectuser” resulttype=”user”&gt;</span><br><span class="line">         select id, username, hashedpassword</span><br><span class="line">         from some_table</span><br><span class="line">         where username = #&#123;username&#125;</span><br><span class="line">         and hashedpassword = #&#123;hashedpassword&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">（<span class="number">3</span>）第三种：多个参数封装成map</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//映射文件的命名空间.SQL片段的ID，就可以调用对应的映射文件中的SQL</span></span><br><span class="line"><span class="comment">//由于我们的参数超过了两个，而方法中只有一个Object参数收集，因此我们使用Map集合来装载我们的参数</span></span><br><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">     map.put(<span class="string">"start"</span>, start);</span><br><span class="line">     map.put(<span class="string">"end"</span>, end);</span><br><span class="line">     <span class="keyword">return</span> sqlSession.selectList(<span class="string">"StudentID.pagination"</span>, map);</span><br><span class="line"> &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">     sqlSession.rollback();</span><br><span class="line">    <span class="keyword">throw</span> e; &#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line"> MybatisUtil.closeSqlSession();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="15、Mybatis动态sql有什么用？执行原理？有哪些动态sql"><a href="#15、Mybatis动态sql有什么用？执行原理？有哪些动态sql" class="headerlink" title="15、Mybatis动态sql有什么用？执行原理？有哪些动态sql"></a>15、Mybatis动态sql有什么用？执行原理？有哪些动态sql</h2><p>Mybatis动态sql可以在Xml映射文件内，以标签的形式编写动态sql，执行原理是根据表达式的值 完成逻辑判断并动态拼接sql的功能。</p><p>Mybatis提供了9种动态sql标签：trim | where | set | foreach | if | choose | when | otherwise | bind。</p><h2 id="16、Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签"><a href="#16、Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签" class="headerlink" title="16、Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签"></a>16、Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签</h2><p>答：&lt; resultMap &gt;、&lt; parameterMap &gt;、&lt; sql &gt;、&lt; include &gt;、&lt; selectKey &gt;，加上动态sql的9个标签，其中&lt; sql &gt;为sql片段标签，通过&lt; include &gt;标签引入sql片段，&lt; selectKey &gt;为不支持自增的主键生成策略标签。</p><h2 id="17、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复"><a href="#17、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复" class="headerlink" title="17、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复"></a>17、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复</h2><p>不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；</p><p>原因就是namespace+id是作为Map&lt;String, MapperStatement&gt;的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。</p><p>但是，在以前的Mybatis版本的namespace是可选的，不过新版本的namespace已经是必须的了。</p><h2 id="18、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里"><a href="#18、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里" class="headerlink" title="18、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里"></a>18、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里</h2><p>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p><h2 id="19、-一对一、一对多的关联查询"><a href="#19、-一对一、一对多的关联查询" class="headerlink" title="19、 一对一、一对多的关联查询"></a>19、 一对一、一对多的关联查询</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.lcb.mapping.userMapper"</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--association  一对一关联查询 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getClass"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"ClassesResultMap"</span>&gt;</span>  </span><br><span class="line">        select * from class c,teacher t where c.teacher_id=t.t_id and c.c_id=#&#123;id&#125;  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.lcb.user.Classes"</span> <span class="attr">id</span>=<span class="string">"ClassesResultMap"</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 实体类的字段名和数据表的字段名映射 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"c_id"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"c_name"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"teacher"</span> <span class="attr">javaType</span>=<span class="string">"com.lcb.user.Teacher"</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"t_id"</span>/&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"t_name"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--collection  一对多关联查询 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getClass2"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"ClassesResultMap2"</span>&gt;</span>  </span><br><span class="line">        select * from class c,teacher t,student s where c.teacher_id=t.t_id and c.c_id=s.class_id and c.c_id=#&#123;id&#125;  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.lcb.user.Classes"</span> <span class="attr">id</span>=<span class="string">"ClassesResultMap2"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"c_id"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"c_name"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"teacher"</span> <span class="attr">javaType</span>=<span class="string">"com.lcb.user.Teacher"</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"t_id"</span>/&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"t_name"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"student"</span> <span class="attr">ofType</span>=<span class="string">"com.lcb.user.Student"</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"s_id"</span>/&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"s_name"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="20、MyBatis实现一对一有几种方式-具体怎么操作的"><a href="#20、MyBatis实现一对一有几种方式-具体怎么操作的" class="headerlink" title="20、MyBatis实现一对一有几种方式?具体怎么操作的"></a>20、MyBatis实现一对一有几种方式?具体怎么操作的</h2><p>有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次, 通过在resultMap里面配置association节点配置一对一的类就可以完成；</p><p>嵌套查询是先查一个表，根据这个表里面的结果的 外键id，去再另外一个表里面查询数据,也是通过association配置，但另外一个表的查询通过select属性配置。</p><h2 id="21、MyBatis实现一对多有几种方式-怎么操作的"><a href="#21、MyBatis实现一对多有几种方式-怎么操作的" class="headerlink" title="21、MyBatis实现一对多有几种方式,怎么操作的"></a>21、MyBatis实现一对多有几种方式,怎么操作的</h2><p>有联合查询和嵌套查询。联合查询是几个表联合查询,只查询一次,通过在resultMap里面的collection节点配置一对多的类就可以完成；嵌套查询是先查一个表,根据这个表里面的 结果的外键id,去再另外一个表里面查询数据,也是通过配置collection,但另外一个表的查询通过select节点配置。</p><h2 id="22、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么"><a href="#22、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么" class="headerlink" title="22、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么"></a>22、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么</h2><p>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。</p><p>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p><p>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p><h2 id="23、Mybatis的一级、二级缓存"><a href="#23、Mybatis的一级、二级缓存" class="headerlink" title="23、Mybatis的一级、二级缓存"></a>23、Mybatis的一级、二级缓存</h2><p>1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</p><p>2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置&lt; cache/ &gt; ；</p><p>3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear 掉并重新更新，如果开启了二级缓存，则只根据配置判断是否刷新。</p><h2 id="24、什么是MyBatis的接口绑定？有哪些实现方式"><a href="#24、什么是MyBatis的接口绑定？有哪些实现方式" class="headerlink" title="24、什么是MyBatis的接口绑定？有哪些实现方式"></a>24、什么是MyBatis的接口绑定？有哪些实现方式</h2><p>接口绑定，就是在MyBatis中任意定义接口,然后把接口里面的方法和SQL语句绑定, 我们直接调用接口方法就可以,这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。</p><p>接口绑定有两种实现方式,一种是通过注解绑定，就是在接口的方法上面加上 @Select、@Update等注解，里面包含Sql语句来绑定；另外一种就是通过xml里面写SQL来绑定, 在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名。当Sql语句比较简单时候,用注解绑定, 当SQL语句比较复杂时候,用xml绑定,一般用xml绑定的比较多。</p><h2 id="25、使用MyBatis的mapper接口调用时有哪些要求"><a href="#25、使用MyBatis的mapper接口调用时有哪些要求" class="headerlink" title="25、使用MyBatis的mapper接口调用时有哪些要求"></a>25、使用MyBatis的mapper接口调用时有哪些要求</h2><ul><li>①  Mapper接口方法名和mapper.xml中定义的每个sql的id相同；</li><li>②  Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同；</li><li>③  Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同；</li><li>④  Mapper.xml文件中的namespace即是mapper接口的类路径。</li></ul><h2 id="26、Mapper编写有哪几种方式"><a href="#26、Mapper编写有哪几种方式" class="headerlink" title="26、Mapper编写有哪几种方式"></a>26、Mapper编写有哪几种方式</h2><p>第一种：接口实现类继承SqlSessionDaoSupport：使用此种方法需要编写mapper接口，mapper接口实现类、mapper.xml文件。</p><ul><li>（1）在sqlMapConfig.xml中配置mapper.xml的位置</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"mapper.xml文件的地址"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"mapper.xml文件的地址"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>（2）定义mapper接口</li><li>（3）实现类集成SqlSessionDaoSupport<br>mapper方法中可以this.getSqlSession()进行数据增删改查。</li><li>（4）spring 配置</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">" "</span> <span class="attr">class</span>=<span class="string">"mapper接口的实现"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二种：使用org.mybatis.spring.mapper.MapperFactoryBean：</p><ul><li>（1）在sqlMapConfig.xml中配置mapper.xml的位置，如果mapper.xml和mappre接口的名称相同且在同一个目录，这里可以不用配置</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;mappers&gt;</span><br><span class="line">    &lt;mapper resource=<span class="string">"mapper.xml文件的地址"</span> /&gt;</span><br><span class="line">    &lt;mapper resource=<span class="string">"mapper.xml文件的地址"</span> /&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure><ul><li>（2）定义mapper接口：<br>①mapper.xml中的namespace为mapper接口的地址<br>②mapper接口中的方法名和mapper.xml中的定义的statement的id保持一致<br>③Spring中定义</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">""</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.mybatis.spring.mapper.MapperFactoryBean"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"mapperInterface"</span>   value=<span class="string">"mapper接口地址"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"sqlSessionFactory"</span> ref=<span class="string">"sqlSessionFactory"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>第三种：使用mapper扫描器：</p><ul><li>（1）mapper.xml文件编写：<br>mapper.xml中的namespace为mapper接口的地址；<br>mapper接口中的方法名和mapper.xml中的定义的statement的id保持一致；<br>如果将mapper.xml和mapper接口的名称保持一致则不用在sqlMapConfig.xml中进行配置。</li><li>（2）定义mapper接口：<br>注意mapper.xml的文件名和mapper的接口名称保持一致，且放在同一个目录</li><li>（3）配置mapper扫描器：</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span><br><span class="line">    &lt;property name="basePackage" value="mapper接口包地址"&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">"sqlSessionFactoryBeanName"</span> value=<span class="string">"sqlSessionFactory"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>（4）使用扫描器后从spring容器中获取mapper的实现对象。</p><h2 id="27、简述Mybatis的插件运行原理，以及如何编写一个插件"><a href="#27、简述Mybatis的插件运行原理，以及如何编写一个插件" class="headerlink" title="27、简述Mybatis的插件运行原理，以及如何编写一个插件"></a>27、简述Mybatis的插件运行原理，以及如何编写一个插件</h2><p>Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</p><p>编写插件：实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pycharm搭建Selenium、Python自动化环境</title>
      <link href="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/"/>
      <url>/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/python.jpg" alt="我用Python"><br><a href="https://pan.baidu.com/s/1tiwcFLKU11WpmJ4flgNjMg" target="_blank" rel="noopener">Pycharm、Python</a>下载<br>提取码：ided</p><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><h3 id="Python安装"><a href="#Python安装" class="headerlink" title="Python安装"></a>Python安装</h3><a id="more"></a><p><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/python%E4%B8%8B%E8%BD%BD%E6%89%80%E5%9C%A8%E7%9B%AE%E5%BD%95.jpg" alt="下载文件所在目录"></p><p>勾选<strong>Add Python to Path</strong>添加环境变量</p><p><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/%E5%AE%89%E8%A3%85.jpg" alt="进行安装"></p><p>点击<strong>install</strong>进行安装</p><p>验证Python和环境变量是否配置成功：</p><p>win+r 输入cmd以管理员方式运行，在dos窗口下输入python出现如下窗口则说明你就成功啦<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/%E6%9F%A5%E7%9C%8BPython.jpg" alt="查看Python"></p><hr><h3 id="安装Pycharm"><a href="#安装Pycharm" class="headerlink" title="安装Pycharm"></a>安装Pycharm</h3><p>点击安装Pycharm<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/Pycharm.jpg" alt="Pycharm"></p><p>安装好后，点击启动后，点击新建项目，配置Project Interpreter下Base interpreter中选择刚刚安装的python文件，此时创建，则pycharm的python环境搭建完成，参考图见下：<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/Pycharm%E9%85%8D%E7%BD%AE.jpg" alt="Pycharm配置"></p><p>以上pycharm中的python环境已搭建完成，我们现在开始配置selenium环境；</p><hr><h3 id="安装Selenium"><a href="#安装Selenium" class="headerlink" title="安装Selenium"></a>安装Selenium</h3><p>点击pycharm的File-Settings-Project:Pycharm-Project Interpreter，点击窗口右侧绿色的“+”按钮，搜索“selenium”，搜索后点击添加，安装OK之后，如图中所示，直接会在窗口中显示<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/Selenium%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85.jpg" alt="Selenium下载安装"></p><p>安装成功之后，就会显示在面板上，如下图：<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/selenium%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.jpg" alt="selenium安装成功"></p><p><strong><em>接下来我们就可以愉快的写我们的自动化测试代码啦！</em></strong></p><p><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/%E5%86%B2%E9%B8%AD.jpg" alt="***冲鸭！***"></p><h2 id="自动化搭建"><a href="#自动化搭建" class="headerlink" title="自动化搭建"></a>自动化搭建</h2><h3 id="确定当前浏览器版本"><a href="#确定当前浏览器版本" class="headerlink" title="确定当前浏览器版本"></a>确定当前浏览器版本</h3><p>确定好Chrome浏览器版本号，浏览器右上角三个点-帮助-关于Google Chrome，就能看到当前版本号，我的是版本是81.0.4044.113（正式版本）（64 位），确定好之后接下来我们要去找到对应的chromedirver驱动；<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/chrome%E7%89%88%E6%9C%AC.jpg" alt="Chrome版本"></p><h2 id="下载对应版本驱动chromedriver"><a href="#下载对应版本驱动chromedriver" class="headerlink" title="下载对应版本驱动chromedriver"></a>下载对应版本驱动chromedriver</h2><p>这里我们依赖淘宝的镜像下载<a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">ChromeDriver</a></p><p>注意下载的版本要一致，我们这里下载的是81.0.4044.69<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/%E4%B8%8B%E8%BD%BD%E7%9A%84chromedriver%E7%89%88%E6%9C%AC.jpg" alt="chromedriver版本"></p><p> 下载chromedriver后，将chromedriver文件放到python目录下<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/chromedriver%E5%AD%98%E6%94%BE%E7%9B%AE%E5%BD%95.jpg" alt="chromedriver存放目录"></p><h2 id="用例编写测试"><a href="#用例编写测试" class="headerlink" title="用例编写测试"></a>用例编写测试</h2><h3 id="启动pycharm，创建一个项目，File-New-Project-Location，更改位置，创建test项目"><a href="#启动pycharm，创建一个项目，File-New-Project-Location，更改位置，创建test项目" class="headerlink" title="启动pycharm，创建一个项目，File-New Project-Location，更改位置，创建test项目"></a>启动pycharm，创建一个项目，File-New Project-Location，更改位置，创建test项目</h3><p><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/testProject.jpg" alt="test"></p><h3 id="在test下创建一个python-package"><a href="#在test下创建一个python-package" class="headerlink" title="在test下创建一个python package"></a>在test下创建一个python package</h3><p>  右击test-New-Python Package，输入包名：testbag;<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/testbag.jpg" alt="testbag"></p><h3 id="包下创建一个Python文件"><a href="#包下创建一个Python文件" class="headerlink" title="包下创建一个Python文件"></a>包下创建一个Python文件</h3><p>  右击testbag-New-Python File，输入名字：testDemo<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/testDemo.jpg" alt="testDemo"></p><h3 id="写代码通过谷歌浏览器访问TheOak"><a href="#写代码通过谷歌浏览器访问TheOak" class="headerlink" title="写代码通过谷歌浏览器访问TheOak"></a>写代码通过谷歌浏览器访问<a href="http://www.theoak.online/" target="_blank" rel="noopener">TheOak</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">"http://www.theoak.online/"</span>)</span><br><span class="line">time.sleep(<span class="number">10</span>)</span><br><span class="line">driver.close()</span><br></pre></td></tr></table></figure><p>右键直接run就可以了，当浏览器能自动打开，就证明一切OK了，就像这样呀<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/TheOak.jpg" alt="TheOak"><br>以上selenium+pycharm 自动化环境搭建完成了</p><p>今天又是美好的一天，加油呀！铁铁<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/%E5%8A%A0%E6%B2%B9%E9%B8%AD%EF%BC%81.jpg" alt="加油鸭！"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pycharm </tag>
            
            <tag> Selenium </tag>
            
            <tag> Python </tag>
            
            <tag> 测试 </tag>
            
            <tag> chromdriver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java_Github_Crawler</title>
      <link href="/2020/03/21/Java-Github-Crawler/"/>
      <url>/2020/03/21/Java-Github-Crawler/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="java-github-crawler"><a href="#java-github-crawler" class="headerlink" title="java_github_crawler"></a>java_github_crawler</h2><blockquote><p>爬取Github上的一些java中的知名项目，做一个简单的类似GitHub趋势功能的程序。在awesome-java项目中可以看到很多的java开源的第三方库和框架，点进去可以看到很具体的页面后，可以看到该项目中的一些具体信息(star,fork,open_issue)，于是收集这些项目的这些属性，衡量出这一大堆项目中，哪些项目是比较活跃和流行的，最终需求，是给awesome-java这个项目中提到的所有的github上的项目按照活跃程度进行排序。形成一个类似于Github趋势的小程序。</p></blockquote><hr><h3 id="获取所有待收集信息的项目列表"><a href="#获取所有待收集信息的项目列表" class="headerlink" title="获取所有待收集信息的项目列表"></a>获取所有待收集信息的项目列表</h3><p>使用爬虫程序，获取到<a href="https://github.com/akullpp/awesome-java/blob/master/README.md" target="_blank" rel="noopener">awesome-java</a>这个页面的内容，进而知道所有项目的链接信息。<br>分析页面的结构，可以看到，入口页面中包含很多url，每个url中又有很多a标签，a标签中href属性里的url就是我们要获到的内容。</p><h4 id="如何获取页面内容：构造一个http请求发送给服务器"><a href="#如何获取页面内容：构造一个http请求发送给服务器" class="headerlink" title="如何获取页面内容：构造一个http请求发送给服务器"></a>如何获取页面内容：构造一个http请求发送给服务器</h4><p>通过<a href="https://square.github.io/okhttp/" target="_blank" rel="noopener">OkHttp</a>这个库，就能根据url获取到对应的页面的内容，内容一般是一个html页面,具体使用方法参考<a href="https://square.github.io/okhttp/" target="_blank" rel="noopener">官方文档</a>。</p><blockquote><p>OkHttp这个库是使用Kotlin(一种编程语言，和java类似，都是把代码编译生成JVM的字节码)</p></blockquote><h4 id="如何分析页面结构"><a href="#如何分析页面结构" class="headerlink" title="如何分析页面结构"></a>如何分析页面结构</h4><p>采用<a href="https://jsoup.org/" target="_blank" rel="noopener">JSoup</a>分析网页结构，JSoup是一个用于处理实际HTML的Java库。它使用HTML5最佳DOM方法和CSS选择器，为获取URL以及提取和处理数据提供了非常方便的API。，具体使用参考官方文档。</p><p>HTML是一个树形结构，JSoup中的Document对象对应着一个树形结构。树中的每个标签，就是一个Element对象，把很多标签放在一起构成的集合，就是Elements。</p><ul><li>先获取li标签得到Element对象针对这个对象再次findElementByTag(“a”)获取到a标签中的内容</li><li>JSoup支持CSS风格的选择器语法。</li></ul><hr><h3 id="遍历项目列表，依次获取到每个项目的主页信息，进一步就可以知道该项目的star-fork-open-issue"><a href="#遍历项目列表，依次获取到每个项目的主页信息，进一步就可以知道该项目的star-fork-open-issue" class="headerlink" title="遍历项目列表，依次获取到每个项目的主页信息，进一步就可以知道该项目的star fork open_issue"></a>遍历项目列表，依次获取到每个项目的主页信息，进一步就可以知道该项目的star fork open_issue</h3><h4 id="通过API来获取某个项目-仓库的相关信息"><a href="#通过API来获取某个项目-仓库的相关信息" class="headerlink" title="通过API来获取某个项目/仓库的相关信息"></a>通过API来获取某个项目/仓库的相关信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https:&#x2F;&#x2F;api.github.com&#x2F;repos&#x2F;[用户名]&#x2F;[仓库名]</span><br></pre></td></tr></table></figure><h4 id="通过JSON数据格式保存相关信息"><a href="#通过JSON数据格式保存相关信息" class="headerlink" title="通过JSON数据格式保存相关信息"></a>通过JSON数据格式保存相关信息</h4><p>Github API获取到的数据格式是JSON格式是一种非常广泛使用的数据组织格式,特点是以键值对的的方式来组织数据。基本规则: {}包裹里面包含若干个键值对.键值对和键值对之间使用,分割。键和值之间使用:分割，进而获取要爬取的关键信息(每个项目的相关指标)，以JSON格式保存。</p><p>Java中有很多第三方库帮我们解析，JSON源自于JavaScript这个语言。通过JSON来表示对象。JSON比XML好用很多。GSON google出品的一个JSON解析库。</p><hr><h3 id="把这些数据保存到数据库中"><a href="#把这些数据保存到数据库中" class="headerlink" title="把这些数据保存到数据库中"></a>把这些数据保存到数据库中</h3><h4 id="创建表结构"><a href="#创建表结构" class="headerlink" title="创建表结构"></a>创建表结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create database java_github_crawler;</span><br><span class="line">use java_github_crawler;</span><br><span class="line">create table project_table(</span><br><span class="line">    name varchar(50),url varchar(1024),</span><br><span class="line">    description varchar(1024),starCount int,</span><br><span class="line">    forkCount int, openedIssueCount int, date varchar(128)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="实现ProjectDao"><a href="#实现ProjectDao" class="headerlink" title="实现ProjectDao"></a>实现ProjectDao</h4><p>先创建Connection,再根据Connection创建PrepareStatement，通过PrepareStatement获取到ResultSet。关闭的时候,也要先关闭ResultSet,然后关闭PrepareStatement,最后关闭Connection。</p><h4 id="抓取时可能出现的问题"><a href="#抓取时可能出现的问题" class="headerlink" title="抓取时可能出现的问题"></a>抓取时可能出现的问题</h4><h5 id="1-出现异常"><a href="#1-出现异常" class="headerlink" title="1.出现异常"></a>1.出现异常</h5><p>当前这个url对应的不是一个github的项目.前面把这些不是项目的url放到一个黑名单里面了(没放干净)。我们真正应该保证的是,抓取过程中任何一个项目出现异常,不要影响到后面的抓取.用try catch把抓取的循环包裹起来。</p><h5 id="2-程序执行速度太慢了-如何进行性能优化"><a href="#2-程序执行速度太慢了-如何进行性能优化" class="headerlink" title="2.程序执行速度太慢了.如何进行性能优化"></a>2.程序执行速度太慢了.如何进行性能优化</h5><p>打印出每个环节的时间，可以看到性能最差的就是循环调用Github API这个操作是访问网络;访问的还是一个外国的服务器。<br>大量的时间都消耗在等待服务器响应上了。一次服务器的响应时间， 这基本是固定. (取决于网络环境)<br>实现批量发送的方式，有很多种方式使用多线程方式来发送数据。例如我想批量发送10个数据就创建10个线程.每个线程负责等待自己的结构</p><hr><h3 id="写一个简单网页服务器，来展示数据库中的数据-通过图表的的形式，看到一个更直观的排名效果"><a href="#写一个简单网页服务器，来展示数据库中的数据-通过图表的的形式，看到一个更直观的排名效果" class="headerlink" title="写一个简单网页服务器，来展示数据库中的数据(通过图表的的形式，看到一个更直观的排名效果)"></a>写一个简单网页服务器，来展示数据库中的数据(通过图表的的形式，看到一个更直观的排名效果)</h3><ul><li>1.扩充ProjectDao类,新增一个方法,能够按照指定日期来获取数据库中的信息</li><li>2.写一个简单的Servlet,提供-个HTTP的接口，让前端可以通过这个接口来获取到数据</li><li>3.写一个网页,在网页上获取到数据,并展示成图表EChart 百度提供的一个开源的图表组件，使用方法具体参考<br><a href="https://www.echartsjs.com/zh/tutorial.html#5%20%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8B%20ECharts" target="_blank" rel="noopener">官方文档</a><br><a href="https://www.echartsjs.com/zh/builder.html" target="_blank" rel="noopener">下载安装</a></li></ul><hr><p><a href="http://47.93.16.83:8080/java_github_crawler/index.html" target="_blank" rel="noopener">项目演示</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Github </tag>
            
            <tag> Crawler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lombok可真香！！！</title>
      <link href="/2020/03/19/Lombok%E5%8F%AF%E7%9C%9F%E9%A6%99%EF%BC%81%EF%BC%81%EF%BC%81/"/>
      <url>/2020/03/19/Lombok%E5%8F%AF%E7%9C%9F%E9%A6%99%EF%BC%81%EF%BC%81%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Lombok到底是什么"><a href="#Lombok到底是什么" class="headerlink" title="Lombok到底是什么"></a>Lombok到底是什么</h3><p>先看一下它的官网<br><img src="/2020/03/19/Lombok%E5%8F%AF%E7%9C%9F%E9%A6%99%EF%BC%81%EF%BC%81%EF%BC%81/Lombok%E5%AE%98%E7%BD%91.jpg" alt="Lombok官网"><br><strong>大致意思是</strong>：Lombok项目是一个Java库，它会自动插入您的编辑器和构建工具中，从而为您的Java增光添彩。永远不要再编写另一个getter或equals方法，带有一个注释的类将具有功能全面的生成器，自动执行日志记录变量等等。</p><p>听起来好像是挺不错吼，亲自尝试一下吧！</p><hr><h3 id="项目中引入Lombok"><a href="#项目中引入Lombok" class="headerlink" title="项目中引入Lombok"></a>项目中引入Lombok</h3><a id="more"></a><p>首先在项目的 pom.xml中引入 Lombok依赖：</p><p>如果不知道如何导入的话，可以在<a href="https://mvnrepository.com/" target="_blank" rel="noopener">MvnRepository</a>进行查找一下，是不是就很nice。<br><img src="/2020/03/19/Lombok%E5%8F%AF%E7%9C%9F%E9%A6%99%EF%BC%81%EF%BC%81%EF%BC%81/MvnRepository.jpg" alt="MvnRepository"><br>接下来你就会看到如下界面<br><img src="/2020/03/19/Lombok%E5%8F%AF%E7%9C%9F%E9%A6%99%EF%BC%81%EF%BC%81%EF%BC%81/Choose.jpg" alt="ChooseLombok"><br><strong>选择安装版本</strong><br>一般我们选择使用人数多且不是最新版本的，于是我们选择1.18.8<br><img src="/2020/03/19/Lombok%E5%8F%AF%E7%9C%9F%E9%A6%99%EF%BC%81%EF%BC%81%EF%BC%81/version.jpg" alt="version"><br>于是乎我们复制这段代码到pom.xml中引入 Lombok依赖：<br><img src="/2020/03/19/Lombok%E5%8F%AF%E7%9C%9F%E9%A6%99%EF%BC%81%EF%BC%81%EF%BC%81/%E5%AF%BC%E5%85%A5%E4%BE%9D%E8%B5%96.jpg" alt="导入依赖"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.projectlombok&#x2F;lombok --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.18.8&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>项目中导入<img src="/2020/03/19/Lombok%E5%8F%AF%E7%9C%9F%E9%A6%99%EF%BC%81%EF%BC%81%EF%BC%81/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%AF%BC%E5%85%A5.jpg" alt=" "><br>接下来就是愉快的代码环节了。</p><hr><h3 id="get-set-toString不用写了"><a href="#get-set-toString不用写了" class="headerlink" title="get/set/toString不用写了"></a>get/set/toString不用写了</h3><p>定义一个课程 Course，需要自己手动写上每个字段的 get()和 set()方法以及toString()方法，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Dao;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：Eric</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020/3/19 21:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;    <span class="comment">// 课程ID</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 课程名称</span></span><br><span class="line">    <span class="keyword">private</span> Integer score;  <span class="comment">// 课程成绩</span></span><br><span class="line">    <span class="comment">// 自己手写下面的 get/set/toString 方法！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(Integer score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Course&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", score="</span> + score +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是借助于Lombok，一切都变得优雅起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：Eric</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020/3/19 21:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> Long id;    <span class="comment">// 课程ID</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 课程名称</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> Integer score;  <span class="comment">// 课程成绩</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个注解：@Getter、@Setter和@ToString即可方便搞定。</p><hr><h3 id="new对象变得优雅了"><a href="#new对象变得优雅了" class="headerlink" title="new对象变得优雅了"></a>new对象变得优雅了</h3><p>在没有用Lombok之前，我们假如想new一个对象，我们往往会这么做（以上面的 Course类为例）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Course course = <span class="keyword">new</span> Course(); <span class="comment">//首先new一个对象</span></span><br><span class="line">      <span class="comment">//逐步去填充各个字段</span></span><br><span class="line">  course.setId(<span class="number">124l</span>);</span><br><span class="line">  course.setName(<span class="string">"javaWeb"</span>);</span><br><span class="line">  course.setScore(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>引进Lombok之后，我们只需要在 Course类上用上 @Builder注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> Long id;    <span class="comment">// 课程ID</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 课程名称</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> Integer score;  <span class="comment">// 课程成绩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则 Course类对象的创建即可使用 链式表达 的方式一行代码完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ourse course = Course.builder().id(<span class="number">123l</span>).name(<span class="string">"javaWeb"</span>).score(<span class="number">100</span>).build();</span><br></pre></td></tr></table></figure><p>Builder注解就是一个典型的“建造者模式”的实现案例</p><hr><h3 id="构造函数不用写了"><a href="#构造函数不用写了" class="headerlink" title="构造函数不用写了"></a>构造函数不用写了</h3><p>1、全参构造器不用写了</p><p>当你在你的类上使用了Lombok的注解 AllArgsConstructor时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：Eric</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020/3/19 21:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;    <span class="comment">// 课程ID</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 课程名称</span></span><br><span class="line">    <span class="keyword">private</span> Integer score;  <span class="comment">// 课程成绩</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候你的类在编译后会自动生成一个无参构造函数，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：Eric</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020/3/19 21:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;    <span class="comment">// 课程ID</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 课程名称</span></span><br><span class="line">    <span class="keyword">private</span> Integer score;  <span class="comment">// 课程成绩</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Course</span><span class="params">(Long id, String name, Integer score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、无参数构造器也不用写了</p><p>当你在你的类上使用了Lombok的注解 NoArgsConstructor时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：Eric</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020/3/19 21:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;    <span class="comment">// 课程ID</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 课程名称</span></span><br><span class="line">    <span class="keyword">private</span> Integer score;  <span class="comment">// 课程成绩</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候你的类在编译后会自动生成一个无参构造函数，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：Eric</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020/3/19 21:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;    <span class="comment">// 课程ID</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 课程名称</span></span><br><span class="line">    <span class="keyword">private</span> Integer score;  <span class="comment">// 课程成绩</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lombok自动会帮你生成一个无参构造器！！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Course</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、部分参数构造器也不用写了</p><p>当你在你的类上使用了Lombok的注解 RequiredArgsConstructor时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：Eric</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020/3/19 21:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;    <span class="comment">// 课程ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;    <span class="comment">// 课程名称</span></span><br><span class="line">    <span class="keyword">private</span> Integer score;  <span class="comment">// 课程成绩</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候你的类在编译后会自动生成一个具备部分参数的构造函数，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：Eric</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020/3/19 21:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;    <span class="comment">// 课程ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;    <span class="comment">// 课程名称</span></span><br><span class="line">    <span class="keyword">private</span> Integer score;  <span class="comment">// 课程成绩</span></span><br><span class="line">    <span class="comment">// 因为name字段定义成final，所以Lombok自动会帮你生成一个部分参数的构造器！！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Course</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="null判空不用写了"><a href="#null判空不用写了" class="headerlink" title="null判空不用写了"></a>null判空不用写了</h3><p>Lombok的 @NonNull注解可以自动帮我们避免空指针判断。该注解作用在方法参数上，用于自动生成空值参数检查，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">JudgeNull</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (name == <span class="keyword">null</span>)&#123;</span><br><span class="line">          System.out.println(<span class="string">"参数为空"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(name);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>大批量的判空会不会让你感到烦躁呢？但是有了Lombok之后，事情就变得简单了，一个注解搞定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">JudgeNull</span><span class="params">(@NonNull String name)</span></span>&#123;</span><br><span class="line">       System.out.println(name);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="再也不用收尾了"><a href="#再也不用收尾了" class="headerlink" title="再也不用收尾了"></a>再也不用收尾了</h3><p>比如我们打开一个 txt文本文件亦或是调用Scanner输入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileReader fileReader = <span class="keyword">null</span>;</span><br><span class="line">            fileReader = <span class="keyword">new</span> FileReader(<span class="string">"Lombok.txt"</span>);</span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(fileReader);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(br.readLine());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>注意，这个文件句柄在使用完成之后是一定要手动 close的，否则就有可能资源泄漏。有了Lombok之后，这些统统不用干了，一个 @Cleanup注解即可搞定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cleanup</span> BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">       FileReader fileReader = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           fileReader = <span class="keyword">new</span> FileReader(<span class="string">"Lombok.txt"</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       br = <span class="keyword">new</span> BufferedReader(fileReader);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           System.out.println(br.readLine());</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="异常不用捕捉了"><a href="#异常不用捕捉了" class="headerlink" title="异常不用捕捉了"></a>异常不用捕捉了</h3><p>以上面那个作为例子</p><p>这地方的 FileNotFoundException异常，要么显式地在函数级抛出，要么就像上面一样 try/catch内部消灭。</p><p>如果在编码时，不想处理这种繁杂的异常处理，你可以使用Lombok的 @SneakyThrows注解进行简化，比如上面的代码就可以简化为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OpnTxt</span><span class="params">( String fileName)</span></span>&#123;</span><br><span class="line">    <span class="meta">@Cleanup</span> BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">    FileReader fileReader = <span class="keyword">null</span>;</span><br><span class="line">    fileReader = <span class="keyword">new</span> FileReader(<span class="string">"Lombok.txt"</span>);</span><br><span class="line">    br = <span class="keyword">new</span> BufferedReader(fileReader);</span><br><span class="line">    System.out.println(br.readLine());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样你编码时就无需处理异常了</p><hr><h3 id="还有一些"><a href="#还有一些" class="headerlink" title="还有一些"></a>还有一些</h3><p>上面列举了几个平时项目开发中使用非常频繁的Lombok注解，除此之外，还有诸如像：</p><ul><li>@EqualsAndHashCode：为类自动生成hashCode和equals实现</li><li>@Log：为类自动生成log日志记录</li><li>@Synchronized：为类方法或实例方法自动生成synchronized保护</li></ul><hr><p>从此，代码5分钟，划水2小时不是梦。。。<br><img src="/2020/03/19/Lombok%E5%8F%AF%E7%9C%9F%E9%A6%99%EF%BC%81%EF%BC%81%EF%BC%81/%E5%88%92%E6%B0%B4%E5%96%BD.jpg" alt="只想本分划水"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lombok </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea常用的一些插件</title>
      <link href="/2020/03/15/idea%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/"/>
      <url>/2020/03/15/idea%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2020/03/15/idea%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/idea%E6%8F%92%E4%BB%B6.jpg" alt="idea插件"></p><p>今天给分享一下中常用的几款能提升幸福感IDEA插件</p><hr><h3 id="1-Background-Image-Plus"><a href="#1-Background-Image-Plus" class="headerlink" title="1.Background Image Plus"></a>1.Background Image Plus</h3><a id="more"></a><p>默认IDEA的背景一般都比较单调，要么白乎乎，要么褐乎乎，而Background Image Plus这个插件可以为IDEA设置自定义图片作为背景，而且还可以设置透明度，从此写代码乐趣十足</p><p><strong>背景图设置效果如下：</strong></p><p><img src="/2020/03/15/idea%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/Background.png" alt="Background Image Plus"></p><hr><h3 id="2-CodeGlance"><a href="#2-CodeGlance" class="headerlink" title="2.CodeGlance"></a>2.CodeGlance</h3><p>CodeGlance是一款非常好用的代码地图插件，可以在代码编辑区的右侧生成一个竖向可拖动的代码缩略区，可以快速定位代码的同时，并且提供放大镜功能</p><p><strong>右侧代码缩略图效果:</strong></p><p><img src="/2020/03/15/idea%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/CodeGlance.jpg" alt="codeGlance"></p><hr><h3 id="3-Translation"><a href="#3-Translation" class="headerlink" title="3.Translation"></a>3.Translation</h3><p>代码中经常遇到不认识的英文单词或者句子，很懵怎么办？</p><p>Translation是一款非常好用的翻译插件，可以随时随地翻译单词、甚至一段话，从此不再需要额外打开浏览器搜索翻译网站了！</p><p><img src="/2020/03/15/idea%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/TranslationIn.jpg" alt="TranslationIn"></p><p><strong>翻译逐个单词：</strong></p><p><img src="/2020/03/15/idea%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/%E7%BF%BB%E8%AF%91%E5%8D%95%E8%AF%8D.jpg" alt="翻译单词"></p><p><strong>翻译一段话：</strong></p><p><img src="/2020/03/15/idea%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/%E7%BF%BB%E8%AF%91%E4%B8%80%E6%AE%B5%E8%AF%9D.jpg" alt="翻译一段话"></p><hr><h3 id="4-Rainbow-Brackets"><a href="#4-Rainbow-Brackets" class="headerlink" title="4.Rainbow Brackets"></a>4.Rainbow Brackets</h3><p>在代码非常复杂时，各种俄罗斯套娃式的括号简直让人心碎，Rainbow Brackets则是一款可以对成对括号进行着色的插件，顾名思义“彩虹色的括号”，从此复杂代码一眼即可看穿！</p><p>装完插件，括号都被染上了彩虹的颜色</p><p><img src="/2020/03/15/idea%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/RainbowBrackets.jpg" alt="Rainbow Brackets"></p><hr><h3 id="5-Statistic"><a href="#5-Statistic" class="headerlink" title="5.Statistic"></a>5.Statistic</h3><p>天天闷头写代码！</p><ul><li>你知道你项目到底有多少行代码吗？</li><li>你知道项目代码里有多少是实际代码？</li><li>有多少是空行？</li><li>有多少是注释吗？</li><li>. . .</li></ul><p>Statistic则是一款可以做项目全局代码统计信息的小插件</p><p><img src="/2020/03/15/idea%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/Statistic.jpg" alt="Statistic"></p><hr><h3 id="6-Lombok"><a href="#6-Lombok" class="headerlink" title="6.Lombok"></a>6.Lombok</h3><h4 id="Lombok到底是什么"><a href="#Lombok到底是什么" class="headerlink" title="Lombok到底是什么"></a>Lombok到底是什么</h4><p>先看一下它的官网<br><img src="/2020/03/15/idea%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/lombok%E5%AE%98%E7%BD%91.jpg" alt="lombok官网"><br><strong>大致意思是：</strong> Lombok是一个很牛批的插件（本质是个Java库），项目里一旦引入了Lombok之后，你项目中所有诸如：对象的构造函数、 equals()方法，属性的 get()/set()方法等等，这些没有技术含量的代码统统都不用写了，Lombok帮你搞定一切，全部帮你自动生成。<br>总之很香就是啦，后面会写一篇有关于lombok的博客！</p>]]></content>
      
      
      <categories>
          
          <category> idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo本地图片不显示</title>
      <link href="/2020/03/13/hexo%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA/"/>
      <url>/2020/03/13/hexo%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1、修改文件-config-yml-里的post-asset-folder-这个选项设置为true"><a href="#1、修改文件-config-yml-里的post-asset-folder-这个选项设置为true" class="headerlink" title="1、修改文件_config.yml 里的post_asset_folder:这个选项设置为true"></a>1、修改文件_config.yml 里的post_asset_folder:这个选项设置为true</h3><ul><li>修改之后，再使用hexo n “hexo 本地图片不显示”时，目录的样子是</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hexo本地图片不显示</span><br><span class="line">    ├── 01.jpg</span><br><span class="line">    ├── 02.jpg</span><br><span class="line">    └── 03.jpg</span><br><span class="line">    ...</span><br><span class="line">    hexo本地图片不显示.md</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2、安装hexo-asset-image-可以上传本地图片的插件"><a href="#2、安装hexo-asset-image-可以上传本地图片的插件" class="headerlink" title="2、安装hexo-asset-image,可以上传本地图片的插件"></a>2、安装<a href="https://github.com/EricGerry/hexo-asset-image-0.0.5.git" target="_blank" rel="noopener">hexo-asset-image</a>,可以上传本地图片的插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https:&#x2F;&#x2F;github.com&#x2F;EricGerry&#x2F;hexo-asset-image-0.0.5.git --save</span><br></pre></td></tr></table></figure><p><img src="/2020/03/13/hexo%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA/1.png" alt=" "><br>注意 不要使用npm install hexo-asset-image –save这个命令安装,版本号不对<br><img src="/2020/03/13/hexo%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA/2.jpg" alt=" "></p><ul><li>0.0.5版本<br><img src="/2020/03/13/hexo%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA/3.png" alt=" "></li><li>1.0.0版本<br><img src="/2020/03/13/hexo%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA/4.png" alt=" "></li></ul><h3 id="3、在md使用如下形式引用图片"><a href="#3、在md使用如下形式引用图片" class="headerlink" title="3、在md使用如下形式引用图片"></a>3、在md使用如下形式引用图片</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">01</span>](<span class="link">hexo本地图片不显示/01.jpg</span>)</span><br></pre></td></tr></table></figure><p><strong>注意</strong> 这里要使用”/“</p><h3 id="4、使用以下命令发布博客"><a href="#4、使用以下命令发布博客" class="headerlink" title="4、使用以下命令发布博客"></a>4、使用以下命令发布博客</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p><strong>注意</strong> 重命名md文件之后记得重命名文件夹，当md文件的名称与文件夹名称不同时，映射关系以md文件名称为主。会导致src图片路径找不到</p><p><strong>总结</strong>：</p><ul><li>检查_config.yml 文件的post_asset_folder:选项是否为true</li><li>检查创建文件之后的目录结构</li><li>检查hexo-asset-image插件的版本</li><li>检查路径引用图片的路径使用/</li><li>检查md文件的文件名称和图片存放文件夹名称是否相同</li></ul>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机（JVM）面试题</title>
      <link href="/2020/03/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/03/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2020/03/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E9%9D%A2%E8%AF%95%E9%A2%98/java.jpg" alt=" "></p><h2 id="1、Java内存区域"><a href="#1、Java内存区域" class="headerlink" title="1、Java内存区域"></a>1、Java内存区域</h2><h3 id="JVM-的主要组成部分及其作用"><a href="#JVM-的主要组成部分及其作用" class="headerlink" title="JVM 的主要组成部分及其作用"></a>JVM 的主要组成部分及其作用</h3><p><img src="/2020/03/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E9%9D%A2%E8%AF%95%E9%A2%98/JVM.png" alt=" "></p><p>&emsp;JVM包含两个子系统和两个组件，两个子系统为Class loader(类装载)、Execution engine(执行引擎)；两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)。</p><ul><li>Class loader(类装载)：根据给定的全限定名类名(如：java.lang.Object)来装载class文件到Runtime data area中的method area。</li><li>Execution engine（执行引擎）：执行classes中的指令。</li><li>Native Interface(本地接口)：与native libraries交互，是其它编程语言交互的接口。</li><li>Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存。</li></ul><p><strong>作用 ：</strong>首先通过编译器把 Java 代码转换成字节码，类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p><h3 id="下面是Java程序运行机制详细说明"><a href="#下面是Java程序运行机制详细说明" class="headerlink" title="下面是Java程序运行机制详细说明"></a>下面是Java程序运行机制详细说明</h3><p>Java程序运行机制步骤</p><ul><li>首先利用IDE集成开发工具编写Java源代码，源文件的后缀为.java；</li><li>再利用编译器(javac命令)将源代码编译成字节码文件，字节码文件的后缀名为.class；</li><li>运行字节码的工作是由解释器(java命令)来完成的。</li></ul><p><img src="/2020/03/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.jpg" alt=" "></p><p>从上图可以看，java文件通过编译器变成了.class文件，接下来类加载器又将这些.class文件加载到JVM中。<br>其实可以一句话来解释：类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构。</p><h3 id="说一下-JVM-运行时数据区"><a href="#说一下-JVM-运行时数据区" class="headerlink" title="说一下 JVM 运行时数据区"></a>说一下 JVM 运行时数据区</h3><p><strong>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域。</strong>这些区域都有各自的用途，以及创建和销毁的时间，有些区域随着虚拟机进程的启动而存在，有些区域则是依赖线程的启动和结束而建立和销毁。Java 虚拟机所管理的内存被划分为如下几个区域：<br><img src="/2020/03/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.jpg" alt=" "><br>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：</p><ul><li>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</li><li>Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；</li><li>本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；</li><li>Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；</li><li>方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</li></ul><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，</p><p>深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，</p><p>使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。</p><p>浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。</p><p>深复制：在计算机中开辟一块<strong>新的内存地址</strong>用于存放复制的对象。</p><h3 id="说一下堆栈的区别"><a href="#说一下堆栈的区别" class="headerlink" title="说一下堆栈的区别"></a>说一下堆栈的区别</h3><h4 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h4><p>堆的物理地址分配对对象是不连续的。因此性能慢些。在GC的时候也要考虑到不连续的分配，所以有各种算法。比如，标记-消除，复制，标记-压缩，分代（即新生代使用复制算法，老年代使用标记——压缩）</p><p>栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。</p><h4 id="内存分别"><a href="#内存分别" class="headerlink" title="内存分别"></a>内存分别</h4><p>堆因为是不连续的，所以分配的内存是在运行期确认的，因此大小不固定。一般堆大小远远大于栈。</p><p>栈是连续的，所以分配的内存大小要在编译期就确认，大小是固定的。</p><h4 id="存放的内容"><a href="#存放的内容" class="headerlink" title="存放的内容"></a>存放的内容</h4><p>堆存放的是对象的实例和数组。因此该区更关注的是数据的存储</p><p>栈存放：局部变量，操作数栈，返回结果。该区更关注的是程序方法的执行。</p><h4 id="PS"><a href="#PS" class="headerlink" title="PS:"></a><strong>PS:</strong></h4><ul><li>静态变量放在方法区</li><li>静态的对象还是放在堆。</li></ul><h4 id="程序的可见度"><a href="#程序的可见度" class="headerlink" title="程序的可见度"></a>程序的可见度</h4><p>堆对于整个应用程序都是共享、可见的。</p><p>栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同。</p><h3 id="队列和栈是什么？有什么区别"><a href="#队列和栈是什么？有什么区别" class="headerlink" title="队列和栈是什么？有什么区别"></a>队列和栈是什么？有什么区别</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><p>队列和栈都是被用来预存储数据的。</p><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ul><li>操作的名称不同。队列的插入称为入队，队列的删除称为出队。栈的插入称为进栈，栈的删除称为出栈。</li><li>可操作的方式不同。队列是在队尾入队，队头出队，即两边都可操作。而栈的进栈和出栈都是在栈顶进行的，无法对栈底直接进行操作。</li><li>操作的方法不同。队列是先进先出（FIFO），即队列的修改是依先进先出的原则进行的。新来的成员总是加入队尾（不能从中间插入），每次离开的成员总是队列头上（不允许中途离队）。而栈为后进先出（LIFO）,即每次删除（出栈）的总是当前栈中最新的元素，即最后插入（进栈）的元素，而最先插入的被放在栈的底部，要到最后才能删除。</li></ul><h2 id="2、HotSpot虚拟机对象探秘"><a href="#2、HotSpot虚拟机对象探秘" class="headerlink" title="2、HotSpot虚拟机对象探秘"></a>2、HotSpot虚拟机对象探秘</h2><h3 id="对象是怎么创建的"><a href="#对象是怎么创建的" class="headerlink" title="对象是怎么创建的"></a>对象是怎么创建的</h3><p>说到对象的创建，首先让我们看看 Java 中提供的几种对象创建方式：</p><table><thead><tr><th align="center">Header</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">使用new关键字</td><td align="center">调用了构造函数</td></tr><tr><td align="center">使用Class的newInstance方法</td><td align="center">调用了构造函数</td></tr><tr><td align="center">使用Constructor类的newInstance方法</td><td align="center">调用了构造函数</td></tr><tr><td align="center">使用clone方法</td><td align="center">没有调用构造函数</td></tr><tr><td align="center">使用反序列化</td><td align="center">没有调用构造函数</td></tr></tbody></table><p>下面是对象创建的主要流程:</p><p><img src="/2020/03/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B.jpg" alt=" "></p><p>&emsp;虚拟机遇到一条new指令时，先检查常量池是否已经加载相应的类，如果没有，必须先执行相应的类加载。类加载通过后，接下来分配内存。若Java堆中内存是绝对规整的，使用“指针碰撞“方式分配内存；如果不是规整的，就从空闲列表中分配，叫做”空闲列表“方式。划分内存时还需要考虑一个问题-并发，也有两种方式: CAS同步处理，或者本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)。然后内存空间初始化操作，接着是做一些必要的对象设置(元信息、哈希码…)，最后执行&lt; init &gt;方法。</p><h3 id="为对象分配内存"><a href="#为对象分配内存" class="headerlink" title="为对象分配内存"></a>为对象分配内存</h3><p>类加载完成后，接着会在Java堆中划分一块内存分配给对象。内存分配根据Java堆是否规整，有两种方式：</p><ul><li>指针碰撞：如果Java堆的内存是规整，即所有用过的内存放在一边，而空闲的的放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成分配内存工作。</li><li>空闲列表：如果Java堆的内存不是规整的，则需要由虚拟机维护一个列表来记录那些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录。</li></ul><p>选择哪种分配方式是由 Java 堆是否规整来决定的，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p><p><img src="/2020/03/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F.jpg" alt=" "></p><h3 id="处理并发安全问题"><a href="#处理并发安全问题" class="headerlink" title="处理并发安全问题"></a>处理并发安全问题</h3><p>对象的创建在虚拟机中是一个非常频繁的行为，哪怕只是修改一个指针所指向的位置，在并发情况下也是不安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案：</p><ul><li>对分配内存空间的动作进行同步处理（采用 CAS + 失败重试来保障更新操作的原子性）；</li><li>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配。只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁。通过-XX:+/-UserTLAB参数来设定虚拟机是否使用TLAB。</li></ul><p><img src="/2020/03/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E9%9D%A2%E8%AF%95%E9%A2%98/%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95.jpg" alt=" "></p><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>Java程序需要通过 JVM 栈上的引用访问堆中的具体对象。对象的访问方式取决于 JVM 虚拟机的实现。目前主流的访问方式有 <strong>句柄</strong> 和 <strong>直接指针</strong> 两种方式。</p><ul><li><p>指针： 指向对象，代表一个对象在内存中的起始地址。</p></li><li><p>句柄： 可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向对象，而是指向对象的指针（句柄不发生变化，指向固定内存地址），再由对象的指针指向对象的真实内存地址。</p></li></ul><h4 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h4><p>Java堆中划分出一块内存来作为<strong>句柄池</strong>，引用中存储对象的<strong>句柄地址</strong>，而句柄中包含了<strong>对象实例数据</strong>与<strong>对象类型数据</strong>各自的<strong>具体地址</strong>信息，具体构造如下图所示：<br><img src="/2020/03/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%8F%A5%E6%9F%84%E5%85%B7%E4%BD%93%E6%9E%84%E9%80%A0.png" alt=" "><br><strong>优势：</strong>引用中存储的是<strong>稳定</strong>的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变<strong>句柄中</strong>的<strong>实例数据指针</strong>，而<strong>引用</strong>本身不需要修改。</p><h4 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h4><p>如果使用<strong>直接指针</strong>访问，<strong>引用</strong> 中存储的直接就是<strong>对象地址</strong>，那么Java堆对象内部的布局中就必须考虑如何放置访问<strong>类型数据</strong>的相关信息。</p><p><img src="/2020/03/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.png" alt=" "></p><p><strong>优势：</strong>速度更<strong>快</strong>，节省了<strong>一次指针定位</strong>的时间开销。由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。HotSpot 中采用的就是这种方式。</p><h2 id="3、内存溢出异常"><a href="#3、内存溢出异常" class="headerlink" title="3、内存溢出异常"></a>3、内存溢出异常</h2><h3 id="Java会存在内存泄漏吗？请简单描述"><a href="#Java会存在内存泄漏吗？请简单描述" class="headerlink" title="Java会存在内存泄漏吗？请简单描述"></a>Java会存在内存泄漏吗？请简单描述</h3><p>内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说，Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。</p><p>但是，即使这样，Java也还是存在着内存泄漏的情况，java导致内存泄露的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。</p><h2 id="4、垃圾收集器"><a href="#4、垃圾收集器" class="headerlink" title="4、垃圾收集器"></a>4、垃圾收集器</h2><h3 id="简述Java垃圾回收机制"><a href="#简述Java垃圾回收机制" class="headerlink" title="简述Java垃圾回收机制"></a>简述Java垃圾回收机制</h3><p>在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p><h3 id="GC是什么？为什么要GC"><a href="#GC是什么？为什么要GC" class="headerlink" title="GC是什么？为什么要GC"></a>GC是什么？为什么要GC</h3><p>GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存</p><p>回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动</p><p>回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。</p><h3 id="垃圾回收的优点和原理。并考虑2种回收机制"><a href="#垃圾回收的优点和原理。并考虑2种回收机制" class="headerlink" title="垃圾回收的优点和原理。并考虑2种回收机制"></a>垃圾回收的优点和原理。并考虑2种回收机制</h3><p>java语言最显著的特点就是引入了垃圾回收机制，它使java程序员在编写程序时不再考虑内存管理的问题。</p><p>由于有这个垃圾回收机制，java中的对象不再有“作用域”的概念，只有引用的对象才有“作用域”。</p><p>垃圾回收机制有效的防止了内存泄露，可以有效的使用可使用的内存。</p><p>垃圾回收器通常作为一个单独的低级别的线程运行，在不可预知的情况下对内存堆中已经死亡的或很长时间没有用过的对象进行清除和回收。</p><p>程序员不能实时的对某个对象或所有对象调用垃圾回收器进行垃圾回收。</p><p>垃圾回收有分代复制垃圾回收、标记垃圾回收、增量垃圾回收。</p><h3 id="垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收"><a href="#垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收" class="headerlink" title="垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收"></a>垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收</h3><p>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。</p><p>通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。</p><p>可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。</p><h3 id="Java-中都有哪些引用类型"><a href="#Java-中都有哪些引用类型" class="headerlink" title="Java 中都有哪些引用类型"></a>Java 中都有哪些引用类型</h3><ul><li>强引用：发生 gc 的时候不会被回收。</li><li>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。</li><li>弱引用：有用但不是必须的对象，在下一次GC时会被回收。</li><li>虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。</li></ul><h3 id="怎么判断对象是否可以被回收"><a href="#怎么判断对象是否可以被回收" class="headerlink" title="怎么判断对象是否可以被回收"></a>怎么判断对象是否可以被回收</h3><p>垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收的，哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需要被回收。</p><p>一般有两种方法来判断：</p><ul><li>引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</li><li>可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</li></ul><h3 id="在Java中，对象什么时候可以被垃圾回收"><a href="#在Java中，对象什么时候可以被垃圾回收" class="headerlink" title="在Java中，对象什么时候可以被垃圾回收"></a>在Java中，对象什么时候可以被垃圾回收</h3><p>当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。<br>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。</p><h3 id="JVM中的永久代中会发生垃圾回收吗"><a href="#JVM中的永久代中会发生垃圾回收吗" class="headerlink" title="JVM中的永久代中会发生垃圾回收吗"></a>JVM中的永久代中会发生垃圾回收吗</h3><p>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区<br>(译者注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区)</p><h3 id="说一下-JVM-有哪些垃圾回收算法"><a href="#说一下-JVM-有哪些垃圾回收算法" class="headerlink" title="说一下 JVM 有哪些垃圾回收算法"></a>说一下 JVM 有哪些垃圾回收算法</h3><ul><li>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。</li><li>复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。</li><li>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</li><li>分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</li></ul><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>标记无用对象，然后进行清除回收。</p><p>标记-清除算法（Mark-Sweep）是一种常见的基础垃圾收集算法，它将垃圾收集分为两个阶段：</p><ul><li>标记阶段：标记出可以回收的对象。</li><li>清除阶段：回收被标记的对象所占用的空间。<br>标记-清除算法之所以是基础的，是因为后面讲到的垃圾收集算法都是在此算法的基础上进行改进的。</li></ul><p><strong>优点：</strong>实现简单，不需要对象进行移动。</p><p><strong>缺点：</strong>标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的频率。</p><p>标记-清除算法的执行的过程如下图所示<br><img src="/2020/03/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" alt=" "></p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>为了解决标记-清除算法的效率不高的问题，产生了复制算法。它把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾收集时，遍历当前使用的区域，把存活对象复制到另外一个区域中，最后将当前使用的区域的可回收的对象进行回收。</p><p><strong>优点：</strong>按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。</p><p><strong>缺点：</strong>可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。</p><p>复制算法的执行过程如下图所示<br><img src="/2020/03/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt=" "></p><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>在新生代中可以使用复制算法，但是在老年代就不能选择复制算法了，因为老年代的对象存活率会较高，这样会有较多的复制操作，导致效率变低。标记-清除算法可以应用在老年代中，但是它效率不高，在内存回收后容易产生大量内存碎片。因此就出现了一种标记-整理算法（Mark-Compact）算法，与标记-整理算法不同的是，在标记可回收的对象后将所有存活的对象压缩到内存的一端，使他们紧凑的排列在一起，然后对端边界以外的内存进行回收。回收后，已用和未用的内存都各自一边。</p><p><strong>优点：</strong>解决了标记-清理算法存在的内存碎片问题。</p><p><strong>缺点：</strong>仍需要进行局部对象移动，一定程度上降低了效率。</p><p>标记-整理算法的执行过程如下图所示<br><img src="/2020/03/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt=" "></p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>当前商业虚拟机都采用<strong>分代收集</strong>的垃圾收集算法。分代收集算法，顾名思义是根据对象的<strong>存活周期</strong>将内存划分为几块。一般包括<strong>年轻代</strong>、<strong>老年代</strong> 和 <strong>永久代</strong>，如图所示：<br><img src="/2020/03/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95.png" alt=" "></p><h3 id="说一下-JVM-有哪些垃圾回收器"><a href="#说一下-JVM-有哪些垃圾回收器" class="headerlink" title="说一下 JVM 有哪些垃圾回收器"></a>说一下 JVM 有哪些垃圾回收器</h3><p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。下图展示了7种作用于不同分代的收集器，其中用于回收新生代的收集器包括Serial、PraNew、Parallel Scavenge，回收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收整个Java堆的G1收集器。不同收集器之间的连线表示它们可以搭配使用<br><img src="/2020/03/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png" alt=" "></p><ul><li>Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；</li><li>ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；</li><li>Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；</li><li>Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；</li><li>Parallel Old收集器 (标记-整理算法)：老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；</li><li>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）：老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</li><li>G1(Garbage First)收集器 (标记-整理算法)：Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</li></ul><h3 id="详细介绍一下-CMS-垃圾回收器"><a href="#详细介绍一下-CMS-垃圾回收器" class="headerlink" title="详细介绍一下 CMS 垃圾回收器"></a>详细介绍一下 CMS 垃圾回收器</h3><p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</p><p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p><h3 id="新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别"><a href="#新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别" class="headerlink" title="新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别"></a>新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别</h3><ul><li>新生代回收器：Serial、ParNew、Parallel Scavenge</li><li>老年代回收器：Serial Old、Parallel Old、CMS</li><li>整堆回收器：G1</li></ul><p>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p><h3 id="简述分代垃圾回收器是怎么工作的"><a href="#简述分代垃圾回收器是怎么工作的" class="headerlink" title="简述分代垃圾回收器是怎么工作的"></a>简述分代垃圾回收器是怎么工作的</h3><p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。</p><p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p><ul><li>把 Eden + From Survivor 存活的对象放入 To Survivor 区；</li><li>清空 Eden 和 From Survivor 分区；</li><li>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。</li></ul><p>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</p><p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p><h2 id="5、内存分配策略"><a href="#5、内存分配策略" class="headerlink" title="5、内存分配策略"></a>5、内存分配策略</h2><h3 id="简述java内存分配与回收策率以及Minor-GC和Major-GC"><a href="#简述java内存分配与回收策率以及Minor-GC和Major-GC" class="headerlink" title="简述java内存分配与回收策率以及Minor GC和Major GC"></a>简述java内存分配与回收策率以及Minor GC和Major GC</h3><p>所谓自动内存管理，最终要解决的也就是内存分配和内存回收两个问题。前面我们介绍了内存回收，这里我们再来聊聊内存分配。</p><p>对象的内存分配通常是在 Java 堆上分配（随着虚拟机优化技术的诞生，某些场景下也会在栈上分配，后面会详细介绍），对象主要分配在新生代的 Eden 区，如果启动了本地线程缓冲，将按照线程优先在 TLAB 上分配。少数情况下也会直接在老年代上分配。总的来说分配规则不是百分百固定的，其细节取决于哪一种垃圾收集器组合以及虚拟机相关参数有关，但是虚拟机对于内存的分配还是会遵循以下几种「普世」规则：</p><h4 id="对象优先在-Eden-区分配"><a href="#对象优先在-Eden-区分配" class="headerlink" title="对象优先在 Eden 区分配"></a>对象优先在 Eden 区分配</h4><p>多数情况，对象都在新生代 Eden 区分配。当 Eden 区分配没有足够的空间进行分配时，虚拟机将会发起一次 Minor GC。如果本次 GC 后还是没有足够的空间，则将启用分配担保机制在老年代中分配内存。</p><p>这里我们提到 Minor GC，如果你仔细观察过 GC 日常，通常我们还能从日志中发现 Major GC/Full GC。</p><p><strong>Minor GC</strong> 是指发生在新生代的 GC，因为 Java 对象大多都是朝生夕死，所有 Minor GC 非常频繁，一般回收速度也非常快；<br><strong>Major GC/Full GC</strong> 是指发生在老年代的 GC，出现了 Major GC 通常会伴随至少一次 Minor GC。Major GC 的速度通常会比 Minor GC 慢 10 倍以上。</p><h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>所谓大对象是指需要大量连续内存空间的对象，频繁出现大对象是致命的，会导致在内存还有不少空间的情况下提前触发 GC 以获取足够的连续空间来安置新对象。</p><p>前面我们介绍过新生代使用的是标记-清除算法来处理垃圾回收的，如果大对象直接在新生代分配就会导致 Eden 区和两个 Survivor 区之间发生大量的内存复制。因此对于大对象都会直接在老年代进行分配。</p><h4 id="长期存活对象将进入老年代"><a href="#长期存活对象将进入老年代" class="headerlink" title="长期存活对象将进入老年代"></a>长期存活对象将进入老年代</h4><p>虚拟机采用分代收集的思想来管理内存，那么内存回收时就必须判断哪些对象应该放在新生代，哪些对象应该放在老年代。因此虚拟机给每个对象定义了一个对象年龄的计数器，如果对象在 Eden 区出生，并且能够被 Survivor 容纳，将被移动到 Survivor 空间中，这时设置对象年龄为 1。对象在 Survivor 区中每「熬过」一次 Minor GC 年龄就加 1，当年龄达到一定程度（默认 15） 就会被晋升到老年代。</p><h2 id="6、虚拟机类加载机制"><a href="#6、虚拟机类加载机制" class="headerlink" title="6、虚拟机类加载机制"></a>6、虚拟机类加载机制</h2><h3 id="简述java类加载机制"><a href="#简述java类加载机制" class="headerlink" title="简述java类加载机制"></a>简述java类加载机制</h3><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的java类型。</p><h3 id="描述一下JVM加载Class文件的原理机制"><a href="#描述一下JVM加载Class文件的原理机制" class="headerlink" title="描述一下JVM加载Class文件的原理机制"></a>描述一下JVM加载Class文件的原理机制</h3><p>Java中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。</p><h4 id="类装载方式，有两种"><a href="#类装载方式，有两种" class="headerlink" title="类装载方式，有两种"></a>类装载方式，有两种</h4><ul><li><p>1.隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中，</p></li><li><p>2.显式装载， 通过class.forname()等方法，显式加载需要的类</p></li></ul><p>Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。</p><h4 id="什么是类加载器，类加载器有哪些"><a href="#什么是类加载器，类加载器有哪些" class="headerlink" title="什么是类加载器，类加载器有哪些"></a>什么是类加载器，类加载器有哪些</h4><p>实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。</p><p>主要有一下四种类加载器:</p><ul><li>启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。</li><li>扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li><li>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</li><li>用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。</li></ul><h4 id="说一下类装载的执行过程"><a href="#说一下类装载的执行过程" class="headerlink" title="说一下类装载的执行过程"></a>说一下类装载的执行过程</h4><p>类装载分为以下 5 个步骤：</p><ul><li>加载：根据查找路径找到相应的 class 文件然后导入；</li><li>验证：检查加载的 class 文件的正确性；</li><li>准备：给类中的静态变量分配内存空间；</li><li>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li><li>初始化：对静态变量和静态代码块执行初始化工作。</li></ul><h4 id="什么是双亲委派模型"><a href="#什么是双亲委派模型" class="headerlink" title="什么是双亲委派模型"></a>什么是双亲委派模型</h4><p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。<br><img src="/2020/03/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE.png" alt=" "></p><h5 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h5><ul><li>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；<br>其他类加载器：</li><li>扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；</li><li>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</li></ul><p><strong>双亲委派模型：</strong>如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p><p>当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。</p><h2 id="7、JVM调优"><a href="#7、JVM调优" class="headerlink" title="7、JVM调优"></a>7、JVM调优</h2><h3 id="说一下-JVM-调优的工具"><a href="#说一下-JVM-调优的工具" class="headerlink" title="说一下 JVM 调优的工具"></a>说一下 JVM 调优的工具</h3><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p><ul><li>jconsole：用于对 JVM 中的内存、线程和类等进行监控；</li><li>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</li></ul><h3 id="常用的-JVM-调优的参数都有哪些"><a href="#常用的-JVM-调优的参数都有哪些" class="headerlink" title="常用的 JVM 调优的参数都有哪些"></a>常用的 JVM 调优的参数都有哪些</h3><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">-Xms2g</td><td align="center">初始化推大小为 2g；</td></tr><tr><td align="center">-Xmx2g</td><td align="center">堆最大内存为 2g；</td></tr><tr><td align="center">-XX:NewRatio=4</td><td align="center">设置年轻的和老年代的内存比例为 1:4；</td></tr><tr><td align="center">-XX:SurvivorRatio=8</td><td align="center">设置新生代 Eden 和 Survivor 比例为 8:2；</td></tr><tr><td align="center">–XX:+UseParNewGC</td><td align="center">指定使用 ParNew + Serial Old 垃圾回收器组合；</td></tr><tr><td align="center">-XX:+UseParallelOldGC</td><td align="center">指定使用 ParNew + ParNew Old 垃圾回收器组合；</td></tr><tr><td align="center">-XX:+UseConcMarkSweepGC</td><td align="center">指定使用 CMS + Serial Old 垃圾回收器组合；</td></tr><tr><td align="center">-XX:+PrintGC</td><td align="center">开启打印 gc 信息；</td></tr><tr><td align="center">-XX:+PrintGCDetails</td><td align="center">打印 gc 详细信息。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/UDP面试题</title>
      <link href="/2020/02/13/TCP-UDP%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/02/13/TCP-UDP%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</p><h2 id="1、UDP-和-TCP-的特点与区别"><a href="#1、UDP-和-TCP-的特点与区别" class="headerlink" title="1、UDP 和 TCP 的特点与区别"></a>1、UDP 和 TCP 的特点与区别</h2><p><strong>用户数据报协议</strong> UDP（User Datagram Protocol）<br>是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</p><p><strong>传输控制协议</strong> TCP（Transmission Control Protocol）<br>是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</p><h2 id="2、UDP-、TCP-首部格式"><a href="#2、UDP-、TCP-首部格式" class="headerlink" title="2、UDP 、TCP 首部格式"></a>2、UDP 、TCP 首部格式</h2><p><img src="/2020/02/13/TCP-UDP%E9%9D%A2%E8%AF%95%E9%A2%98/UDP%20TCP%20%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.jpg" alt=" "></p><p>UDP 首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p><p><img src="/2020/02/13/TCP-UDP%E9%9D%A2%E8%AF%95%E9%A2%98/TCP.jpg" alt=" "></p><p>TCP 首部格式比 UDP 复杂。<br><strong>序号：</strong>用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p><p><strong>确认号：</strong>期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p><p><strong>数据偏移：</strong>指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p><p><strong>控制位：</strong>八位从左到右分别是 CWR，ECE，URG，ACK，PSH，RST，SYN，FIN。</p><p><strong>CWR：</strong>CWR 标志与后面的 ECE 标志都用于 IP 首部的 ECN 字段，ECE 标志为 1 时，则通知对方已将拥塞窗口缩小；</p><p><strong>ECE：</strong>若其值为 1 则会通知对方，从对方到这边的网络有阻塞。在收到数据包的 IP 首部中 ECN 为 1 时将 TCP 首部中的 ECE 设为 1；</p><p><strong>URG：</strong>该位设为 1，表示包中有需要紧急处理的数据，对于需要紧急处理的数据，与后面的紧急指针有关；</p><p><strong>ACK：</strong>该位设为 1，确认应答的字段有效，TCP规定除了最初建立连接时的 SYN 包之外该位必须设为 1；</p><p><strong>PSH：</strong>该位设为 1，表示需要将收到的数据立刻传给上层应用协议，若设为 0，则先将数据进行缓存；</p><p><strong>RST：</strong>该位设为 1，表示 TCP 连接出现异常必须强制断开连接；</p><p><strong>SYN：</strong>用于建立连接，该位设为 1，表示希望建立连接，并在其序列号的字段进行序列号初值设定；</p><p><strong>FIN：</strong>该位设为 1，表示今后不再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位置为 1 的 TCP 段。</p><p>每个主机又对对方的 FIN 包进行确认应答之后可以断开连接。不过，主机收到 FIN 设置为 1 的 TCP 段之后不必马上回复一个 FIN 包，而是可以等到缓冲区中的所有数据都因为已成功发送而被自动删除之后再发 FIN 包；</p><p><strong>窗口：</strong>窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p><h2 id="3、什么是-TCP-的三次握手和四次挥手"><a href="#3、什么是-TCP-的三次握手和四次挥手" class="headerlink" title="3、什么是 TCP 的三次握手和四次挥手"></a>3、什么是 TCP 的三次握手和四次挥手</h2><p>三次握手：<br><img src="/2020/02/13/TCP-UDP%E9%9D%A2%E8%AF%95%E9%A2%98/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg" alt=" "><br>假设 A 为客户端，B 为服务器端。<br>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</p><ul><li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</li><li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li><li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li></ul><p>B 收到 A 的确认后，连接建立。</p><h3 id="为什么三次"><a href="#为什么三次" class="headerlink" title="为什么三次"></a>为什么三次</h3><p>1、第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>2、换个易于理解的视角来看为什么要 3 次握手。</p><p>客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。</p><p>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p><p>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。</p><p>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。</p><p>而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。</p><p>经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。</p><p><strong>每次都是接收到数据包的一方可以得到一些结论，发送的一方其实没有任何头绪。我虽然有发包的动作，但是我怎么知道我有没有发出去，而对方有没有接收到呢？</strong></p><p>而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。</p><p>其实每次收到网络包的一方至少是可以得到：对方的发送、我方的接收是正常的。而每一步都是有关联的，下一次的“响应”是由于第一次的“请求”触发，因此每次握手其实是可以得到额外的结论的。</p><p>比如第三次握手时，服务端收到数据包，表明看服务端只能得到客户端的发送能力、服务端的接收能力是正常的，但是结合第二次，说明服务端在第二次发送的响应包，客户端接收到了，并且作出了响应，从而得到额外的结论：客户端的接收、服务端的发送是正常的。</p><h2 id="5、TCP-的四次挥手（为什么四次？）"><a href="#5、TCP-的四次挥手（为什么四次？）" class="headerlink" title="5、TCP 的四次挥手（为什么四次？）"></a>5、TCP 的四次挥手（为什么四次？）</h2><p>四次挥手：<br><img src="/2020/02/13/TCP-UDP%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg" alt=" "></p><ul><li>客户端发送一个 FIN 段，并包含一个希望接收者看到的自己当前的序列号 K. 同时还包含一个 ACK 表示确认对方最近一次发过来的数据。</li><li>服务端将 K 值加 1 作为 ACK 序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。</li><li>服务端发起自己的 FIN 段，ACK=K+1, Seq=L。</li><li>客户端确认。进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。ACK=L+1。</li></ul><h3 id="为什么建立连接是三次握手，而关闭连接却是四次挥手呢"><a href="#为什么建立连接是三次握手，而关闭连接却是四次挥手呢" class="headerlink" title="为什么建立连接是三次握手，而关闭连接却是四次挥手呢"></a>为什么建立连接是三次握手，而关闭连接却是四次挥手呢</h3><p>1、TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。</p><p>2、这时对方会回一个ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，也就是说，服务端收到客户端的 FIN 标志，知道客户端想要断开这次连接了，但是，我服务端，我还想发数据呢？我等到发送完了所有的数据后，会发送一个 FIN 段来关闭此方向上的连接。接收方发送 ACK确认关闭连接。</p><p>注意，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解“上层的意志”。</p><p>3、客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><p>4、因为服务端在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。而关闭连接时，当收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方 ACK 和 FIN 一般都会分开发。</p><h3 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h3><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ul><li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><h2 id="6、TCP-短连接和长连接的区别"><a href="#6、TCP-短连接和长连接的区别" class="headerlink" title="6、TCP 短连接和长连接的区别"></a>6、TCP 短连接和长连接的区别</h2><p><strong>短连接：</strong>Client 向 Server 发送消息，Server 回应 Client，然后一次读写就完成了，这时候双方任何一个都可以发起 close 操作，不过一般都是 Client 先发起 close 操作。短连接一般只会在 Client/Server 间传递一次读写操作。</p><p>短连接的优点：管理起来比较简单，建立存在的连接都是有用的连接，不需要额外的控制手段。</p><p><strong>长连接：</strong>Client 与 Server 完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。</p><p>在长连接的应用场景下，Client 端一般不会主动关闭它们之间的连接，Client 与 Server 之间的连接如果一直不关闭的话，随着客户端连接越来越多，Server 压力也越来越大，这时候 Server 端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致 Server 端服务受损；如果条件再允许可以以客户端为颗粒度，限制每个客户端的最大长连接数，从而避免某个客户端连累后端的服务。</p><p>长连接和短连接的产生在于 Client 和 Server 采取的关闭策略，具体的应用场景采用具体的策略。</p><h2 id="7、TCP粘包、拆包及解决办法"><a href="#7、TCP粘包、拆包及解决办法" class="headerlink" title="7、TCP粘包、拆包及解决办法"></a>7、TCP粘包、拆包及解决办法</h2><h3 id="为什么常说-TCP-有粘包和拆包的问题而不说-UDP"><a href="#为什么常说-TCP-有粘包和拆包的问题而不说-UDP" class="headerlink" title="为什么常说 TCP 有粘包和拆包的问题而不说 UDP"></a>为什么常说 TCP 有粘包和拆包的问题而不说 UDP</h3><p>由前两节可知，UDP 是基于报文发送的，UDP首部采用了 16bit 来指示 UDP 数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。</p><p>而 TCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP 并没有把这些数据块区分边界，仅仅是一连串没有结构的字节流；另外从 TCP 的帧结构也可以看出，在 TCP 的首部没有表示数据长度的字段，基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。</p><h3 id="什么是粘包、拆包"><a href="#什么是粘包、拆包" class="headerlink" title="什么是粘包、拆包"></a>什么是粘包、拆包</h3><p>假设 Client 向 Server 连续发送了两个数据包，用 packet1 和 packet2 来表示，那么服务端收到的数据可以分为三种情况，现列举如下：</p><p>第一种情况，接收端正常收到两个数据包，即没有发生拆包和粘包的现象。<br><img src="/2020/02/13/TCP-UDP%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%AD%A3%E5%B8%B8.png" alt=" "><br>第二种情况，接收端只收到一个数据包，但是这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。<br><img src="/2020/02/13/TCP-UDP%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%B2%98%E5%8C%85.png" alt=" "><br>第三种情况，这种情况有两种表现形式，如下图。接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。<br><img src="/2020/02/13/TCP-UDP%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85.png" alt=" "><br><img src="/2020/02/13/TCP-UDP%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%852.png" alt=" "></p><h3 id="为什么会发生-TCP-粘包、拆包"><a href="#为什么会发生-TCP-粘包、拆包" class="headerlink" title="为什么会发生 TCP 粘包、拆包"></a>为什么会发生 TCP 粘包、拆包</h3><ul><li>要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包。</li><li>待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。</li><li>要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。</li><li>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。</li></ul><h3 id="粘包、拆包解决办法"><a href="#粘包、拆包解决办法" class="headerlink" title="粘包、拆包解决办法"></a>粘包、拆包解决办法</h3><p>由于 TCP 本身是面向字节流的，无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，归纳如下：</p><ul><li>消息定长：发送端将每个数据包封装为固定长度（不够的可以通过补 0 填充），这样接收端每次接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</li><li>设置消息边界：服务端从网络流中按消息边界分离出消息内容。在包尾增加回车换行符进行分割，例如 FTP 协议。</li><li>将消息分为消息头和消息体：消息头中包含表示消息总长度（或者消息体长度）的字段。</li><li>更复杂的应用层协议比如 Netty 中实现的一些协议都对粘包、拆包做了很好的处理。</li></ul><h2 id="8、TCP-可靠传输"><a href="#8、TCP-可靠传输" class="headerlink" title="8、TCP 可靠传输"></a>8、TCP 可靠传输</h2><p>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p><p>一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：<br><img src="/2020/02/13/TCP-UDP%E9%9D%A2%E8%AF%95%E9%A2%98/RTTs%E8%AE%A1%E7%AE%97.png" alt=" "><br>其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：<br><img src="/2020/02/13/TCP-UDP%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%B6%85%E5%87%BA%E6%97%B6%E9%97%B4.png" alt=" "><br>其中 RTTd 为偏差的加权平均值。</p><h2 id="9、TCP-滑动窗口"><a href="#9、TCP-滑动窗口" class="headerlink" title="9、TCP 滑动窗口"></a>9、TCP 滑动窗口</h2><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p><p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p><p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。<br><img src="/2020/02/13/TCP-UDP%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.jpg" alt=" "></p><h2 id="10、TCP-流量控制"><a href="#10、TCP-流量控制" class="headerlink" title="10、TCP 流量控制"></a>10、TCP 流量控制</h2><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p><p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><p><strong>实际上，为了避免此问题的产生，发送端主机会时不时的发送一个叫做窗口探测的数据段</strong>，此数据段仅包含一个字节来获取最新的窗口大小信息。</p><h2 id="11、TCP-拥塞控制"><a href="#11、TCP-拥塞控制" class="headerlink" title="11、TCP 拥塞控制"></a>11、TCP 拥塞控制</h2><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。<br><img src="/2020/02/13/TCP-UDP%E9%9D%A2%E8%AF%95%E9%A2%98/TCP%E9%98%BB%E5%A1%9E%E6%8E%A7%E5%88%B6.jpg" alt=" "><br>TCP 主要通过四个算法来进行拥塞控制：<br><strong>慢开始、拥塞避免、快重传、快恢复。</strong></p><p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p><p>为了便于讨论，做如下假设：</p><ul><li>接收方有足够大的接收缓存，因此不会发生流量控制；</li><li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。<br><img src="/2020/02/13/TCP-UDP%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%8E%A7%E5%88%B6%E6%97%B6%E5%8F%98%E5%8C%96%E6%83%85%E5%86%B5.jpg" alt=" "></li></ul><h3 id="慢开始与拥塞避免"><a href="#慢开始与拥塞避免" class="headerlink" title="慢开始与拥塞避免"></a>慢开始与拥塞避免</h3><p>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p><p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p><p>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</p><h3 id="快重传与快恢复"><a href="#快重传与快恢复" class="headerlink" title="快重传与快恢复"></a>快重传与快恢复</h3><p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</p><p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</p><p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</p><p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。<br><img src="/2020/02/13/TCP-UDP%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%BF%AB%E9%87%8D%E4%BC%A0.jpg" alt=" "></p><h2 id="12、提供网络利用率"><a href="#12、提供网络利用率" class="headerlink" title="12、提供网络利用率"></a>12、提供网络利用率</h2><h3 id="1、Nagle-算法"><a href="#1、Nagle-算法" class="headerlink" title="1、Nagle 算法"></a>1、Nagle 算法</h3><p>发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送的一种处理机制。具体来说，就是仅在下列任意一种条件下才能发送数据。如果两个条件都不满足，那么暂时等待一段时间以后再进行数据发送。</p><ul><li>已发送的数据都已经收到确认应答。</li><li>可以发送最大段长度的数据时。</li></ul><h3 id="2、延迟确认应答"><a href="#2、延迟确认应答" class="headerlink" title="2、延迟确认应答"></a>2、延迟确认应答</h3><p>接收方收到数据之后可以并不立即返回确认应答，而是延迟一段时间的机制。</p><ul><li>在没有收到 2*最大段长度的数据为止不做确认应答。</li><li>其他情况下，最大延迟 0.5秒 发送确认应答。</li><li>TCP 文件传输中，大多数是每两个数据段返回一次确认应答。</li></ul><h3 id="3、捎带应答"><a href="#3、捎带应答" class="headerlink" title="3、捎带应答"></a>3、捎带应答</h3><p>在一个 TCP 包中既发送数据又发送确认应答的一种机制，由此，网络利用率会提高，计算机的负荷也会减轻，但是这种应答必须等到应用处理完数据并将作为回执的数据返回为止。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 网络 </tag>
            
            <tag> TCP </tag>
            
            <tag> UDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程基础面试题</title>
      <link href="/2020/02/12/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/02/12/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2020/02/12/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/java.jpg" alt=" "></p><h2 id="1、多线程有什么用"><a href="#1、多线程有什么用" class="headerlink" title="1、多线程有什么用"></a>1、多线程有什么用</h2><p>&emsp;一个可能在很多人看来很扯淡的一个问题：我会用多线程就好了，还管它有什么用？在我看来，这个回答更扯淡。所谓”知其然知其所以然”，”会用”只是”知其然”，”为什么用”才是”知其所以然”，只有达到”知其然知其所以然”的程度才可以说是把一个知识点运用自如。OK，下面说说我对这个问题的看法：</p><ul><li>（1）发挥多核CPU的优势</li></ul><p>&emsp;随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程”同时”运行罢了。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。</p><ul><li>（2）防止阻塞</li></ul><p>&emsp;从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。</p><ul><li>（3）便于建模</li></ul><p>&emsp;这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。</p><h2 id="2、创建线程的方式"><a href="#2、创建线程的方式" class="headerlink" title="2、创建线程的方式"></a>2、创建线程的方式</h2><p>比较常见的一个问题了，一般就是两种：</p><ul><li><p>（1）继承Thread类</p></li><li><p>（2）实现Runnable接口</p></li></ul><p>至于哪个好，不用说肯定是后者好，因为实现接口的方式比继承类的方式更灵活，也能减少程序之间的耦合度，面向接口编程也是设计模式6大原则的核心。</p><h2 id="3、start-方法和run-方法的区别"><a href="#3、start-方法和run-方法的区别" class="headerlink" title="3、start()方法和run()方法的区别"></a>3、start()方法和run()方法的区别</h2><p>&emsp;只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。</p><h2 id="4、Runnable接口和Callable接口的区别"><a href="#4、Runnable接口和Callable接口的区别" class="headerlink" title="4、Runnable接口和Callable接口的区别"></a>4、Runnable接口和Callable接口的区别</h2><p>&emsp;Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</p><p>&emsp;这其实是很有用的一个特性，因为<strong>多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性</strong>，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。</p><h2 id="5、CyclicBarrier和CountDownLatch的区别"><a href="#5、CyclicBarrier和CountDownLatch的区别" class="headerlink" title="5、CyclicBarrier和CountDownLatch的区别"></a>5、CyclicBarrier和CountDownLatch的区别</h2><p>&emsp;两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：</p><ul><li><p>（1）CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行</p></li><li><p>（2）CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务</p></li><li><p>（3）CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</p></li></ul><h2 id="6、volatile关键字的作用"><a href="#6、volatile关键字的作用" class="headerlink" title="6、volatile关键字的作用"></a>6、volatile关键字的作用</h2><p>volatile关键字的作用主要有两个：</p><ul><li><p>（1）多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据</p></li><li><p>（2）代码底层执行不像我们看到的高级语言—-Java程序这么简单，它的执行是Java代码–&gt;字节码–&gt;根据字节码执行对应的C/C++代码–&gt;C/C++代码被编译成汇编语言–&gt;和硬件电路交互，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率</p></li></ul><p>&emsp;从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。</p><h2 id="7、什么是线程安全"><a href="#7、什么是线程安全" class="headerlink" title="7、什么是线程安全"></a>7、什么是线程安全</h2><p><strong>如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。</strong></p><p>&emsp;这个问题有值得一提的地方，就是线程安全也是有几个级别的：</p><ul><li>（1）不可变</li></ul><p>&emsp;像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用</p><ul><li>（2）绝对线程安全</li></ul><p>&emsp;不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet</p><ul><li>（3）相对线程安全</li></ul><p>&emsp;相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。</p><ul><li>（4）线程非安全</li></ul><p>&emsp;这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类</p><h2 id="8、Java中如何获取到线程dump文件"><a href="#8、Java中如何获取到线程dump文件" class="headerlink" title="8、Java中如何获取到线程dump文件"></a>8、Java中如何获取到线程dump文件</h2><p>&emsp;死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步：</p><ul><li><p>（1）获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java</p></li><li><p>（2）打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid</p></li></ul><p>&emsp;另外值得一提的是，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈</p><h2 id="9、一个线程如果出现了运行时异常会怎么样"><a href="#9、一个线程如果出现了运行时异常会怎么样" class="headerlink" title="9、一个线程如果出现了运行时异常会怎么样"></a>9、一个线程如果出现了运行时异常会怎么样</h2><p>&emsp;如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放</p><h2 id="10、如何在两个线程之间共享数据"><a href="#10、如何在两个线程之间共享数据" class="headerlink" title="10、如何在两个线程之间共享数据"></a>10、如何在两个线程之间共享数据</h2><p>&emsp;通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的</p><h2 id="11、sleep方法和wait方法有什么区别"><a href="#11、sleep方法和wait方法有什么区别" class="headerlink" title="11、sleep方法和wait方法有什么区别"></a>11、sleep方法和wait方法有什么区别</h2><p>&emsp;这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器</p><h2 id="12、生产者消费者模型的作用是什么"><a href="#12、生产者消费者模型的作用是什么" class="headerlink" title="12、生产者消费者模型的作用是什么"></a>12、生产者消费者模型的作用是什么</h2><ul><li><p>（1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用</p></li><li><p>（2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约</p></li></ul><h2 id="13、ThreadLocal有什么用"><a href="#13、ThreadLocal有什么用" class="headerlink" title="13、ThreadLocal有什么用"></a>13、ThreadLocal有什么用</h2><p>&emsp;简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了</p><h2 id="14、为什么wait-方法和notify-notifyAll-方法要在同步块中被调用"><a href="#14、为什么wait-方法和notify-notifyAll-方法要在同步块中被调用" class="headerlink" title="14、为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用"></a>14、为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用</h2><p>&emsp;这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁</p><h2 id="15、wait-方法和notify-notifyAll-方法在放弃对象监视器时有什么区别"><a href="#15、wait-方法和notify-notifyAll-方法在放弃对象监视器时有什么区别" class="headerlink" title="15、wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别"></a>15、wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别</h2><p>&emsp;wait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于：<strong>wait()方法立即释放对象监视器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器。</strong></p><h2 id="16、为什么要使用线程池"><a href="#16、为什么要使用线程池" class="headerlink" title="16、为什么要使用线程池"></a>16、为什么要使用线程池</h2><p>&emsp;避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。</p><h2 id="17、怎么检测一个线程是否持有对象监视器"><a href="#17、怎么检测一个线程是否持有对象监视器" class="headerlink" title="17、怎么检测一个线程是否持有对象监视器"></a>17、怎么检测一个线程是否持有对象监视器</h2><p>&emsp;Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着<strong>“某条线程”指的是当前线程</strong>。</p><h2 id="18、synchronized和ReentrantLock的区别"><a href="#18、synchronized和ReentrantLock的区别" class="headerlink" title="18、synchronized和ReentrantLock的区别"></a>18、synchronized和ReentrantLock的区别</h2><p>&emsp;synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：</p><ul><li><p>（1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</p></li><li><p>（2）ReentrantLock可以获取各种锁的信息</p></li><li><p>（3）ReentrantLock可以灵活地实现多路通知</p></li></ul><p>&emsp;另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。</p><h2 id="19、ConcurrentHashMap的并发度是什么"><a href="#19、ConcurrentHashMap的并发度是什么" class="headerlink" title="19、ConcurrentHashMap的并发度是什么"></a>19、ConcurrentHashMap的并发度是什么</h2><p>&emsp;ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据</p><h2 id="20、ReadWriteLock是什么"><a href="#20、ReadWriteLock是什么" class="headerlink" title="20、ReadWriteLock是什么"></a>20、ReadWriteLock是什么</h2><p>&emsp;首先明确一下，不是说ReentrantLock不好，只是ReentrantLock某些时候有局限。如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。</p><p>&emsp;因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p><h2 id="21、FutureTask是什么"><a href="#21、FutureTask是什么" class="headerlink" title="21、FutureTask是什么"></a>21、FutureTask是什么</h2><p>&emsp;这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。</p><h2 id="22、Linux环境下如何查找哪个线程使用CPU最长"><a href="#22、Linux环境下如何查找哪个线程使用CPU最长" class="headerlink" title="22、Linux环境下如何查找哪个线程使用CPU最长"></a>22、Linux环境下如何查找哪个线程使用CPU最长</h2><p>&emsp;这是一个比较偏实践的问题，这种问题我觉得挺有意义的。可以这么做：</p><ul><li><p>（1）获取项目的pid，jps或者ps -ef | grep java，这个前面有讲过</p></li><li><p>（2）top -H -p pid，顺序不能改变</p></li></ul><p>&emsp;这样就可以打印出当前的项目，每条线程占用CPU时间的百分比。注意这里打出的是LWP，也就是操作系统原生线程的线程号，我笔记本山没有部署Linux环境下的Java工程，因此没有办法截图演示，网友朋友们如果公司是使用Linux环境部署项目的话，可以尝试一下。</p><p>&emsp;使用”top -H -p pid”+”jps pid”可以很容易地找到某条占用CPU高的线程的线程堆栈，从而定位占用CPU高的原因，一般是因为不当的代码操作导致了死循环。</p><p>&emsp;最后提一点，”top -H -p pid”打出来的LWP是十进制的，”jps pid”打出来的本地线程号是十六进制的，转换一下，就能定位到占用CPU高的线程的当前线程堆栈了。</p><h2 id="23、Java编程写一个会导致死锁的程序"><a href="#23、Java编程写一个会导致死锁的程序" class="headerlink" title="23、Java编程写一个会导致死锁的程序"></a>23、Java编程写一个会导致死锁的程序</h2><p>&emsp;很多人都知道死锁是怎么一回事儿：线程A和线程B相互等待对方持有的锁导致程序无限死循环下去。当然也仅限于此了，问一下怎么写一个死锁的程序就不知道了，这种情况说白了就是不懂什么是死锁，懂一个理论就完事儿了，实践中碰到死锁的问题基本上是看不出来的。</p><p>真正理解什么是死锁，这个问题其实不难，几个步骤：</p><ul><li><p>（1）两个线程里面分别持有两个Object对象：lock1和lock2。这两个lock作为同步代码块的锁；</p></li><li><p>（2）线程1的run()方法中同步代码块先获取lock1的对象锁，Thread.sleep(xxx)，时间不需要太多，50毫秒差不多了，然后接着获取lock2的对象锁。这么做主要是为了防止线程1启动一下子就连续获得了lock1和lock2两个对象的对象锁</p></li><li><p>（3）线程2的run)(方法中同步代码块先获取lock2的对象锁，接着获取lock1的对象锁，当然这时lock1的对象锁已经被线程1锁持有，线程2肯定是要等待线程1释放lock1的对象锁的</p></li></ul><p>&emsp;这样，线程1”睡觉”睡完，线程2已经获取了lock2的对象锁了，线程1此时尝试获取lock2的对象锁，便被阻塞，此时一个死锁就形成了。代码就不写了，占的篇幅有点多，Java多线程7：死锁这篇文章里面有，就是上面步骤的代码实现。</p><h2 id="24、怎么唤醒一个阻塞的线程"><a href="#24、怎么唤醒一个阻塞的线程" class="headerlink" title="24、怎么唤醒一个阻塞的线程"></a>24、怎么唤醒一个阻塞的线程</h2><p>&emsp;如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</p><h2 id="25、不可变对象对多线程有什么帮助"><a href="#25、不可变对象对多线程有什么帮助" class="headerlink" title="25、不可变对象对多线程有什么帮助"></a>25、不可变对象对多线程有什么帮助</h2><p>&emsp;前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。</p><h2 id="26、什么是多线程的上下文切换"><a href="#26、什么是多线程的上下文切换" class="headerlink" title="26、什么是多线程的上下文切换"></a>26、什么是多线程的上下文切换</h2><p>&emsp;多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。</p><h2 id="27、如果你提交任务时，线程池队列已满，这时会发生什么"><a href="#27、如果你提交任务时，线程池队列已满，这时会发生什么" class="headerlink" title="27、如果你提交任务时，线程池队列已满，这时会发生什么"></a>27、如果你提交任务时，线程池队列已满，这时会发生什么</h2><p>这里区分一下：</p><ul><li>1.如果使用的是无界队列LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务</li><li>2.如果使用的是有界队列比如ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，会根据maximumPoolSize的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue继续满，那么则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy</li></ul><h2 id="28、Java中用到的线程调度算法是什么"><a href="#28、Java中用到的线程调度算法是什么" class="headerlink" title="28、Java中用到的线程调度算法是什么"></a>28、Java中用到的线程调度算法是什么</h2><p>&emsp;抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</p><h2 id="29、Thread-sleep-0-的作用是什么"><a href="#29、Thread-sleep-0-的作用是什么" class="headerlink" title="29、Thread.sleep(0)的作用是什么"></a>29、Thread.sleep(0)的作用是什么</h2><p>&emsp;由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。</p><h2 id="30、什么是自旋"><a href="#30、什么是自旋" class="headerlink" title="30、什么是自旋"></a>30、什么是自旋</h2><p>&emsp;很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p><h2 id="31、什么是Java内存模型"><a href="#31、什么是Java内存模型" class="headerlink" title="31、什么是Java内存模型"></a>31、什么是Java内存模型</h2><p>Java内存模型定义了一种多线程访问Java内存的规范。Java内存模型要完整讲不是这里几句话能说清楚的，我简单总结一下Java内存模型的几部分内容：</p><ul><li><p>（1）Java内存模型将内存分为了主内存和工作内存。类的状态，也就是类之间共享的变量，是存储在主内存中的，每次Java线程用到这些主内存中的变量的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去</p></li><li><p>（2）定义了几个原子操作，用于操作主内存和工作内存中的变量</p></li><li><p>（3）定义了volatile变量的使用规则</p></li><li><p>（4）happens-before，即先行发生原则，定义了操作A必然先行发生于操作B的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码、一个释放锁unlock的动作一定先行发生于后面对于同一个锁进行锁定lock的动作等等，只要符合这些规则，则不需要额外做同步措施，如果某段代码不符合所有的happens-before规则，则这段代码一定是线程非安全的</p></li></ul><h2 id="32、什么是CAS"><a href="#32、什么是CAS" class="headerlink" title="32、什么是CAS"></a>32、什么是CAS</h2><p>&emsp;CAS，全称为Compare and Swap，即比较-替换。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。</p><h2 id="33、什么是乐观锁和悲观锁"><a href="#33、什么是乐观锁和悲观锁" class="headerlink" title="33、什么是乐观锁和悲观锁"></a>33、什么是乐观锁和悲观锁</h2><ul><li><p>（1）乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</p></li><li><p>（2）悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。</p></li></ul><h2 id="34、什么是AQS"><a href="#34、什么是AQS" class="headerlink" title="34、什么是AQS"></a>34、什么是AQS</h2><blockquote><p>简单说一下AQS，AQS全称为AbstractQueuedSychronizer，翻译过来应该是抽象队列同步器。</p></blockquote><p>&emsp;如果说java.util.concurrent的基础是CAS的话，那么AQS就是整个Java并发包的核心了，ReentrantLock、CountDownLatch、Semaphore等等都用到了它。AQS实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队列，前面一个线程使用ReentrantLock好了，则双向队列实际上的第一个Entry开始运行。</p><p>&emsp;AQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，开发者可以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。</p><h2 id="35、单例模式的线程安全性"><a href="#35、单例模式的线程安全性" class="headerlink" title="35、单例模式的线程安全性"></a>35、单例模式的线程安全性</h2><p>&emsp;老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下：</p><ul><li><p>（1）饿汉式单例模式的写法：线程安全</p></li><li><p>（2）懒汉式单例模式的写法：非线程安全</p></li><li><p>（3）双检锁单例模式的写法：线程安全</p></li></ul><h2 id="36、Semaphore有什么作用"><a href="#36、Semaphore有什么作用" class="headerlink" title="36、Semaphore有什么作用"></a>36、Semaphore有什么作用</h2><p>&emsp;Semaphore就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。</p><h2 id="37、Hashtable的size-方法中明明只有一条语句”return-count”，为什么还要做同步"><a href="#37、Hashtable的size-方法中明明只有一条语句”return-count”，为什么还要做同步" class="headerlink" title="37、Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步"></a>37、Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步</h2><p>&emsp;这是我之前的一个困惑，不知道大家有没有想过这个问题。某个方法中如果有多条语句，并且都在操作同一个类变量，那么在多线程环境下不加锁，势必会引发线程安全问题，这很好理解，但是size()方法明明只有一条语句，为什么还要加锁？</p><p>关于这个问题，在慢慢地工作、学习中，有了理解，主要原因有两点：</p><ul><li><p>（1）同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性</p></li><li><p>（2）CPU执行代码，执行的不是Java代码，这点很关键，一定得记住。Java代码最终是被翻译成机器码执行的，机器码才是真正可以和硬件电路交互的代码。即使你看到Java代码只有一行，甚至你看到Java代码编译之后生成的字节码也只有一行，也不意味着对于底层来说这句语句的操作只有一个。一句”return count”假设被翻译成了三句汇编语句执行，一句汇编语句和其机器码做对应，完全可能执行完第一句，线程就切换了。</p></li></ul><h2 id="38、线程类的构造方法、静态块是被哪个线程调用的"><a href="#38、线程类的构造方法、静态块是被哪个线程调用的" class="headerlink" title="38、线程类的构造方法、静态块是被哪个线程调用的"></a>38、线程类的构造方法、静态块是被哪个线程调用的</h2><p>&emsp;这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。</p><p>&emsp;如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：</p><ul><li><p>（1）Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的</p></li><li><p>（2）Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的</p></li></ul><h2 id="39、同步方法和同步块，哪个是更好的选择"><a href="#39、同步方法和同步块，哪个是更好的选择" class="headerlink" title="39、同步方法和同步块，哪个是更好的选择"></a>39、同步方法和同步块，哪个是更好的选择</h2><p>&emsp;同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越小越好。</p><p>&emsp;借着这一条，我额外提一点，虽说同步的范围越少越好，但是在Java虚拟机中还是存在着一种叫做锁粗化的优化方法，这种方法就是把同步范围变大。这是有用的，比方说StringBuffer，它是一个线程安全的类，自然最常用的append()方法是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁-&gt;解锁，这对性能不利，因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作，将多次的append的操作扩展到append方法的头尾，变成一个大的同步块，这样就减少了加锁–&gt;解锁的次数，有效地提升了代码执行的效率。</p><h2 id="40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池"><a href="#40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池" class="headerlink" title="40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池"></a>40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池</h2><ul><li><p>（1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换</p></li><li><p>（2）并发不高、任务执行时间长的业务要区分开看：<br>a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务<br>b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换</p></li><li><p>（3）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring经典面试题</title>
      <link href="/2020/01/13/Spring%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/01/13/Spring%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2020/01/13/Spring%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%84%8F%E5%A2%83.jpg" alt=" "></p><h2 id="1、基础概念"><a href="#1、基础概念" class="headerlink" title="1、基础概念"></a>1、基础概念</h2><h3 id="1-1-不同版本的-Spring-Framework-有哪些主要功能"><a href="#1-1-不同版本的-Spring-Framework-有哪些主要功能" class="headerlink" title="1.1. 不同版本的 Spring Framework 有哪些主要功能"></a>1.1. 不同版本的 Spring Framework 有哪些主要功能</h3><table><thead><tr><th align="center">Version</th><th align="center">Feature</th></tr></thead><tbody><tr><td align="center">Spring 2.5</td><td align="center">发布于 2007 年。这是第一个支持注解的版本。</td></tr><tr><td align="center">Spring 3.0</td><td align="center">发布于 2009 年。它完全利用了 Java5 中的改进，并为 JEE6 提供了支持。</td></tr><tr><td align="center">Spring 4.0</td><td align="center">发布于 2013 年。这是第一个完全支持 JAVA8 的版本。</td></tr></tbody></table><h3 id="1-2-什么是-Spring-Framework"><a href="#1-2-什么是-Spring-Framework" class="headerlink" title="1.2. 什么是 Spring Framework"></a>1.2. 什么是 Spring Framework</h3><p>Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。</p><p>它是轻量级、松散耦合的。</p><p>它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。</p><p>它可以集成其他框架，如 Structs、Hibernate、EJB 等，所以又称为框架的框架。</p><h3 id="1-3-列举-Spring-Framework-的优点"><a href="#1-3-列举-Spring-Framework-的优点" class="headerlink" title="1.3. 列举 Spring Framework 的优点"></a>1.3. 列举 Spring Framework 的优点</h3><p>由于 Spring Frameworks 的分层架构，用户可以自由选择自己需要的组件。</p><p>Spring Framework 支持 POJO(Plain Old Java Object) 编程，从而具备持续集成和可测试性。</p><p>由于依赖注入和控制反转，JDBC 得以简化。</p><p>它是开源免费的。</p><h3 id="1-4-Spring-Framework-有哪些不同的功能"><a href="#1-4-Spring-Framework-有哪些不同的功能" class="headerlink" title="1.4. Spring Framework 有哪些不同的功能"></a>1.4. Spring Framework 有哪些不同的功能</h3><p>轻量级 - Spring 在代码量和透明度方面都很轻便。</p><p>IOC - 控制反转</p><p>AOP - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。</p><p>容器 - Spring 负责创建和管理对象（Bean）的生命周期和配置。</p><p>MVC - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。</p><p>事务管理 - 提供了用于事务管理的通用抽象层。</p><p>Spring 的事务支持也可用于容器较少的环境。</p><p>JDBC 异常 - Spring 的 JDBC 抽象层提供了一个异常层次结构，简化了错误处理策略。</p><h3 id="1-5-Spring-Framework-中有多少个模块，它们分别是什么"><a href="#1-5-Spring-Framework-中有多少个模块，它们分别是什么" class="headerlink" title="1.5. Spring Framework 中有多少个模块，它们分别是什么"></a>1.5. Spring Framework 中有多少个模块，它们分别是什么</h3><p><img src="/2020/01/13/Spring%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/SpringFramework.jpg" alt=" "><br>Spring 核心容器 – 该层基本上是 Spring Framework 的核心。它包含以下模块：</p><ul><li>Spring Core</li><li>Spring Bean</li><li>SpEL (Spring Expression Language)</li><li>Spring Context</li></ul><p>数据访问/集成 – 该层提供与数据库交互的支持。它包含以下模块：</p><ul><li>JDBC (Java DataBase Connectivity)</li><li>ORM (Object Relational Mapping)</li><li>OXM (Object XML Mappers)</li><li>JMS (Java Messaging Service)</li><li>Transaction</li></ul><p>Web – 该层提供了创建 Web 应用程序的支持。它包含以下模块：</p><ul><li>Web</li><li>Web – Servlet</li><li>Web – Socket</li><li>Web – Portlet</li></ul><p><strong>AOP</strong> – 该层支持面向切面编程</p><p><strong>Instrumentation</strong> – 该层为类检测和类加载器实现提供支持。</p><p><strong>Test</strong> – 该层为使用 JUnit 和 TestNG 进行测试提供支持。</p><p>几个杂项模块:</p><ul><li>Messaging – 该模块为 STOMP 提供支持。它还支持注解编程模型，该模型用于从 WebSocket 客户端路由和处理 STOMP 消息</li><li>Aspects – 该模块为与 AspectJ 的集成提供支持。</li></ul><h3 id="1-6-什么是-Spring-配置文件"><a href="#1-6-什么是-Spring-配置文件" class="headerlink" title="1.6. 什么是 Spring 配置文件"></a>1.6. 什么是 Spring 配置文件</h3><p>Spring 配置文件是 XML 文件。该文件主要包含类信息。它描述了这些类是如何配置以及相互引入的。但是，XML 配置文件冗长且更加干净。如果没有正确规划和编写，那么在大项目中管理变得非常困难。</p><h3 id="1-7-Spring-应用程序有哪些不同组件"><a href="#1-7-Spring-应用程序有哪些不同组件" class="headerlink" title="1.7. Spring 应用程序有哪些不同组件"></a>1.7. Spring 应用程序有哪些不同组件</h3><p>Spring 应用一般有以下组件：</p><p><strong>接口</strong> - 定义功能。</p><p><strong>Bean 类</strong> - 它包含属性，setter 和 getter 方法，函数等。</p><p><strong>Spring 面向切面编程（AOP）</strong> - 提供面向切面编程的功能。</p><p><strong>Bean 配置文件</strong> - 包含类的信息以及如何配置它们。</p><p><strong>用户程序</strong> - 它使用接口。</p><h3 id="1-8-使用-Spring-有哪些方式"><a href="#1-8-使用-Spring-有哪些方式" class="headerlink" title="1.8. 使用 Spring 有哪些方式"></a>1.8. 使用 Spring 有哪些方式</h3><p>使用 Spring 有以下方式：</p><ul><li>作为一个成熟的 Spring Web 应用程序。</li><li>作为第三方 Web 框架，使用 Spring Frameworks 中间层。</li><li>用于远程使用。</li><li>作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。</li></ul><h2 id="2、依赖注入（Ioc）"><a href="#2、依赖注入（Ioc）" class="headerlink" title="2、依赖注入（Ioc）"></a>2、依赖注入（Ioc）</h2><h3 id="2-1-什么是-Spring-IOC-容器"><a href="#2-1-什么是-Spring-IOC-容器" class="headerlink" title="2.1. 什么是 Spring IOC 容器"></a>2.1. 什么是 Spring IOC 容器</h3><p>Spring 框架的核心是 Spring 容器。容器创建对象，将它们装配在一起，配置它们并管理它们的完整生命周期。Spring 容器使用依赖注入来管理组成应用程序的组件。</p><p>容器通过读取提供的配置元数据来接收对象进行实例化，配置和组装的指令。该元数据可以通过 XML，Java 注解或 Java 代码提供。<br><img src="/2020/01/13/Spring%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/SpringIOC%E5%AE%B9%E5%99%A8.jpg" alt=" "></p><h3 id="2-2-什么是依赖注入"><a href="#2-2-什么是依赖注入" class="headerlink" title="2.2. 什么是依赖注入"></a>2.2. 什么是依赖注入</h3><p>在依赖注入中，您不必创建对象，但必须描述如何创建它们。您不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务。由 IoC 容器将它们装配在一起。</p><h3 id="2-3-可以通过多少种方式完成依赖注入"><a href="#2-3-可以通过多少种方式完成依赖注入" class="headerlink" title="2.3. 可以通过多少种方式完成依赖注入"></a>2.3. 可以通过多少种方式完成依赖注入</h3><p>通常，依赖注入可以通过三种方式完成，即：</p><ul><li>构造函数注入</li><li>setter 注入</li><li>接口注入</li></ul><p>在 Spring Framework 中，仅使用构造函数和 setter 注入。</p><h3 id="2-4-区分构造函数注入和-setter-注入"><a href="#2-4-区分构造函数注入和-setter-注入" class="headerlink" title="2.4. 区分构造函数注入和 setter 注入"></a>2.4. 区分构造函数注入和 setter 注入</h3><table><thead><tr><th align="center">构造函数注入</th><th align="center">setter 注入</th></tr></thead><tbody><tr><td align="center">没有部分注入</td><td align="center">有部分注入</td></tr><tr><td align="center">不会覆盖 setter 属性</td><td align="center">会覆盖 setter 属性</td></tr><tr><td align="center">任意修改都会创建一个新实例</td><td align="center">任意修改不会创建一个新实例</td></tr><tr><td align="center">适用于设置很多属性</td><td align="center">适用于设置少量属性</td></tr></tbody></table><h3 id="2-5-spring-中有多少种-IOC-容器"><a href="#2-5-spring-中有多少种-IOC-容器" class="headerlink" title="2.5. spring 中有多少种 IOC 容器"></a>2.5. spring 中有多少种 IOC 容器</h3><ul><li>BeanFactory - BeanFactory 就像一个包含 bean 集合的工厂类。它会在客户端要求时实例化 bean。</li><li>ApplicationContext - ApplicationContext 接口扩展了 BeanFactory 接口。它在 BeanFactory 基础上提供了一些额外的功能。</li></ul><h3 id="2-6-区分-BeanFactory-和-ApplicationContext"><a href="#2-6-区分-BeanFactory-和-ApplicationContext" class="headerlink" title="2.6. 区分 BeanFactory 和 ApplicationContext"></a>2.6. 区分 BeanFactory 和 ApplicationContext</h3><table><thead><tr><th align="center">BeanFactory</th><th align="center">ApplicationContext</th></tr></thead><tbody><tr><td align="center">它使用懒加载</td><td align="center">它使用即时加载</td></tr><tr><td align="center">它使用语法显式提供资源对象</td><td align="center">它自己创建和管理资源对象</td></tr><tr><td align="center">不支持国际化</td><td align="center">支持国际化</td></tr><tr><td align="center">不支持基于依赖的注解</td><td align="center">支持基于依赖的注解</td></tr></tbody></table><h3 id="2-7-列举-IoC-的一些好处"><a href="#2-7-列举-IoC-的一些好处" class="headerlink" title="2.7. 列举 IoC 的一些好处"></a>2.7. 列举 IoC 的一些好处</h3><p>IoC 的一些好处是：</p><ul><li>它将最小化应用程序中的代码量。</li><li>它将使您的应用程序易于测试，因为它不需要单元测试用例中的任何单例或 JNDI 查找机制。</li><li>它以最小的影响和最少的侵入机制促进松耦合。</li><li>它支持即时的实例化和延迟加载服务。</li></ul><h3 id="2-8-Spring-IoC-的实现机制"><a href="#2-8-Spring-IoC-的实现机制" class="headerlink" title="2.8. Spring IoC 的实现机制"></a>2.8. Spring IoC 的实现机制</h3><p>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Apple"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Orange"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">getInstance</span><span class="params">(String ClassName)</span> </span>&#123;</span><br><span class="line">        Fruit f=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f=(Fruit)Class.forName(ClassName).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a)</span> </span>&#123;</span><br><span class="line">        Fruit f=Factory.getInstance(<span class="string">"io.github.dunwu.spring.Apple"</span>);</span><br><span class="line">        <span class="keyword">if</span>(f!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            f.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、Beans"><a href="#3、Beans" class="headerlink" title="3、Beans"></a>3、Beans</h2><h3 id="3-1-什么是-spring-bean"><a href="#3-1-什么是-spring-bean" class="headerlink" title="3.1. 什么是 spring bean"></a>3.1. 什么是 spring bean</h3><ul><li>它们是构成用户应用程序主干的对象。</li><li>Bean 由 Spring IoC 容器管理。</li><li>它们由 Spring IoC 容器实例化，配置，装配和管理。</li><li>Bean 是基于用户提供给容器的配置元数据创建。</li></ul><h3 id="3-2-spring-提供了哪些配置方式"><a href="#3-2-spring-提供了哪些配置方式" class="headerlink" title="3.2. spring 提供了哪些配置方式"></a>3.2. spring 提供了哪些配置方式</h3><ul><li>基于 xml 配置</li></ul><p>bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"studentbean"</span> <span class="attr">class</span>=<span class="string">"org.edureka.firstSpring.StudentBean"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Edureka"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>基于注解配置</li></ul><p>您可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 XML 来描述 bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- bean definitions go here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>基于 Java API 配置</li></ul><p>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。</p><p>1.@Bean 注解扮演与 &lt; bean/ &gt; 元素相同的角色。</p><p>2.@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentBean <span class="title">myStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-spring-支持集中-bean-scope"><a href="#3-3-spring-支持集中-bean-scope" class="headerlink" title="3.3. spring 支持集中 bean scope"></a>3.3. spring 支持集中 bean scope</h3><p>Spring bean 支持 5 种 scope：</p><ul><li>Singleton - 每个 Spring IoC 容器仅有一个单实例。</li><li>Prototype - 每次请求都会产生一个新的实例。</li><li>Request - 每一次 HTTP 请求都会产生一个新的实例，并且该 bean 仅在当前 HTTP 请求内有效。</li><li>Session - 每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效。</li><li>Global-session - 类似于标准的 HTTP Session 作用域，不过它仅仅在基于 portlet 的 web 应用中才有意义。Portlet 规范定义了全局 Session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享。在 global session 作用域中定义的 bean 被限定于全局 portlet Session 的生命周期范围内。如果你在 web 中使用 global session 作用域来标识 bean，那么 web 会自动当成 session 类型来使用。</li></ul><p>仅当用户使用支持 Web 的 ApplicationContext 时，最后三个才可用。更多spring内容</p><h3 id="3-4-spring-bean-容器的生命周期是什么样的"><a href="#3-4-spring-bean-容器的生命周期是什么样的" class="headerlink" title="3.4. spring bean 容器的生命周期是什么样的"></a>3.4. spring bean 容器的生命周期是什么样的</h3><p>spring bean 容器的生命周期流程如下：</p><p>1.Spring 容器根据配置中的 bean 定义中实例化 bean</p><p>2.Spring 使用依赖注入填充所有属性，如 bean 中所定义的配置。</p><p>3.如果 bean 实现 BeanNameAware 接口，则工厂通过传递 bean 的 ID 来调用 setBeanName()。</p><p>4.如果 bean 实现 BeanFactoryAware 接口，工厂通过传递自身的实例来调用 setBeanFactory()。</p><p>5.如果存在与 bean 关联的任何 BeanPostProcessors，则调用 preProcessBeforeInitialization() 方法。</p><p>6.如果为 bean 指定了 init 方法（ &lt; bean &gt;的 init-method 属性），那么将调用它。</p><p>7.最后，如果存在与 bean 关联的任何 BeanPostProcessors，则将调用postProcessAfterInitialization() 方法。</p><p>8.如果 bean 实现 DisposableBean 接口，当 spring 容器关闭时，会调用 destory()。</p><p>9.如果为 bean 指定了 destroy 方法（ &lt; bean &gt;的 destroy-method 属性），那么将调用它。<br><img src="/2020/01/13/Spring%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/SpringBean%E5%AE%B9%E5%99%A8.png" alt=" "></p><h3 id="3-5-什么是-spring-的内部-bean"><a href="#3-5-什么是-spring-的内部-bean" class="headerlink" title="3.5. 什么是 spring 的内部 bean"></a>3.5. 什么是 spring 的内部 bean</h3><p>只有将 bean 用作另一个 bean 的属性时，才能将 bean 声明为内部 bean。为了定义 bean，Spring 的基于 XML 的配置元数据在&lt; property &gt;或&lt; constructor-arg &gt; 中提供了&lt; bean &gt;元素的使用。内部 bean 总是匿名的，它们总是作为原型。<br>例如，假设我们有一个 Student 类，其中引用了 Person 类。这里我们将只创建一个 Person 类实例并在 Student 中使用它。</p><p>Student.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line">    <span class="comment">//Setters and Getters</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="comment">//Setters and Getters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bean.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“StudentBean</span>" <span class="attr">class</span>=<span class="string">"com.edureka.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"person"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--This is inner bean --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.edureka.Person"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">“Scott</span>"&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">value</span>=<span class="string">“Bangalore</span>"&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-6-什么是-spring-装配"><a href="#3-6-什么是-spring-装配" class="headerlink" title="3.6. 什么是 spring 装配"></a>3.6. 什么是 spring 装配</h3><p>当 bean 在 Spring 容器中组合在一起时，它被称为装配或 bean 装配。Spring 容器需要知道需要什么 bean 以及容器应该如何使用依赖注入来将 bean 绑定在一起，同时装配 bean。</p><h3 id="3-7-自动装配有哪些方式"><a href="#3-7-自动装配有哪些方式" class="headerlink" title="3.7. 自动装配有哪些方式"></a>3.7. 自动装配有哪些方式</h3><p>Spring 容器能够自动装配 bean。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 bean 的协作者。</p><p>自动装配的不同模式：</p><ul><li>no - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。</li><li>byName - 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 bean。</li><li>byType - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 bean 名称匹配，则匹配并装配属性。</li><li>构造函数 - 它通过调用类的构造函数来注入依赖项。它有大量的参数。</li><li>autodetect - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。</li></ul><h3 id="3-8-自动装配有什么局限"><a href="#3-8-自动装配有什么局限" class="headerlink" title="3.8. 自动装配有什么局限"></a>3.8. 自动装配有什么局限</h3><ul><li>覆盖的可能性 - 您始终可以使用&lt; constructor-arg &gt; 和 &lt; property &gt;设置指定依赖项，这将覆盖自动装配。</li><li>基本元数据类型 - 简单属性（如原数据类型，字符串和类）无法自动装配。</li><li>令人困惑的性质 - 总是喜欢使用明确的装配，因为自动装配不太精确。</li></ul><h2 id="4、注-解"><a href="#4、注-解" class="headerlink" title="4、注 解"></a>4、注 解</h2><h3 id="4-1-你用过哪些重要的-Spring-注解"><a href="#4-1-你用过哪些重要的-Spring-注解" class="headerlink" title="4.1. 你用过哪些重要的 Spring 注解"></a>4.1. 你用过哪些重要的 Spring 注解</h3><ul><li>@Controller - 用于 Spring MVC 项目中的控制器类。</li><li>@Service - 用于服务类。</li><li>@RequestMapping - 用于在控制器处理程序方法中配置 URI 映射。</li><li>@ResponseBody - 用于发送 Object 作为响应，通常用于发送 XML 或 JSON 数据作为响应。</li><li>@PathVariable - 用于将动态值从 URI 映射到处理程序方法参数。</li><li>@Autowired - 用于在 spring bean 中自动装配依赖项。</li><li>@Qualifier - 使用 @Autowired 注解，以避免在存在多个 bean 类型实例时出现混淆。</li><li>@Scope - 用于配置 spring bean 的范围。</li><li>@Configuration，@ComponentScan 和 @Bean - 用于基于 java 的配置。</li><li>@Aspect，@Before，@After，@Around，@Pointcut - 用于切面编程（AOP）。</li></ul><h3 id="4-2-如何在-spring-中启动注解装配"><a href="#4-2-如何在-spring-中启动注解装配" class="headerlink" title="4.2. 如何在 spring 中启动注解装配"></a>4.2. 如何在 spring 中启动注解装配</h3><p>默认情况下，Spring 容器中未打开注解装配。因此，要使用基于注解装配，我们必须通过配置&lt; context：annotation-config /&gt; 元素在 Spring 配置文件中启用它。</p><h3 id="4-3-Component-Controller-Repository-Service-有何区别"><a href="#4-3-Component-Controller-Repository-Service-有何区别" class="headerlink" title="4.3. @Component, @Controller, @Repository, @Service 有何区别"></a>4.3. @Component, @Controller, @Repository, @Service 有何区别</h3><ul><li>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</li><li>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</li><li>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</li><li>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</li></ul><h3 id="4-4-Required-注解有什么用"><a href="#4-4-Required-注解有什么用" class="headerlink" title="4.4. @Required 注解有什么用"></a>4.4. @Required 注解有什么用</h3><p>@Required 应用于 bean 属性 setter 方法。此注解仅指示必须在配置时使用 bean 定义中的显式属性值或使用自动装配填充受影响的 bean 属性。如果尚未填充受影响的 bean 属性，则容器将抛出 BeanInitializationException。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> string <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-Autowired-注解有什么用"><a href="#4-5-Autowired-注解有什么用" class="headerlink" title="4.5. @Autowired 注解有什么用"></a>4.5. @Autowired 注解有什么用</h3><p>@Autowired 可以更准确地控制应该在何处以及如何进行自动装配。此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配 bean。默认情况下，它是类型驱动的注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> string <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-Qualifier-注解有什么用"><a href="#4-6-Qualifier-注解有什么用" class="headerlink" title="4.6. @Qualifier 注解有什么用"></a>4.6. @Qualifier 注解有什么用</h3><p>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。<br>例如，这里我们分别有两个类，Employee 和 EmpAccount。在 EmpAccount 中，使用@Qualifier 指定了必须装配 id 为 emp1 的 bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EmpAccount.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpAccount</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Employee emp;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(emp1)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(“Employee name : ”+emp.getName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-7-RequestMapping-注解有什么用"><a href="#4-7-RequestMapping-注解有什么用" class="headerlink" title="4.7. @RequestMapping 注解有什么用"></a>4.7. @RequestMapping 注解有什么用</h3><p>@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注解可应用于两个级别：</p><ul><li><p>类级别：映射请求的 URL</p></li><li><p>方法级别：映射 URL 以及 HTTP 请求方法</p></li></ul><h2 id="5、数据访问"><a href="#5、数据访问" class="headerlink" title="5、数据访问"></a>5、数据访问</h2><h3 id="5-1-spring-DAO-有什么用"><a href="#5-1-spring-DAO-有什么用" class="headerlink" title="5.1. spring DAO 有什么用"></a>5.1. spring DAO 有什么用</h3><p>Spring DAO 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。</p><h3 id="5-2-列举-Spring-DAO-抛出的异常"><a href="#5-2-列举-Spring-DAO-抛出的异常" class="headerlink" title="5.2. 列举 Spring DAO 抛出的异常"></a>5.2. 列举 Spring DAO 抛出的异常</h3><p><img src="/2020/01/13/Spring%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/SpringDao%E5%BC%82%E5%B8%B8.jpg" alt=" "></p><h3 id="5-3-spring-JDBC-API-中存在哪些类"><a href="#5-3-spring-JDBC-API-中存在哪些类" class="headerlink" title="5.3. spring JDBC API 中存在哪些类"></a>5.3. spring JDBC API 中存在哪些类</h3><ul><li>JdbcTemplate</li><li>SimpleJdbcTemplate</li><li>NamedParameterJdbcTemplate</li><li>SimpleJdbcInsert</li><li>SimpleJdbcCall</li></ul><h3 id="5-4-使用-Spring-访问-Hibernate-的方法有哪些"><a href="#5-4-使用-Spring-访问-Hibernate-的方法有哪些" class="headerlink" title="5.4. 使用 Spring 访问 Hibernate 的方法有哪些"></a>5.4. 使用 Spring 访问 Hibernate 的方法有哪些</h3><p>我们可以通过两种方式使用 Spring 访问 Hibernate：</p><ul><li>使用 Hibernate 模板和回调进行控制反转</li><li>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点</li></ul><h3 id="5-5-列举-spring-支持的事务管理类型"><a href="#5-5-列举-spring-支持的事务管理类型" class="headerlink" title="5.5. 列举 spring 支持的事务管理类型"></a>5.5. 列举 spring 支持的事务管理类型</h3><p>Spring 支持两种类型的事务管理：</p><ul><li>程序化事务管理：在此过程中，在编程的帮助下管理事务。它为您提供极大的灵活性，但维护起来非常困难。</li><li>声明式事务管理：在此，事务管理与业务代码分离。仅使用注解或基于 XML 的配置来管理事务。</li></ul><h3 id="5-6-Spring-支持哪些-ORM-框架"><a href="#5-6-Spring-支持哪些-ORM-框架" class="headerlink" title="5.6. Spring 支持哪些 ORM 框架"></a>5.6. Spring 支持哪些 ORM 框架</h3><ul><li>Hibernate</li><li>iBatis</li><li>JPA</li><li>JDO</li><li>OJB</li></ul><h2 id="6、AOP"><a href="#6、AOP" class="headerlink" title="6、AOP"></a>6、AOP</h2><h3 id="6-1-什么是-AOP"><a href="#6-1-什么是-AOP" class="headerlink" title="6.1. 什么是 AOP"></a>6.1. 什么是 AOP</h3><p>AOP(Aspect-Oriented Programming), 即 面向切面编程, 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成, 提供了与 OOP 不同的抽象软件结构的视角.</p><p>在 OOP 中, 我们以类(class)作为我们的基本单元, 而 AOP 中的基本单元是 Aspect(切面)</p><h3 id="6-2-AOP-中的-Aspect、Advice、Pointcut、JointPoint-和-Advice-参数分别是什么"><a href="#6-2-AOP-中的-Aspect、Advice、Pointcut、JointPoint-和-Advice-参数分别是什么" class="headerlink" title="6.2. AOP 中的 Aspect、Advice、Pointcut、JointPoint 和 Advice 参数分别是什么"></a>6.2. AOP 中的 Aspect、Advice、Pointcut、JointPoint 和 Advice 参数分别是什么</h3><p><img src="/2020/01/13/Spring%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/AOP.png" alt=" "></p><ul><li>Aspect - Aspect 是一个实现交叉问题的类，例如事务管理。方面可以是配置的普通类，然后在 Spring Bean 配置文件中配置，或者我们可以使用 Spring AspectJ 支持使用 @Aspect 注解将类声明为 Aspect。</li><li>Advice - Advice 是针对特定 JoinPoint 采取的操作。在编程方面，它们是在应用程序中达到具有匹配切入点的特定 JoinPoint 时执行的方法。您可以将 Advice 视为 Spring 拦截器（Interceptor）或 Servlet 过滤器（filter）。</li><li>Advice Arguments - 我们可以在 advice 方法中传递参数。我们可以在切入点中使用 args() 表达式来应用于与参数模式匹配的任何方法。如果我们使用它，那么我们需要在确定参数类型的 advice 方法中使用相同的名称。</li><li>Pointcut - Pointcut 是与 JoinPoint 匹配的正则表达式，用于确定是否需要执行 Advice。Pointcut 使用与 JoinPoint 匹配的不同类型的表达式。Spring 框架使用 AspectJ Pointcut 表达式语言来确定将应用通知方法的 JoinPoint。</li><li>JoinPoint - JoinPoint 是应用程序中的特定点，例如方法执行，异常处理，更改对象变量值等。在 Spring AOP 中，JoinPoint 始终是方法的执行器。</li></ul><h3 id="6-3-什么是通知（Advice）"><a href="#6-3-什么是通知（Advice）" class="headerlink" title="6.3. 什么是通知（Advice）"></a>6.3. 什么是通知（Advice）</h3><p>特定 JoinPoint 处的 Aspect 所采取的动作称为 Advice。Spring AOP 使用一个 Advice 作为拦截器，在 JoinPoint “周围”维护一系列的拦截器。</p><h3 id="6-4-有哪些类型的通知（Advice）"><a href="#6-4-有哪些类型的通知（Advice）" class="headerlink" title="6.4. 有哪些类型的通知（Advice）"></a>6.4. 有哪些类型的通知（Advice）</h3><ul><li>Before - 这些类型的 Advice 在 joinpoint 方法之前执行，并使用 @Before 注解标记进行配置。</li><li>After Returning - 这些类型的 Advice 在连接点方法正常执行后执行，并使用@AfterReturning 注解标记进行配置。</li><li>After Throwing - 这些类型的 Advice 仅在 joinpoint 方法通过抛出异常退出并使用 @AfterThrowing 注解标记配置时执行。</li><li>After (finally) - 这些类型的 Advice 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 @After 注解标记进行配置。</li><li>Around - 这些类型的 Advice 在连接点之前和之后执行，并使用 @Around 注解标记进行配置。</li></ul><h3 id="6-5-指出在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处"><a href="#6-5-指出在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处" class="headerlink" title="6.5. 指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处"></a>6.5. 指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处</h3><p>concern 是我们想要在应用程序的特定模块中定义的行为。它可以定义为我们想要实现的功能。</p><p>cross-cutting concern 是一个适用于整个应用的行为，这会影响整个应用程序。例如，日志记录，安全性和数据传输是应用程序几乎每个模块都需要关注的问题，因此它们是跨领域的问题。</p><h3 id="6-6-AOP-有哪些实现方式"><a href="#6-6-AOP-有哪些实现方式" class="headerlink" title="6.6. AOP 有哪些实现方式"></a>6.6. AOP 有哪些实现方式</h3><p>实现 AOP 的技术，主要分为两大类：</p><ul><li>静态代理 - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；</li><li>编译时编织（特殊编译器实现）</li><li>类加载时编织（特殊的类加载器实现）。</li><li>动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。</li><li>JDK 动态代理</li><li>CGLIB</li></ul><h3 id="6-7-Spring-AOP-and-AspectJ-AOP-有什么区别"><a href="#6-7-Spring-AOP-and-AspectJ-AOP-有什么区别" class="headerlink" title="6.7. Spring AOP and AspectJ AOP 有什么区别"></a>6.7. Spring AOP and AspectJ AOP 有什么区别</h3><p>Spring AOP 基于动态代理方式实现；AspectJ 基于静态代理方式实现。</p><p>Spring AOP 仅支持方法级别的 PointCut；提供了完全的 AOP 支持，它还支持属性级别的 PointCut。</p><h3 id="6-8-如何理解-Spring-中的代理"><a href="#6-8-如何理解-Spring-中的代理" class="headerlink" title="6.8. 如何理解 Spring 中的代理"></a>6.8. 如何理解 Spring 中的代理</h3><p>将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Advice + Target Object &#x3D; Proxy</span><br></pre></td></tr></table></figure><h3 id="6-9-什么是编织（Weaving）"><a href="#6-9-什么是编织（Weaving）" class="headerlink" title="6.9. 什么是编织（Weaving）"></a>6.9. 什么是编织（Weaving）</h3><p>为了创建一个 advice 对象而链接一个 aspect 和其它应用类型或对象，称为编织（Weaving）。在 Spring AOP 中，编织在运行时执行。请参考下图：</p><p><img src="/2020/01/13/Spring%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%BC%96%E7%BB%87.png" alt=" "></p><h2 id="7、MVC"><a href="#7、MVC" class="headerlink" title="7、MVC"></a>7、MVC</h2><h3 id="7-1-Spring-MVC-框架有什么用"><a href="#7-1-Spring-MVC-框架有什么用" class="headerlink" title="7.1. Spring MVC 框架有什么用"></a>7.1. Spring MVC 框架有什么用</h3><p>Spring Web MVC 框架提供 模型-视图-控制器 架构和随时可用的组件，用于开发灵活且松散耦合的 Web 应用程序。MVC 模式有助于分离应用程序的不同方面，如输入逻辑，业务逻辑和 UI 逻辑，同时在所有这些元素之间提供松散耦合。</p><h3 id="7-2-描述一下-DispatcherServlet-的工作流程"><a href="#7-2-描述一下-DispatcherServlet-的工作流程" class="headerlink" title="7.2. 描述一下 DispatcherServlet 的工作流程"></a>7.2. 描述一下 DispatcherServlet 的工作流程</h3><p>DispatcherServlet 的工作流程可以用一幅图来说明：</p><p><img src="/2020/01/13/Spring%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/DispatcherServlet.png" alt=" "></p><p>1.向服务器发送 HTTP 请求，请求被前端控制器 DispatcherServlet 捕获。</p><p>2.DispatcherServlet 根据 -servlet.xml 中的配置对请求的 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以HandlerExecutionChain 对象的形式返回。</p><p>3.DispatcherServlet 根据获得的Handler，选择一个合适的 HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的 preHandler(…)方法）。</p><p>4.提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。在填充Handler的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：</p><ul><li>HttpMessageConveter：将请求消息（如 Json、xml 等数据）转换成一个对象，将对象转换为指定的响应信息。</li><li>数据转换：对请求消息进行数据转换。如String转换成Integer、Double等。</li><li>数据根式化：对请求消息进行数据格式化。如将字符串转换成格式化数字或格式化日期等。</li><li>数据验证：验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中。</li></ul><p>5.Handler(Controller)执行完成后，向 DispatcherServlet 返回一个 ModelAndView 对象；</p><p>6.根据返回的ModelAndView，选择一个适合的 ViewResolver（必须是已经注册到 Spring 容器中的ViewResolver)返回给DispatcherServlet。</p><p>7.ViewResolver 结合Model和View，来渲染视图。</p><p>8.视图负责将渲染结果返回给客户端。</p><h3 id="7-3-介绍一下-WebApplicationContext"><a href="#7-3-介绍一下-WebApplicationContext" class="headerlink" title="7.3. 介绍一下 WebApplicationContext"></a>7.3. 介绍一下 WebApplicationContext</h3><p>WebApplicationContext 是 ApplicationContext 的扩展。它具有 Web 应用程序所需的一些额外功能。它与普通的 ApplicationContext 在解析主题和决定与哪个 servlet 关联的能力方面有所不同。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试题 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识面试题</title>
      <link href="/2020/01/13/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/01/13/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2020/01/13/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98/java.jpg" alt=" "></p><h2 id="Java概述"><a href="#Java概述" class="headerlink" title="Java概述"></a>Java概述</h2><h3 id="何为编程"><a href="#何为编程" class="headerlink" title="何为编程"></a>何为编程</h3><blockquote><p>编程就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。</p></blockquote><p>为了使计算机能够理解人的意图，人类就必须要将需解决的问题的思路、方法、和手段通过计算机能够理解的形式告诉计算机，使得计算机能够根据人的指令一步一步去工作，完成某种特定的任务。这种人和计算机之间交流的过程就是编程。</p><h3 id="什么是Java"><a href="#什么是Java" class="headerlink" title="什么是Java"></a>什么是Java</h3><blockquote><p>Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。</p></blockquote><h3 id="jdk1-5之后的三大版本"><a href="#jdk1-5之后的三大版本" class="headerlink" title="jdk1.5之后的三大版本"></a>jdk1.5之后的三大版本</h3><p>Java SE（J2SE，Java 2 Platform Standard Edition，标准版）<br>Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为Java EE和Java ME提供基础。<br>Java EE（J2EE，Java 2 Platform Enterprise Edition，企业版）<br>Java EE 以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web2.0应用程序。2018年2月，Eclipse 宣布正式将 JavaEE 更名为 JakartaEE<br>Java ME（J2ME，Java 2 Platform Micro Edition，微型版）<br>Java ME 以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。</p><h3 id="JVM、JRE和JDK的关系"><a href="#JVM、JRE和JDK的关系" class="headerlink" title="JVM、JRE和JDK的关系"></a>JVM、JRE和JDK的关系</h3><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><blockquote><p>Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。</p></blockquote><h4 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h4><blockquote><p>Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包<br>如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</p></blockquote><h4 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h4><blockquote><p>Java Development Kit是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等</p></blockquote><h4 id="JVM-amp-JRE-amp-JDK关系图"><a href="#JVM-amp-JRE-amp-JDK关系图" class="headerlink" title="JVM&amp;JRE&amp;JDK关系图"></a>JVM&amp;JRE&amp;JDK关系图</h4><p><img src="/2020/01/13/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg" alt=" "></p><h3 id="什么是跨平台性？原理是什么"><a href="#什么是跨平台性？原理是什么" class="headerlink" title="什么是跨平台性？原理是什么"></a>什么是跨平台性？原理是什么</h3><blockquote><p>所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上运行。</p></blockquote><p><strong>实现原理：</strong> Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。</p><h3 id="Java语言有哪些特点"><a href="#Java语言有哪些特点" class="headerlink" title="Java语言有哪些特点"></a>Java语言有哪些特点</h3><ul><li><p>简单易学（Java语言的语法与C语言和C++语言很接近）</p></li><li><p>面向对象（封装，继承，多态）</p></li><li><p>平台无关性（Java虚拟机实现平台无关性）</p></li><li><p>支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的）</p></li><li><p>支持多线程（多线程机制使应用程序在同一时间并行执行多项任）</p></li><li><p>健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等）</p></li><li><p>安全性</p></li></ul><h3 id="什么是字节码？采用字节码的最大好处是什么"><a href="#什么是字节码？采用字节码的最大好处是什么" class="headerlink" title="什么是字节码？采用字节码的最大好处是什么"></a>什么是字节码？采用字节码的最大好处是什么</h3><p><strong>字节码：</strong> Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。</p><p><strong>采用字节码的好处：</strong></p><p>Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p><p><strong>先看下java中的编译器和解释器：</strong></p><p>Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存的解释。</p><p>Java源代码—-&gt;编译器—-&gt;jvm可执行的Java字节码(即虚拟指令)—-&gt;jvm—-&gt;jvm中解释器—–&gt;</p><h3 id="什么是Java程序的主类？应用程序和小程序的主类有何不同"><a href="#什么是Java程序的主类？应用程序和小程序的主类有何不同" class="headerlink" title="什么是Java程序的主类？应用程序和小程序的主类有何不同"></a>什么是Java程序的主类？应用程序和小程序的主类有何不同</h3><p>一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main()方法的类。而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。</p><h3 id="Java应用程序与小程序之间有那些差别"><a href="#Java应用程序与小程序之间有那些差别" class="headerlink" title="Java应用程序与小程序之间有那些差别"></a>Java应用程序与小程序之间有那些差别</h3><p>简单说应用程序是从主线程启动(也就是main()方法)。applet小程序没有main方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟flash的小游戏类似。</p><h3 id="Java和C-的区别"><a href="#Java和C-的区别" class="headerlink" title="Java和C++的区别"></a>Java和C++的区别</h3><ul><li>都是面向对象的语言，都支持封装、继承和多态</li><li>Java不提供指针来直接访问内存，程序内存更加安全</li><li>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。</li><li>Java有自动内存管理机制，不需要程序员手动释放无用内存</li></ul><h3 id="Oracle-JDK-和-OpenJDK-的对比"><a href="#Oracle-JDK-和-OpenJDK-的对比" class="headerlink" title="Oracle JDK 和 OpenJDK 的对比"></a>Oracle JDK 和 OpenJDK 的对比</h3><ul><li>Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次；</li><li>OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的；</li><li>Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题；</li><li>在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能；</li><li>Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li><li>Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。</li></ul><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="Java有哪些数据类型"><a href="#Java有哪些数据类型" class="headerlink" title="Java有哪些数据类型"></a>Java有哪些数据类型</h4><p><strong>定义：</strong> Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。</p><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><p>基本数据类型</p><ul><li>整数类型(byte,short,int,long)</li><li>浮点类型(float,double)</li><li>数值型</li><li>字符型(char)</li><li>布尔型(boolean)</li></ul><p>引用数据类型</p><ul><li>类(class)</li><li>接口(interface)</li><li>数组([])</li></ul><h5 id="Java基本数据类型图"><a href="#Java基本数据类型图" class="headerlink" title="Java基本数据类型图"></a>Java基本数据类型图</h5><p><img src="/2020/01/13/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9B%BE.jpg" alt=" "></p><h4 id="switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上"><a href="#switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上" class="headerlink" title="switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上"></a>switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上</h4><p>在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从 Java5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，从 Java 7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。</p><h4 id="用最有效率的方法计算-2-乘以-8"><a href="#用最有效率的方法计算-2-乘以-8" class="headerlink" title="用最有效率的方法计算 2 乘以 8"></a>用最有效率的方法计算 2 乘以 8</h4><p>2 &lt;&lt; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。</p><h4 id="Math-round-11-5-等于多少？Math-round-11-5-等于多少"><a href="#Math-round-11-5-等于多少？Math-round-11-5-等于多少" class="headerlink" title="Math.round(11.5) 等于多少？Math.round(-11.5)等于多少"></a>Math.round(11.5) 等于多少？Math.round(-11.5)等于多少</h4><p>Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加 0.5 然后进行下取整。</p><h4 id="float-f-3-4-是否正确"><a href="#float-f-3-4-是否正确" class="headerlink" title="float f=3.4;是否正确"></a>float f=3.4;是否正确</h4><p>不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成 float f =3.4F;。</p><h4 id="short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗"><a href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗" class="headerlink" title="short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗"></a>short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗</h4><p>对于 short s1 = 1; s1 = s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型。</p><p>而 short s1 = 1; s1 += 1;可以正确编译，因为 s1+= 1;相当于 s1 = (short(s1 + 1);其中有隐含的强制类型转换。</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><h4 id="Java语言采用何种编码方案？有何特点"><a href="#Java语言采用何种编码方案？有何特点" class="headerlink" title="Java语言采用何种编码方案？有何特点"></a>Java语言采用何种编码方案？有何特点</h4><p>Java语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><h4 id="什么是Java注释"><a href="#什么是Java注释" class="headerlink" title="什么是Java注释"></a>什么是Java注释</h4><p><strong>定义：</strong> 用于解释说明程序的文字</p><p><strong>分类</strong>：</p><p>单行注释</p><ul><li>格式：// 注释文字</li></ul><p>多行注释</p><ul><li>格式：/<em>注释文字</em>/</li></ul><p>文档注释</p><ul><li>格式：/** 注释文字 */</li></ul><p><strong>作用</strong>：</p><p>在程序中，尤其是复杂的程序中，适当地加入注释可以增加程序的可读性，有利于程序的修改、调试和交流。注释的内容在程序编译的时候会被忽视，不会产生目标代码，注释的部分不会对程序的执行结果产生任何影响。</p><p>注意事项：多行和文档注释都不能嵌套使用。</p><h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><h4 id="访问修饰符-public-private-protected-以及不写（默认）时的区别"><a href="#访问修饰符-public-private-protected-以及不写（默认）时的区别" class="headerlink" title="访问修饰符 public,private,protected,以及不写（默认）时的区别"></a>访问修饰符 public,private,protected,以及不写（默认）时的区别</h4><p><strong>定义：</strong> Java中，可以使用访问修饰符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</p><p><strong>分类</strong>：</p><ul><li>private : 在同一类内可见。使用对象：变量、方法。注意：不能修饰类（外部类）</li><li>default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li><li>protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。注意：不能修饰类（外部类）。</li><li>public : 对所有类可见。使用对象：类、接口、变量、方法</li></ul><p><strong>访问修饰符图</strong>：<br><img src="/2020/01/13/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%9B%BE.jpg" alt=" "></p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp;和&amp;&amp;的区别"></a>&amp;和&amp;&amp;的区别</h4><p>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。</p><p>&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。&amp;&amp;之所以称为短路运算，是因为如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。</p><p>注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="Java-有没有-goto"><a href="#Java-有没有-goto" class="headerlink" title="Java 有没有 goto"></a>Java 有没有 goto</h4><p>goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。</p><h4 id="final-有什么用"><a href="#final-有什么用" class="headerlink" title="final 有什么用"></a>final 有什么用</h4><p>用于修饰类、属性和方法:</p><ul><li>被final修饰的类不可以被继承</li><li>被final修饰的方法不可以被重写</li><li>被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的</li></ul><h4 id="final-finally-finalize区别"><a href="#final-finally-finalize区别" class="headerlink" title="final finally finalize区别"></a>final finally finalize区别</h4><ul><li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。</li><li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li><li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的<br>最后判断。</li></ul><h4 id="this关键字的用法"><a href="#this关键字的用法" class="headerlink" title="this关键字的用法"></a>this关键字的用法</h4><p>this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。</p><p>this的用法在java中大体可以分为3种：</p><ul><li><p>1.普通的直接引用，this相当于是指向当前对象本身。</p></li><li><p>2.形参与成员名字重名，用this来区分：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3.引用本类的构造函数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="super关键字的用法"><a href="#super关键字的用法" class="headerlink" title="super关键字的用法"></a>super关键字的用法</h4><p>super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。</p><p>super也有三种用法：</p><ul><li>1.普通的直接引用</li></ul><p>与this类似，super相当于是指向当前对象的父类的引用，这样就可以用super.xxx来引用父类的成员。</p><ul><li>2.子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, String name1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.name = name1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name); <span class="comment">//Child</span></span><br><span class="line">        System.out.println(<span class="keyword">super</span>.name); <span class="comment">//Father</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       Student s1 = <span class="keyword">new</span> Student(<span class="string">"Father"</span>,<span class="string">"Child"</span>);</span><br><span class="line">       s1.getInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3、引用父类构造函数</li></ul><p>super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。<br>this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</p><h4 id="this与super的区别"><a href="#this与super的区别" class="headerlink" title="this与super的区别"></a>this与super的区别</h4><p><strong>super:</strong>　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参）<br><strong>this：</strong> 它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）<br>super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。<br>super()和this()均需放在构造方法内第一行。<br>尽管可以用this调用一个构造器，但却不能调用两个。<br>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。<br>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。<br>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。</p><h4 id="static存在的主要意义"><a href="#static存在的主要意义" class="headerlink" title="static存在的主要意义"></a>static存在的主要意义</h4><p>static的主要意义是在于创建独立于具体对象的域变量或者方法。<strong>以致于即使没有创建对象，也能使用属性和调用方法！</strong></p><p>static关键字还有一个比较关键的作用就是 用来<strong>形成静态代码块以优化程序性能</strong>。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。</p><p>为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</p><h4 id="static的独特之处"><a href="#static的独特之处" class="headerlink" title="static的独特之处"></a>static的独特之处</h4><p>1、被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法<strong>不属于任何一个实例对象，而是被类的实例对象所共享。</strong></p><blockquote><p>怎么理解 “被类的实例对象所共享” 这句话呢？就是说，一个类的静态成员，它是属于大伙的【大伙指的是这个类的多个对象实例，我们都知道一个类可以创建多个实例！】，所有的类对象共享的，不像成员变量是自个的【自个指的是这个类的单个实例对象】</p></blockquote><p>2、在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在类第一次使用时加载并进行初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。</p><p>3、static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！</p><p>4、被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。</p><h4 id="static应用场景"><a href="#static应用场景" class="headerlink" title="static应用场景"></a>static应用场景</h4><p>因为static是被类的实例对象所共享，因此如果<strong>某个成员变量是被所有对象所共享的，那么这个成员变量就应该定义为静态变量。</strong></p><p>因此比较常见的static应用场景有：</p><ul><li>1、修饰成员变量</li><li>2、修饰成员方法</li><li>3、静态代码块</li><li>4、修饰类【只能修饰内部类也就是静态内部类】</li><li>5、静态导包</li></ul><h4 id="static注意事项"><a href="#static注意事项" class="headerlink" title="static注意事项"></a>static注意事项</h4><ul><li>1、静态只能访问静态。</li><li>2、非静态既可以访问非静态的，也可以访问静态的。</li></ul><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><h4 id="break-continue-return-的区别及作用"><a href="#break-continue-return-的区别及作用" class="headerlink" title="break ,continue ,return 的区别及作用"></a>break ,continue ,return 的区别及作用</h4><p>break 跳出总上一层循环，不再执行循环(结束当前的循环体)</p><p>continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)</p><p>return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)</p><h4 id="在-Java-中，如何跳出当前的多重嵌套循环"><a href="#在-Java-中，如何跳出当前的多重嵌套循环" class="headerlink" title="在 Java 中，如何跳出当前的多重嵌套循环"></a>在 Java 中，如何跳出当前的多重嵌套循环</h4><p>在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ok:</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"i="</span> + i + <span class="string">",j="</span> + j);</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span> ok;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="面向对象概述"><a href="#面向对象概述" class="headerlink" title="面向对象概述"></a>面向对象概述</h3><h4 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h4><p><strong>面向过程：</strong></p><p>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</p><p>缺点：没有面向对象易维护、易复用、易扩展</p><p><strong>面向对象：</strong></p><p>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</p><p>缺点：性能比面向过程低</p><p>面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。</p><p>面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。</p><p>面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了。</p><h3 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h3><h4 id="面向对象的特征有哪些方面"><a href="#面向对象的特征有哪些方面" class="headerlink" title="面向对象的特征有哪些方面"></a>面向对象的特征有哪些方面</h4><p><strong>抽象：</strong> 抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p><p><strong>封装：</strong> 封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p><p><strong>继承：</strong> 继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p><p>关于继承如下 3 点请记住：</p><ul><li>子类拥有父类非 private 的属性和方法。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li></ul><p><strong>多态：</strong> 所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p><strong>多态性：</strong> 父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。</p><p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p><p>方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。</p><p>一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：</p><ul><li>方法重写（子类继承父类并重写父类中已有的或抽象的方法）；</li><li>对象造型（用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</li></ul><h4 id="什么是多态机制？Java语言是如何实现多态的"><a href="#什么是多态机制？Java语言是如何实现多态的" class="headerlink" title="什么是多态机制？Java语言是如何实现多态的"></a>什么是多态机制？Java语言是如何实现多态的</h4><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p><p>多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。</p><p><strong>多态的实现：</strong></p><p>Java实现多态有三个必要条件：继承、重写、向上转型。</p><p><strong>继承：</strong>在多态中必须存在有继承关系的子类和父类。</p><p><strong>重写：</strong>子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</p><p><strong>向上转型：</strong>在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</p><p>只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。</p><p>对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。</p><h4 id="面向对象五大基本原则是什么（可选）"><a href="#面向对象五大基本原则是什么（可选）" class="headerlink" title="面向对象五大基本原则是什么（可选）"></a>面向对象五大基本原则是什么（可选）</h4><ul><li>单一职责原则SRP(Single Responsibility Principle)<br>类的功能要单一，不能包罗万象，跟杂货铺似的。</li><li>开放封闭原则OCP(Open－Close Principle)<br>一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。</li><li>里式替换原则LSP(the Liskov Substitution Principle LSP)<br>子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~</li><li>依赖倒置原则DIP(the Dependency Inversion Principle DIP)<br>高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。</li><li>接口分离原则ISP(the Interface Segregation Principle ISP)<br>设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。</li></ul><h3 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h3><h4 id="抽象类和接口的对比"><a href="#抽象类和接口的对比" class="headerlink" title="抽象类和接口的对比"></a>抽象类和接口的对比</h4><p>抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。</p><p>从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</p><p><strong>相同点：</strong></p><ul><li>接口和抽象类都不能实例化</li><li>都位于继承的顶端，用于被其他实现或继承</li><li>都包含抽象方法，其子类都必须覆写这些抽象方法</li></ul><p><strong>不同点:</strong></p><table><thead><tr><th align="center">参数</th><th align="center">抽象类</th><th align="center">接口</th></tr></thead><tbody><tr><td align="center">声明</td><td align="center">抽象类使用abstract关键字声明</td><td align="center">接口使用interface关键字声明</td></tr><tr><td align="center">实现</td><td align="center">子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现</td><td align="center">子类使用implements关键字来实现接口。它需要提供接口中所有声明的方法的实现</td></tr><tr><td align="center">构造器</td><td align="center">抽象类可以有构造器</td><td align="center">接口不能有构造器</td></tr><tr><td align="center">访问修饰符</td><td align="center">抽象类中的方法可以是任意访问修饰符</td><td align="center">接口方法默认修饰符是public。并且不允许定义为 private 或者 protected</td></tr><tr><td align="center">多继承</td><td align="center">一个类最多只能继承一个抽象类</td><td align="center">一个类可以实现多个接口</td></tr><tr><td align="center">字段声明</td><td align="center">抽象类的字段声明可以是任意的</td><td align="center">接口的字段默认都是 static 和 final 的</td></tr></tbody></table><p><strong>备注：</strong> Java8中接口中引入默认方法和静态方法，以此来减少抽象类和接口之间的差异。</p><p>现在，我们可以为接口提供默认实现的方法了，并且不用强制子类来实现它。</p><p>接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则：</p><ul><li>行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。</li><li>选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。</li></ul><h4 id="普通类和抽象类有哪些区别"><a href="#普通类和抽象类有哪些区别" class="headerlink" title="普通类和抽象类有哪些区别"></a>普通类和抽象类有哪些区别</h4><ul><li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li><li>抽象类不能直接实例化，普通类可以直接实例化。</li></ul><h4 id="抽象类能使用-final-修饰吗"><a href="#抽象类能使用-final-修饰吗" class="headerlink" title="抽象类能使用 final 修饰吗"></a>抽象类能使用 final 修饰吗</h4><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类</p><h4 id="创建一个对象用什么关键字？对象实例与对象引用有何不同"><a href="#创建一个对象用什么关键字？对象实例与对象引用有何不同" class="headerlink" title="创建一个对象用什么关键字？对象实例与对象引用有何不同"></a>创建一个对象用什么关键字？对象实例与对象引用有何不同</h4><p>new关键字，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）</p><h3 id="变量与方法"><a href="#变量与方法" class="headerlink" title="变量与方法"></a>变量与方法</h3><h4 id="成员变量与局部变量的区别有哪些"><a href="#成员变量与局部变量的区别有哪些" class="headerlink" title="成员变量与局部变量的区别有哪些"></a>成员变量与局部变量的区别有哪些</h4><p>变量：在程序执行的过程中，在某个范围内其值可以发生改变的量。从本质上讲，变量其实是内存中的一小块区域</p><p>成员变量：方法外部，类内部定义的变量</p><p>局部变量：类的方法中的变量。</p><p>成员变量和局部变量的区别</p><p><strong>作用域:</strong></p><p>成员变量：针对整个类有效。<br>局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)</p><p><strong>存储位置:</strong></p><p>成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。<br>局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。当方法调用完，或者语句结束后，就自动释放。</p><p><strong>生命周期:</strong></p><p>成员变量：随着对象的创建而存在，随着对象的消失而消失<br>局部变量：当方法调用完，或者语句结束后，就自动释放。</p><p><strong>初始值:</strong></p><p>成员变量：有默认初始值。</p><p>局部变量：没有默认初始值，使用前必须赋值。</p><p><strong>使用原则:</strong></p><p>在使用变量时需要遵循的原则为：就近原则<br>首先在局部范围找，有就使用；接着在成员位置找。</p><h4 id="在Java中定义一个不做事且没有参数的构造方法的作用"><a href="#在Java中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="在Java中定义一个不做事且没有参数的构造方法的作用"></a>在Java中定义一个不做事且没有参数的构造方法的作用</h4><p>Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p><h4 id="在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是"><a href="#在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是" class="headerlink" title="在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是"></a>在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是</h4><p>帮助子类做初始化工作。</p><h4 id="一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么"><a href="#一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么" class="headerlink" title="一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么"></a>一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么</h4><p>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p><h4 id="构造方法有哪些特性"><a href="#构造方法有哪些特性" class="headerlink" title="构造方法有哪些特性"></a>构造方法有哪些特性</h4><p>名字与类名相同；</p><p>没有返回值，但不能用void声明构造函数；</p><p>生成类的对象时自动执行，无需调用。</p><h4 id="静态变量和实例变量区别"><a href="#静态变量和实例变量区别" class="headerlink" title="静态变量和实例变量区别"></a>静态变量和实例变量区别</h4><p>静态变量：静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间。</p><p>实例变量：每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。</p><h4 id="静态变量与普通变量区别"><a href="#静态变量与普通变量区别" class="headerlink" title="静态变量与普通变量区别"></a>静态变量与普通变量区别</h4><p>static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</p><p>还有一点就是static成员变量的初始化顺序按照定义的顺序进行初始化。</p><h4 id="静态方法和实例方法有何不同"><a href="#静态方法和实例方法有何不同" class="headerlink" title="静态方法和实例方法有何不同"></a>静态方法和实例方法有何不同</h4><p>静态方法和实例方法的区别主要体现在两个方面：</p><ul><li>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</li><li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制</li></ul><h4 id="在一个静态方法内调用一个非静态成员为什么是非法的"><a href="#在一个静态方法内调用一个非静态成员为什么是非法的" class="headerlink" title="在一个静态方法内调用一个非静态成员为什么是非法的"></a>在一个静态方法内调用一个非静态成员为什么是非法的</h4><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p><h4 id="什么是方法的返回值？返回值的作用是什么"><a href="#什么是方法的返回值？返回值的作用是什么" class="headerlink" title="什么是方法的返回值？返回值的作用是什么"></a>什么是方法的返回值？返回值的作用是什么</h4><p>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！</p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><h4 id="什么是内部类"><a href="#什么是内部类" class="headerlink" title="什么是内部类"></a>什么是内部类</h4><p>在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是内部类。内部类本身就是类的一个属性，与其他属性定义方式一致。</p><h4 id="内部类的分类有哪些"><a href="#内部类的分类有哪些" class="headerlink" title="内部类的分类有哪些"></a>内部类的分类有哪些</h4><p>内部类可以分为四种：成员内部类、局部内部类、匿名内部类和静态内部类。</p><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>定义在类内部的静态类，就是静态内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> radius = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"visit outer static variable:"</span> + radius);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；静态内部类的创建方式，new 外部类.静态内部类()，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Outer.StaticInner inner = <span class="keyword">new</span> Outer.StaticInner();</span><br><span class="line">inner.visit();</span><br></pre></td></tr></table></figure><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p>定义在类内部，成员位置上的非静态类，就是成员内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">int</span> radius = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count =<span class="number">2</span>;</span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"visit outer static variable:"</span> + radius);</span><br><span class="line">            System.out.println(<span class="string">"visit outer variable:"</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，它的创建方式外部类实例.new 内部类()，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">Outer.Inner inner = outer.<span class="keyword">new</span> Inner();</span><br><span class="line">inner.visit();</span><br></pre></td></tr></table></figure><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>定义在方法中的内部类，就是局部内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> out_a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> STATIC_b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFunctionClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> inner_c =<span class="number">3</span>;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(out_a);</span><br><span class="line">                System.out.println(STATIC_b);</span><br><span class="line">                System.out.println(inner_c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.fun();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStaticFunctionClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d =<span class="number">3</span>;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">// System.out.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量</span></span><br><span class="line">                System.out.println(STATIC_b);</span><br><span class="line">                System.out.println(d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应方法内，new 内部类()，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStaticFunctionClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Service() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"匿名内部类"</span> );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.method();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//匿名内部类必须继承或实现一个已有的接口</span></span><br><span class="line"> <span class="class"><span class="keyword">interface</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了没有名字，匿名内部类还有以下特点：</p><ul><li>匿名内部类必须继承一个抽象类或者实现一个接口。</li><li>匿名内部类不能定义任何静态成员和静态方法。</li><li>当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。</li><li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</li></ul><p><strong>匿名内部类创建方式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类/接口&#123;</span><br><span class="line">  <span class="comment">//匿名内部类实现部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内部类的优点"><a href="#内部类的优点" class="headerlink" title="内部类的优点"></a>内部类的优点</h4><ul><li>一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！</li><li>内部类不为同一包的其他类所见，具有很好的封装性；</li><li>内部类有效实现了“多重继承”，优化 java 单继承的缺陷。</li><li>匿名内部类可以很方便的定义回调</li></ul><h4 id="内部类有哪些应用场景"><a href="#内部类有哪些应用场景" class="headerlink" title="内部类有哪些应用场景"></a>内部类有哪些应用场景</h4><ul><li>一些多算法场合</li><li>解决一些非面向对象的语句块。</li><li>适当使用内部类，使得代码更加灵活和富有扩展性。</li><li>当某个类除了它的外部类，不再被其他的类使用时。</li></ul><h4 id="局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final"><a href="#局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final" class="headerlink" title="局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final"></a>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final</h4><p>先看这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">outMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> a =<span class="number">10</span>;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">innerMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上例子，为什么要加final呢？是因为生命周期不一致， 局部变量直接存储在栈中，当方法执行结束后，非final的局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。加了final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。</p><h4 id="内部类相关，看程序说出运行结果"><a href="#内部类相关，看程序说出运行结果" class="headerlink" title="内部类相关，看程序说出运行结果"></a>内部类相关，看程序说出运行结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">13</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> age = <span class="number">14</span>;</span><br><span class="line">            System.out.println(<span class="string">"局部变量："</span> + age);</span><br><span class="line">            System.out.println(<span class="string">"内部类变量："</span> + <span class="keyword">this</span>.age);</span><br><span class="line">            System.out.println(<span class="string">"外部类变量："</span> + Outer.<span class="keyword">this</span>.age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer.Inner in = <span class="keyword">new</span> Outer().<span class="keyword">new</span> Inner();</span><br><span class="line">        in.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">局部变量：<span class="number">14</span></span><br><span class="line">内部类变量：<span class="number">13</span></span><br><span class="line">外部类变量：<span class="number">12</span></span><br></pre></td></tr></table></figure><h3 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h3><h4 id="构造器（constructor）是否可被重写（override）"><a href="#构造器（constructor）是否可被重写（override）" class="headerlink" title="构造器（constructor）是否可被重写（override）"></a>构造器（constructor）是否可被重写（override）</h4><p>构造器不能被继承，因此不能被重写，但可以被重载。</p><h4 id="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分"><a href="#重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分" class="headerlink" title="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分"></a>重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分</h4><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p><p>重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分</p><p>重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写。</p><h3 id="对象相等判断"><a href="#对象相等判断" class="headerlink" title="对象相等判断"></a>对象相等判断</h3><h4 id="和-equals-的区别是什么"><a href="#和-equals-的区别是什么" class="headerlink" title="== 和 equals 的区别是什么"></a>== 和 equals 的区别是什么</h4><p>== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)</p><p>equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><p>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</p><p>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</p><p><strong>举个例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">"ab"</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">"ab"</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aa==bb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">"a==b"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aEQb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"true"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。</li><li>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</li></ul><h4 id="hashCode-与-equals-重要"><a href="#hashCode-与-equals-重要" class="headerlink" title="hashCode 与 equals (重要)"></a>hashCode 与 equals (重要)</h4><h5 id="hashCode-介绍"><a href="#hashCode-介绍" class="headerlink" title="hashCode()介绍"></a>hashCode()介绍</h5><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。</p><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><h5 id="为什么要有-hashCode"><a href="#为什么要有-hashCode" class="headerlink" title="为什么要有 hashCode"></a>为什么要有 hashCode</h5><p>我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</p><p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><h5 id="hashCode-与equals-的相关规定"><a href="#hashCode-与equals-的相关规定" class="headerlink" title="hashCode()与equals()的相关规定"></a>hashCode()与equals()的相关规定</h5><p>如果两个对象相等，则hashcode一定也是相同的</p><p>两个对象相等，对两个对象分别调用equals方法都返回true</p><p>两个对象有相同的hashcode值，它们也不一定是相等的</p><p>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</p><p>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p><h4 id="对象的相等与指向他们的引用相等，两者有什么不同"><a href="#对象的相等与指向他们的引用相等，两者有什么不同" class="headerlink" title="对象的相等与指向他们的引用相等，两者有什么不同"></a>对象的相等与指向他们的引用相等，两者有什么不同</h4><p>对象的相等 比的是内存中存放的内容是否相等而 引用相等 比较的是他们指向的内存地址是否相等。</p><h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><h4 id="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"></a>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递</h4><p>是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的</p><h4 id="为什么-Java-中只有值传递"><a href="#为什么-Java-中只有值传递" class="headerlink" title="为什么 Java 中只有值传递"></a>为什么 Java 中只有值传递</h4><p><strong>按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</strong> 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。</p><p><strong>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</strong></p><p><strong>下面通过 3 个例子说明:</strong></p><p>example 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    swap(num1, num2);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"num1 = "</span> + num1);</span><br><span class="line">    System.out.println(<span class="string">"num2 = "</span> + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"a = "</span> + a);</span><br><span class="line">    System.out.println(<span class="string">"b = "</span> + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">20</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line">num1 = <span class="number">10</span></span><br><span class="line">num2 = <span class="number">20</span></span><br></pre></td></tr></table></figure><p>在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p><p><strong>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.</strong></p><p>example 2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">        change(arr);</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将数组的第一个元素变为0</span></span><br><span class="line">        array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>解析：</strong></p><p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。因此，外部对引用对象的改变会反映到所对应的对象上。</p><p><strong>通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</strong></p><p><strong>很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</strong></p><p>example 3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="string">"小张"</span>);</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="string">"小李"</span>);</span><br><span class="line">        Test.swap(s1, s2);</span><br><span class="line">        System.out.println(<span class="string">"s1:"</span> + s1.getName());</span><br><span class="line">        System.out.println(<span class="string">"s2:"</span> + s2.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Student x, Student y)</span> </span>&#123;</span><br><span class="line">        Student temp = x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = temp;</span><br><span class="line">        System.out.println(<span class="string">"x:"</span> + x.getName());</span><br><span class="line">        System.out.println(<span class="string">"y:"</span> + y.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x:小李</span><br><span class="line">y:小张</span><br><span class="line">s1:小张</span><br><span class="line">s2:小李</span><br></pre></td></tr></table></figure><p><strong>解析：</strong></p><p>交换之前：</p><p><img src="/2020/01/13/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98/example3%E8%A7%A3%E6%9E%90.jpg" alt=" "></p><p>通过上图可以很清晰的看出： <strong>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</strong></p><p><strong>总结:</strong></p><p>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。</p><p>下面再总结一下Java中方法参数的使用情况：</p><ul><li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型》</li><li>一个方法可以改变一个对象参数的状态。</li><li>一个方法不能让对象参数引用一个新的对象。</li></ul><h4 id="值传递和引用传递有什么区别"><a href="#值传递和引用传递有什么区别" class="headerlink" title="值传递和引用传递有什么区别"></a>值传递和引用传递有什么区别</h4><p><strong>值传递：</strong> 指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。</p><p><strong>引用传递：</strong> 指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</p><h3 id="Java包"><a href="#Java包" class="headerlink" title="Java包"></a>Java包</h3><h4 id="JDK-中常用的包有哪些"><a href="#JDK-中常用的包有哪些" class="headerlink" title="JDK 中常用的包有哪些"></a>JDK 中常用的包有哪些</h4><ul><li>java.lang：这个是系统的基础类；</li><li>java.io：这里面是所有输入输出有关的类，比如文件操作等；</li><li>java.nio：为了完善 io 包中的功能，提高 io 包中性能而写的一个新包；</li><li>java.net：这里面是与网络有关的类；<br>java.util：这个是系统辅助类，特别是集合类；</li><li>java.sql：这个是数据库操作的类。</li></ul><h4 id="import-java和javax有什么区别"><a href="#import-java和javax有什么区别" class="headerlink" title="import java和javax有什么区别"></a>import java和javax有什么区别</h4><p>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来说使用。然而随着时间的推移，javax 逐渐的扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包将是太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准API的一部分。</p><p>所以，实际上java和javax没有区别。这都是一个名字。</p><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="java-中-IO-流分为几种"><a href="#java-中-IO-流分为几种" class="headerlink" title="java 中 IO 流分为几种"></a>java 中 IO 流分为几种</h3><ul><li>按照流的流向分，可以分为输入流和输出流；</li><li>按照操作单元划分，可以划分为字节流和字符流；</li><li>按照流的角色划分为节点流和处理流。</li></ul><p>Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。</p><ul><li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><p><strong>按操作方式分类结构图：</strong><br><img src="/2020/01/13/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98/IO%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB.jpg" alt=" "></p><p><strong>按操作对象分类结构图：</strong><br><img src="/2020/01/13/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98/IO%E6%93%8D%E4%BD%9C%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB.jpg" alt=" "></p><h3 id="BIO-NIO-AIO-有什么区别"><a href="#BIO-NIO-AIO-有什么区别" class="headerlink" title="BIO,NIO,AIO 有什么区别"></a>BIO,NIO,AIO 有什么区别</h3><p><strong>简答:</strong></p><ul><li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li><li>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li><li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li></ul><p><strong>详细回答:</strong></p><ul><li>BIO (Blocking I/O): 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li><li>NIO (New I/O): NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</li><li>AIO (Asynchronous I/O): AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</li></ul><h3 id="Files的常用方法都有哪些"><a href="#Files的常用方法都有哪些" class="headerlink" title="Files的常用方法都有哪些"></a>Files的常用方法都有哪些</h3><ul><li>Files. exists()：检测文件路径是否存在。</li><li>Files. createFile()：创建文件。</li><li>Files. createDirectory()：创建文件夹。</li><li>Files. delete()：删除一个文件或目录。</li><li>Files. copy()：复制文件。</li><li>Files. move()：移动文件。</li><li>Files. size()：查看文件个数。</li><li>Files. read()：读取文件。</li><li>Files. write()：写入文件。</li></ul><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="什么是反射机制"><a href="#什么是反射机制" class="headerlink" title="什么是反射机制"></a>什么是反射机制</h3><blockquote><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p></blockquote><p><strong>静态编译和动态编译:</strong></p><p><strong>静态编译：</strong> 在编译时确定类型，绑定对象</p><p><strong>动态编译：</strong> 运行时确定类型，绑定对象</p><h3 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="反射机制优缺点"></a>反射机制优缺点</h3><p><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</p><p><strong>缺点：</strong> 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。</p><h3 id="反射机制的应用场景有哪些"><a href="#反射机制的应用场景有哪些" class="headerlink" title="反射机制的应用场景有哪些"></a>反射机制的应用场景有哪些</h3><p>反射是框架设计的灵魂。</p><p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p><p>举例：</p><p>①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；</p><p>②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：</p><ul><li>1) 将程序内所有 XML 或 Properties 配置文件加载入内存中;</li><li>2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息;</li><li>3)使用反射机制，根据这个字符串获得某个类的Class实例;</li><li>4)动态配置实例的属性</li></ul><h3 id="Java获取反射的三种方法"><a href="#Java获取反射的三种方法" class="headerlink" title="Java获取反射的三种方法"></a>Java获取反射的三种方法</h3><ul><li>1.通过new对象实现反射机制</li><li>2.通过路径实现反射机制</li><li>3.通过类名实现反射机制</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> sex;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Get</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取反射机制三种方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//方式一(通过建立对象)</span></span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">        Class classobj1 = stu.getClass();</span><br><span class="line">        System.out.println(classobj1.getName());</span><br><span class="line">        <span class="comment">//方式二（所在通过路径-相对路径）</span></span><br><span class="line">        Class classobj2 = Class.forName(<span class="string">"fanshe.Student"</span>);</span><br><span class="line">        System.out.println(classobj2.getName());</span><br><span class="line">        <span class="comment">//方式三（通过类名）</span></span><br><span class="line">        Class classobj3 = Student<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        System.out.println(classobj3.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="String相关"><a href="#String相关" class="headerlink" title="String相关"></a>String相关</h3><h4 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别"></a>字符型常量和字符串常量的区别</h4><ul><li>形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符</li><li>含义上: 字符常量相当于一个整形值(ASCII值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置)</li><li>占内存大小: 字符常量只占一个字节 字符串常量占若干个字节(至少一个字符结束标志)</li></ul><h4 id="什么是字符串常量池"><a href="#什么是字符串常量池" class="headerlink" title="什么是字符串常量池"></a>什么是字符串常量池</h4><p>字符串常量池位于堆内存中，专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空间存储相同的字符串，在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。</p><h4 id="String-是最基本的数据类型吗"><a href="#String-是最基本的数据类型吗" class="headerlink" title="String 是最基本的数据类型吗"></a>String 是最基本的数据类型吗</h4><p>不是。Java 中的基本数据类型只有 8 个 ：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（referencetype），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。</p><p>这是很基础的东西，但是很多初学者却容易忽视，Java 的 8 种基本数据类型中不包括 String，基本数据类型中用来描述文本数据的是 char，但是它只能表示单个字符，比如 ‘a’,‘好’ 之类的，如果要描述一段文本，就需要用多个 char 类型的变量，也就是一个 char 类型数组，比如“你好” 就是长度为2的数组 char[] chars = {‘你’,‘好’};</p><p>但是使用数组过于麻烦，所以就有了 String，String 底层就是一个 char 类型的数组，只是使用的时候开发者不需要直接操作底层数组，用更加简便的方式即可完成对字符串的使用。</p><h4 id="String有哪些特性"><a href="#String有哪些特性" class="headerlink" title="String有哪些特性"></a>String有哪些特性</h4><ul><li>不变性：String 是只读字符串，是一个典型的 immutable 对象，对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。不变模式的主要作用在于当一个对象需要被多线程共享并频繁访问时，可以保证数据的一致性。</li><li>常量池优化：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。</li><li>final：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。</li></ul><h4 id="String为什么是不可变的吗"><a href="#String为什么是不可变的吗" class="headerlink" title="String为什么是不可变的吗"></a>String为什么是不可变的吗</h4><p>简单来说就是String类利用了final修饰的char类型数组存储字符，源码如下图所以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure><h4 id="String真的是不可变的吗"><a href="#String真的是不可变的吗" class="headerlink" title="String真的是不可变的吗"></a>String真的是不可变的吗</h4><p><strong>1) String不可变但不代表引用不可以变:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"Hello"</span>;</span><br><span class="line">str = str + <span class="string">" World"</span>;</span><br><span class="line">System.out.println(<span class="string">"str="</span> + str);</span><br><span class="line">结果：</span><br><span class="line">str=Hello World</span><br></pre></td></tr></table></figure><p>解析：</p><p>实际上，原来String的内容是不变的，只是str由原来指向”Hello”的内存地址转为指向”Hello World”的内存地址而已，也就是说多开辟了一块内存区域给”Hello World”字符串。</p><p><strong>2) 通过反射是可以修改所谓的“不可变”对象:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建字符串"Hello World"， 并赋给引用s</span></span><br><span class="line">String s = <span class="string">"Hello World"</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s); <span class="comment">// Hello World</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取String类中的value字段</span></span><br><span class="line">Field valueFieldOfString = String.class.getDeclaredField("value");</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变value属性的访问权限</span></span><br><span class="line">valueFieldOfString.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取s对象上的value属性的值</span></span><br><span class="line"><span class="keyword">char</span>[] value = (<span class="keyword">char</span>[]) valueFieldOfString.get(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变value所引用的数组中的第5个字符</span></span><br><span class="line">value[<span class="number">5</span>] = <span class="string">'_'</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s); <span class="comment">// Hello_World</span></span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line">s = Hello World</span><br><span class="line">s = Hello_World</span><br></pre></td></tr></table></figure><p>解析：</p><p>用反射可以访问私有成员， 然后反射出String对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。</p><h4 id="是否可以继承-String-类"><a href="#是否可以继承-String-类" class="headerlink" title="是否可以继承 String 类"></a>是否可以继承 String 类</h4><p>String 类是 final 类，不可以被继承。</p><h4 id="String-str-”i”与-String-str-new-String-“i”-一样吗"><a href="#String-str-”i”与-String-str-new-String-“i”-一样吗" class="headerlink" title="String str=”i”与 String str=new String(“i”)一样吗"></a>String str=”i”与 String str=new String(“i”)一样吗</h4><p>不一样，因为内存的分配方式不一样。String str=”i”的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</p><h4 id="String-s-new-String-“xyz”-创建了几个字符串对象"><a href="#String-s-new-String-“xyz”-创建了几个字符串对象" class="headerlink" title="String s = new String(“xyz”);创建了几个字符串对象"></a>String s = new String(“xyz”);创建了几个字符串对象</h4><p>两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"hello"</span>; <span class="comment">//str1指向静态区</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"hello"</span>); <span class="comment">//str2指向堆上的对象</span></span><br><span class="line">String str3 = <span class="string">"hello"</span>;</span><br><span class="line">String str4 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">System.out.println(str1.equals(str2)); <span class="comment">//true</span></span><br><span class="line">System.out.println(str2.equals(str4)); <span class="comment">//true</span></span><br><span class="line">System.out.println(str1 == str3); <span class="comment">//true</span></span><br><span class="line">System.out.println(str1 == str2); <span class="comment">//false</span></span><br><span class="line">System.out.println(str2 == str4); <span class="comment">//false</span></span><br><span class="line">System.out.println(str2 == <span class="string">"hello"</span>); <span class="comment">//false</span></span><br><span class="line">str2 = str1;</span><br><span class="line">System.out.println(str2 == <span class="string">"hello"</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="如何将字符串反转"><a href="#如何将字符串反转" class="headerlink" title="如何将字符串反转"></a>如何将字符串反转</h4><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">stringBuffer. append(<span class="string">"abcdefg"</span>);</span><br><span class="line">System. out. println(stringBuffer. reverse()); <span class="comment">// gfedcba</span></span><br><span class="line"><span class="comment">// StringBuilder reverse</span></span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">stringBuilder. append(<span class="string">"abcdefg"</span>);</span><br><span class="line">System. out. println(stringBuilder. reverse()); <span class="comment">// gfedcba</span></span><br></pre></td></tr></table></figure><h4 id="数组有没有-length-方法？String-有没有-length-方法"><a href="#数组有没有-length-方法？String-有没有-length-方法" class="headerlink" title="数组有没有 length()方法？String 有没有 length()方法"></a>数组有没有 length()方法？String 有没有 length()方法</h4><p>数组没有 length()方法 ，有 length 的属性。String 有 length()方法。JavaScript中，获得字符串的长度是通过 length 属性得到的，这一点容易和 Java 混淆。</p><h4 id="String-类的常用方法都有那些"><a href="#String-类的常用方法都有那些" class="headerlink" title="String 类的常用方法都有那些"></a>String 类的常用方法都有那些</h4><ul><li>indexOf()：返回指定字符的索引。</li><li>charAt()：返回指定索引处的字符。</li><li>replace()：字符串替换。</li><li>trim()：去除字符串两端空白。</li><li>split()：分割字符串，返回一个分割后的字符串数组。</li><li>getBytes()：返回字符串的 byte 类型数组。</li><li>length()：返回字符串长度。</li><li>toLowerCase()：将字符串转成小写字母。</li><li>toUpperCase()：将字符串转成大写字符。</li><li>substring()：截取字符串。</li><li>equals()：字符串比较。</li></ul><h4 id="在使用-HashMap-的时候，用-String-做-key-有什么好处"><a href="#在使用-HashMap-的时候，用-String-做-key-有什么好处" class="headerlink" title="在使用 HashMap 的时候，用 String 做 key 有什么好处"></a>在使用 HashMap 的时候，用 String 做 key 有什么好处</h4><p>HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。</p><h4 id="String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的"><a href="#String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的" class="headerlink" title="String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的"></a>String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的</h4><p><strong>可变性:</strong></p><p>String类中使用字符数组保存字符串，private　final　char　value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的。</p><p><strong>线程安全性:</strong></p><p>String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</p><p><strong>性能:</strong></p><p>每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><p><strong>对于三者使用的总结:</strong></p><p>如果要操作少量的数据用 = String</p><p>单线程操作字符串缓冲区 下操作大量数据 = StringBuilder</p><p>多线程操作字符串缓冲区 下操作大量数据 = StringBuffer</p><h3 id="Date相关"><a href="#Date相关" class="headerlink" title="Date相关"></a>Date相关</h3><h3 id="包装类相关"><a href="#包装类相关" class="headerlink" title="包装类相关"></a>包装类相关</h3><h4 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h4><p><strong>装箱：</strong> 将基本类型用它们对应的引用类型包装起来；</p><p><strong>拆箱：</strong> 将包装类型转换为基本数据类型；</p><h4 id="int-和-Integer-有什么区别"><a href="#int-和-Integer-有什么区别" class="headerlink" title="int 和 Integer 有什么区别"></a>int 和 Integer 有什么区别</h4><p>Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱/拆箱机制，使得二者可以相互转换。</p><h4 id="Java-为每个原始类型提供了包装类型"><a href="#Java-为每个原始类型提供了包装类型" class="headerlink" title="Java 为每个原始类型提供了包装类型"></a>Java 为每个原始类型提供了包装类型</h4><p><strong>原始类型:</strong> boolean，char，byte，short，int，long，float，double</p><p><strong>包装类型:</strong> Boolean，Character，Byte，Short，Integer，Long，Float，Double</p><h4 id="Integer-a-127-与-Integer-b-127相等吗"><a href="#Integer-a-127-与-Integer-b-127相等吗" class="headerlink" title="Integer a= 127 与 Integer b = 127相等吗"></a>Integer a= 127 与 Integer b = 127相等吗</h4><p>对于对象引用类型：==比较的是对象的内存地址。<br>对于基本数据类型：==比较的是值。</p><p>如果整型字面量的值在-128到127之间，那么自动装箱时不会new新的Integer对象，而是直接引用常量池中的Integer对象，超过范围 a1==b1的结果是false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer a = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">    Integer b = <span class="number">3</span>; <span class="comment">// 将3自动装箱成Integer类型</span></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">    System.out.println(a == b); <span class="comment">// false 两个引用没有引用同一对象</span></span><br><span class="line">    System.out.println(a == c); <span class="comment">// true a自动拆箱成int类型再和c比较</span></span><br><span class="line">    System.out.println(b == c); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    Integer a1 = <span class="number">128</span>;</span><br><span class="line">    Integer b1 = <span class="number">128</span>;</span><br><span class="line">    System.out.println(a1 == b1); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    Integer a2 = <span class="number">127</span>;</span><br><span class="line">    Integer b2 = <span class="number">127</span>;</span><br><span class="line">    System.out.println(a2 == b2); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的几种排序你学会了吗？</title>
      <link href="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/"/>
      <url>/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><h3 id="1-1-排序"><a href="#1-1-排序" class="headerlink" title="1.1 排序"></a>1.1 排序</h3><p>&emsp;排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。<br>平时的上下文中，如果提到排序，通常指的是排升序（非降序）。<br>通常意义上的排序，都是指的原地排序(in place sort)。</p><h3 id="1-2-稳定性（重要）"><a href="#1-2-稳定性（重要）" class="headerlink" title="1.2 稳定性（重要）"></a>1.2 稳定性（重要）</h3><p>&emsp;两个相等的数据，如果经过排序后，排序算法能保证其相对位置不发生变化，则我们称该算法是具备稳定性的排序算法。</p><p><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/Sort.png" alt=" "></p><h3 id="1-3-应用"><a href="#1-3-应用" class="headerlink" title="1.3 应用"></a>1.3 应用</h3><ol><li>各大商城的价格从低到高等<br><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E6%B7%98%E5%AE%9D%E6%8E%92%E5%BA%8F.png" alt=" "></li><li>中国大学排名<br><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6.png" alt=" "></li></ol><h2 id="2-七大基于比较的排序"><a href="#2-七大基于比较的排序" class="headerlink" title="2.七大基于比较的排序"></a>2.七大基于比较的排序</h2><p><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E4%B8%83%E5%A4%A7%E6%8E%92%E5%BA%8F.png" alt=" "></p><p><a href="https://www.bilibili.com/video/av17449274" target="_blank" rel="noopener">排序舞蹈</a></p><h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h2><h3 id="3-1-直接插入排序-原理"><a href="#3-1-直接插入排序-原理" class="headerlink" title="3.1 直接插入排序-原理"></a>3.1 直接插入排序-原理</h3><p>整个区间被分为</p><ul><li><ol><li>有序区间</li></ol></li><li><ol start="2"><li>无序区间</li></ol></li></ul><p>每次选择无序区间的第一个元素，在有序区间内选择合适的位置插入<br><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.png" alt=" "></p><h3 id="3-2-实现"><a href="#3-2-实现" class="headerlink" title="3.2 实现"></a>3.2 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 有序区间: [0, i)</span></span><br><span class="line">        <span class="comment">// 无序区间: [i, array.length)</span></span><br><span class="line">        <span class="keyword">int</span> v = array[i]; <span class="comment">// 无序区间的第一个数</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 不写 array[j] == v 是保证排序的稳定性</span></span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; v; j--) &#123;</span><br><span class="line">            array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">       &#125;</span><br><span class="line">        array[j + <span class="number">1</span>] = v;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-性能分析"><a href="#3-3-性能分析" class="headerlink" title="3.3 性能分析"></a>3.3 性能分析</h3><p>时间复杂度</p><table><thead><tr><th align="center">最好</th><th align="center">平均</th><th align="center">最坏</th></tr></thead><tbody><tr><td align="center">O(n)</td><td align="center">O(n^2)</td><td align="center">O(n^2)</td></tr><tr><td align="center">数据有序</td><td align="center"></td><td align="center">数据逆序</td></tr></tbody></table><table><thead><tr><th align="center">空间复杂度</th><th align="center">O(1)</th></tr></thead></table><h3 id="3-4-折半插入排序"><a href="#3-4-折半插入排序" class="headerlink" title="3.4 折半插入排序"></a>3.4 折半插入排序</h3><p>在有序区间选择数据应该插入的位置时，因为区间的有序性，可以利用折半查找的思想。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bsInsertSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = array[i];</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = i;</span><br><span class="line">        <span class="comment">// [left, right)</span></span><br><span class="line">        <span class="comment">// 需要考虑稳定性</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (v &gt;= array[m]) &#123;</span><br><span class="line">                left = m + <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = m;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="comment">// 搬移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; left; j--) &#123;</span><br><span class="line">            array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">       &#125;</span><br><span class="line">         array[left] = v;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h2><h3 id="4-1-原理"><a href="#4-1-原理" class="headerlink" title="4.1 原理"></a>4.1 原理</h3><p>&emsp;希尔排序法又称缩小增量法。希尔排序法的基本思想是：先选定一个整数，把待排序文件中所有记录分成个组，所有<br>距离为的记录分在同一组内，并对每一组内的记录进行排序。然后，取，重复上述分组和排序的工作。当到达=1时，<br>所有记录在统一组内排好序。</p><ul><li><ol><li>希尔排序是对直接插入排序的优化。</li></ol></li><li><ol start="2"><li>当gap &gt; 1时都是预排序，目的是让数组更接近于有序。当gap == 1时，数组已经接近有序的了，这样就会很快。这样整体而言，可以达到优化的效果。我们实现后可以进行性能测试的对比。<br><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.png" alt=" "><br><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.png" alt=" "></li></ol></li></ul><h3 id="4-2-实现"><a href="#4-2-实现" class="headerlink" title="4.2 实现"></a>4.2 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap = array.length;</span><br><span class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        insertSortGap(array, gap);</span><br><span class="line">        gap = (gap / <span class="number">3</span>) + <span class="number">1</span>; <span class="comment">// OR gap = gap / 2;</span></span><br><span class="line">   &#125;</span><br><span class="line">    insertSortGap(array, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSortGap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> gap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = array[i];</span><br><span class="line">        <span class="keyword">int</span> j = i - gap;</span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; v; j -= gap) &#123;</span><br><span class="line">            array[j + gap] = array[j];</span><br><span class="line">       &#125;</span><br><span class="line">        array[j + gap] = v;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-性能分析"><a href="#4-3-性能分析" class="headerlink" title="4.3 性能分析"></a>4.3 性能分析</h3><p>时间复杂度</p><table><thead><tr><th align="center">最好</th><th align="center">平均</th><th align="center">最坏</th></tr></thead><tbody><tr><td align="center">O(n)</td><td align="center">O(n^1.3)</td><td align="center">O(n^2)</td></tr><tr><td align="center">数据有序</td><td align="center"></td><td align="center">比较难构造</td></tr></tbody></table><table><thead><tr><th align="center">空间复杂度</th><th align="center">O(1)</th></tr></thead></table><p>稳定性：不稳定</p><h2 id="5-选择排序"><a href="#5-选择排序" class="headerlink" title="5. 选择排序"></a>5. 选择排序</h2><h3 id="5-1-直接选择排序-原理"><a href="#5-1-直接选择排序-原理" class="headerlink" title="5.1 直接选择排序-原理"></a>5.1 直接选择排序-原理</h3><p>每一次从无序区间选出最大（或最小）的一个元素，存放在无序区间的最后（或最前），直到全部待排序的数据元素排完 。<br><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.png" alt=" "></p><h3 id="5-2-实现"><a href="#5-2-实现" class="headerlink" title="5.2 实现"></a>5.2 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 无序区间: [0, array.length - i)</span></span><br><span class="line">        <span class="comment">// 有序区间: [array.length - i, array.length)</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; array.length - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[max]) &#123;</span><br><span class="line">                max = j;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">int</span> t = array[max];</span><br><span class="line">        array[max] = array[array.length - i - <span class="number">1</span>];</span><br><span class="line">        array[array.length - i - <span class="number">1</span>] = t;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-性能分析"><a href="#5-3-性能分析" class="headerlink" title="5.3 性能分析"></a>5.3 性能分析</h3><table><thead><tr><th align="center">时间复杂度</th><th align="center">空间复杂度</th></tr></thead><tbody><tr><td align="center">O(n^2)</td><td align="center">O(1)</td></tr><tr><td align="center">数据不敏感</td><td align="center">数据不敏感</td></tr></tbody></table><p>稳定性：不稳定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123; <span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>a, <span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>b &#125;;</span><br><span class="line"><span class="comment">// 交换中该情况无法识别，保证 5a 还在 5b 前边</span></span><br></pre></td></tr></table></figure><h3 id="5-4-双向选择排序"><a href="#5-4-双向选择排序" class="headerlink" title="5.4 双向选择排序"></a>5.4 双向选择排序</h3><p>每一次从无序区间选出最小 + 最大的元素，存放在无序区间的最前和最后，直到全部待排序的数据元素排完。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSortOP</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// [low, high] 表示整个无序区间</span></span><br><span class="line">    <span class="comment">// 无序区间内只有一个数也可以停止排序了</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = low;</span><br><span class="line">        <span class="keyword">int</span> max = low;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = low + <span class="number">1</span>; i &lt;= max; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt; array[min]) &#123;</span><br><span class="line">                min = i;</span><br><span class="line">           &#125;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &gt; array[max]) &#123;</span><br><span class="line">                max = i;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        swap(array, min, low);</span><br><span class="line">        <span class="comment">// 见下面例子讲解</span></span><br><span class="line">        <span class="keyword">if</span> (max == low) &#123;</span><br><span class="line">            max = min;</span><br><span class="line">       &#125;</span><br><span class="line">        swap(array, max, high);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = t; &#125;</span><br><span class="line">array = &#123; <span class="number">9</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span> &#125;; <span class="comment">// 交换之前</span></span><br><span class="line"><span class="comment">// low = 0; high = 6</span></span><br><span class="line"><span class="comment">// max = 0; min = 2</span></span><br><span class="line">array = &#123; <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span> &#125;; <span class="comment">// 将最小的交换到无序区间的最开始后</span></span><br><span class="line"><span class="comment">// max = 0，但实际上最大的数已经不在 0 位置，而是被交换到 min 即 2 位置了</span></span><br><span class="line"><span class="comment">// 所以需要让 max = min 即 max = 2</span></span><br><span class="line">array = &#123; <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span> &#125;; <span class="comment">// 将最大的交换到无序区间的最结尾后</span></span><br></pre></td></tr></table></figure><h2 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6. 堆排序"></a>6. 堆排序</h2><h3 id="6-1-原理"><a href="#6-1-原理" class="headerlink" title="6.1 原理"></a>6.1 原理</h3><p>基本原理也是选择排序，只是不在使用遍历的方式查找无序区间的最大的数，而是通过堆来选择无序区间的最大的<br>数。<br>注意： 排升序要建大堆；排降序要建小堆。</p><p><a href="https://www.cs.usfca.edu/~galles/visualization/HeapSort.html" target="_blank" rel="noopener">堆排序</a></p><p><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E5%A0%86%E6%8E%92%E5%BA%8F.png" alt=" "></p><h3 id="6-2-实现"><a href="#6-2-实现" class="headerlink" title="6.2 实现"></a>6.2 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    createHeap(array);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 交换前</span></span><br><span class="line">        <span class="comment">// 无序区间: [0, array.length - i)</span></span><br><span class="line">        <span class="comment">// 有序区间: [array.length - i, array.length)</span></span><br><span class="line">        swap(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 交换后</span></span><br><span class="line">        <span class="comment">// 无序区间: [0, array.length - i - 1)</span></span><br><span class="line">        <span class="comment">// 有序区间: [array.length - i - 1, array.length)</span></span><br><span class="line">        <span class="comment">// 无序区间长度: array.length - i - 1</span></span><br><span class="line">        shiftDown(array, array.length - i - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = t; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createHeap</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (array.length - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        shiftDown(array, array.length, i);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> size, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; size) &#123;</span><br><span class="line">        <span class="keyword">int</span> max = left;</span><br><span class="line">   <span class="keyword">int</span> right = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[right] &gt; array[left]) &#123;</span><br><span class="line">                max = right;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">if</span> (array[index] &gt;= array[max]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">int</span> t = array[index];</span><br><span class="line">        array[index] = array[max];</span><br><span class="line">        array[max] = t;</span><br><span class="line">        index = max;</span><br><span class="line">        left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-性能分析"><a href="#6-3-性能分析" class="headerlink" title="6.3 性能分析"></a>6.3 性能分析</h3><table><thead><tr><th align="center">时间复杂度</th><th align="center">空间复杂度</th></tr></thead><tbody><tr><td align="center">O(n * log(n))</td><td align="center">O(1)</td></tr><tr><td align="center">数据不敏感</td><td align="center">数据不敏感</td></tr></tbody></table><p>稳定性：不稳定</p><h2 id="7-冒泡排序"><a href="#7-冒泡排序" class="headerlink" title="7. 冒泡排序"></a>7. 冒泡排序</h2><h3 id="7-1-原理"><a href="#7-1-原理" class="headerlink" title="7.1 原理"></a>7.1 原理</h3><p>在无序区间，通过相邻数的比较，将最大的数冒泡到无序区间的最后，持续这个过程，直到数组整体有序<br><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.png" alt=" "></p><h3 id="7-2-实现"><a href="#7-2-实现" class="headerlink" title="7.2 实现"></a>7.2 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"> <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line"> <span class="comment">// 相等不交换，保证稳定性</span></span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(array, j, j + <span class="number">1</span>);</span><br><span class="line">                isSorted = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-性能分析"><a href="#7-3-性能分析" class="headerlink" title="7.3 性能分析"></a>7.3 性能分析</h3><p>时间复杂度<br>最好|平均|最坏<br>:-:|:-:|:-:<br>O(n)|O(n^2)|O(n^2)<br>数据有序| |数据逆序</p><table><thead><tr><th align="center">空间复杂度</th><th align="center">O(1)</th></tr></thead></table><p>稳定性：稳定</p><h2 id="8-快速排序"><a href="#8-快速排序" class="headerlink" title="8. 快速排序"></a>8. 快速排序</h2><h3 id="8-1-原理"><a href="#8-1-原理" class="headerlink" title="8.1 原理"></a>8.1 原理</h3><ul><li><ol><li>从待排序区间选择一个数，作为基准值(pivot)；</li></ol></li><li><ol start="2"><li>Partition: 遍历整个待排序区间，将比基准值小的（可以包含相等的）放到基准值的左边，将比基准值大的（可以包含相等的）放到基准值的右边；</li></ol></li><li><ol start="3"><li>采用分治思想，对左右两个小区间按照同样的方式处理，直到小区间的长度 == 1，代表已经有序，或者小区间的长度 == 0，代表没有数据。<br><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png" alt=" "></li></ol></li></ul><p><strong>实现:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line"> quickSortInternal(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [left, right] 为待排序区间</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortInternal</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 最简单的选择基准值的方式，选择 array[left] 作为基准值</span></span><br><span class="line"> <span class="comment">// pivotIndex 代表基准值最终停留的下标</span></span><br><span class="line"> <span class="keyword">int</span> pivotIndex = partition(array, left, right);</span><br><span class="line"> <span class="comment">// [left, pivotIndex - 1] 都是小于等于基准值的</span></span><br><span class="line"> <span class="comment">// [pivotIndex + 1, right] 都是大于等于基准值的</span></span><br><span class="line"> quickSortInternal(array, left, pivotIndex - <span class="number">1</span>);</span><br><span class="line"> quickSortInternal(array, pivotIndex + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-原理-partition"><a href="#8-2-原理-partition" class="headerlink" title="8.2 原理-partition"></a>8.2 原理-partition</h3><h4 id="Hoare-法"><a href="#Hoare-法" class="headerlink" title="Hoare 法"></a>Hoare 法</h4><p><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/Hoare.png" alt=" "><br><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/Hoare2.png" alt=" "></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> i = left;</span><br><span class="line"> <span class="keyword">int</span> j = right;</span><br><span class="line"> <span class="keyword">int</span> pivot = array[left];</span><br><span class="line"> <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"> <span class="keyword">while</span> (i &lt; j &amp;&amp; array[j] &gt;= pivot) &#123;</span><br><span class="line"> j--;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">while</span> (i &lt; j &amp;&amp; array[i] &lt;= pivot) &#123;</span><br><span class="line"> i++;</span><br><span class="line"> &#125;</span><br><span class="line"> swap(array, i, j);</span><br><span class="line"> &#125;</span><br><span class="line"> swap(array, i, left);</span><br><span class="line"> <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-性能分析"><a href="#8-3-性能分析" class="headerlink" title="8.3 性能分析"></a>8.3 性能分析</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><table><thead><tr><th align="center">最好</th><th align="center">平均</th><th align="center">最坏</th></tr></thead><tbody><tr><td align="center">O(n*log(n))</td><td align="center">O(n*log(n))</td><td align="center">O(n^2)</td></tr></tbody></table><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><table><thead><tr><th align="center">最好</th><th align="center">平均</th><th align="center">最坏</th></tr></thead><tbody><tr><td align="center">O(log(n))</td><td align="center">O(log(n))</td><td align="center">O(n)</td></tr></tbody></table><p>稳定性：不稳定</p><h3 id="8-4-原理-基准值的选择"><a href="#8-4-原理-基准值的选择" class="headerlink" title="8.4 原理-基准值的选择"></a>8.4 原理-基准值的选择</h3><ul><li><ol><li>选择边上（左或者右）</li></ol></li><li><ol start="2"><li>随机选择</li></ol></li><li><ol start="3"><li>几数取中（例如三数取中）：array[left], array[mid], array[right] 大小是中间的为基准值</li></ol></li></ul><h3 id="8-5-原理-非递归分治"><a href="#8-5-原理-非递归分治" class="headerlink" title="8.5 原理-非递归分治"></a>8.5 原理-非递归分治</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line"> Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"> stack.push(array.length - <span class="number">1</span>);</span><br><span class="line"> stack.push(<span class="number">0</span>);</span><br><span class="line"> <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line"> <span class="keyword">int</span> left = stack.pop();</span><br><span class="line"> <span class="keyword">int</span> right = stack.pop();</span><br><span class="line"> <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line"> <span class="keyword">continue</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">int</span> pivotIndex = partition(array, left, right);</span><br><span class="line"> stack.push(right);</span><br><span class="line"> stack.push(pivotIndex + <span class="number">1</span>);</span><br><span class="line"> stack.push(pivotIndex - <span class="number">1</span>);</span><br><span class="line"> stack.push(left);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-归并排序"><a href="#9-归并排序" class="headerlink" title="9. 归并排序"></a>9. 归并排序</h2><h3 id="9-1-原理"><a href="#9-1-原理" class="headerlink" title="9.1 原理"></a>9.1 原理</h3><p>&emsp;归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and<br>Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><p><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.png" alt=" "><br><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F2.png" alt=" "></p><h3 id="9-2-原理-合并两个有序数组"><a href="#9-2-原理-合并两个有序数组" class="headerlink" title="9.2 原理-合并两个有序数组"></a>9.2 原理-合并两个有序数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> i = low;</span><br><span class="line"> <span class="keyword">int</span> j = mid;</span><br><span class="line"> <span class="keyword">int</span> length = high - low;</span><br><span class="line"> <span class="keyword">int</span>[] extra = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"> <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"> <span class="comment">// 选择小的放入 extra</span></span><br><span class="line"> <span class="keyword">while</span> (i &lt; mid &amp;&amp; j &lt; high) &#123;</span><br><span class="line"> <span class="comment">// 加入等于，保证稳定性</span></span><br><span class="line"> <span class="keyword">if</span> (array[i] &lt;= array[j]) &#123;</span><br><span class="line"> extra[k++] = array[i++];</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> extra[k++] = array[j++];</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 将属于元素放入 extra</span></span><br><span class="line"> <span class="keyword">while</span> (i &lt; mid) &#123;</span><br><span class="line"> extra[k++] = array[i++];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> j &lt; right) &#123;</span><br><span class="line"> extra[k++] = array[j++];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 从 extra 搬移回 array</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; length; t++) &#123;</span><br><span class="line"> <span class="comment">// 需要搬移回原位置，从 low 开始</span></span><br><span class="line"> array[low + t] = extra[t];</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-实现"><a href="#9-3-实现" class="headerlink" title="9.3 实现"></a>9.3 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line"> mergeSortInternal(array, <span class="number">0</span>, array.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 待排序区间为 [low, high)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSortInternal</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (low - <span class="number">1</span> &gt;= high) &#123;</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"> mergeSortInternal(array, low, mid);</span><br><span class="line"> mergeSortInternal(array, mid, high);</span><br><span class="line"> merge(array, low, mid, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-4-性能分析"><a href="#9-4-性能分析" class="headerlink" title="9.4 性能分析"></a>9.4 性能分析</h3><table><thead><tr><th align="center">时间复杂度</th><th align="center">空间复杂度</th></tr></thead><tbody><tr><td align="center">O(n*log(n))</td><td align="center">O(n)</td></tr><tr><td align="center">数据不敏感</td><td align="center">数据不敏感</td></tr></tbody></table><p>稳定性：稳定</p><h3 id="9-5-优化总结"><a href="#9-5-优化总结" class="headerlink" title="9.5 优化总结"></a>9.5 优化总结</h3><p>在排序过程中重复利用两个数组，减少元素的复制过程</p><h3 id="9-6-非递归版本"><a href="#9-6-非递归版本" class="headerlink" title="9.6 非递归版本"></a>9.6 非递归版本</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i = i * <span class="number">2</span>) &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length; j = j + <span class="number">2</span> * i) &#123;</span><br><span class="line"> <span class="keyword">int</span> low = j;</span><br><span class="line"> <span class="keyword">int</span> mid = j + i;</span><br><span class="line"> <span class="keyword">if</span> (mid &gt;= array.length) &#123;</span><br><span class="line"> <span class="keyword">continue</span>;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">int</span> high = mid + i;</span><br><span class="line"> <span class="keyword">if</span> (high &gt; array.length) &#123;</span><br><span class="line"> high = array.length;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> merge(array, low, mid, high);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-7-海量数据的排序问题"><a href="#9-7-海量数据的排序问题" class="headerlink" title="9.7 海量数据的排序问题"></a>9.7 海量数据的排序问题</h3><p>外部排序：排序过程需要在磁盘等外部存储进行的排序<br>前提：内存只有 1G，需要排序的数据有 100G<br>因为内存中因为无法把所有数据全部放下，所以需要外部排序，而归并排序是最常用的外部排序</p><ul><li><ol><li>先把文件切分成 200 份，每个 512 M</li></ol></li><li><ol start="2"><li>分别对 512 M 排序，因为内存已经可以放的下，所以任意排序方式都可以</li></ol></li><li><ol start="3"><li>进行 200 路归并，同时对 200 份有序文件做归并过程，最终结果就有序了</li></ol></li></ul><h2 id="10-排序总结"><a href="#10-排序总结" class="headerlink" title="10.  排序总结"></a>10.  排序总结</h2><p><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93.png" alt=" "></p><p>排序方法|最好|平均|最坏|空间复杂度|稳定性<br>:-:|:-:|:-:|:-:|:-:|:-:|:-:<br>冒泡排序|O(n)|O(n^2)|O(n^2)|O(1)|稳定<br>插入排序|O(n)|O(n^2)|O(n^2)|O(1)|稳定<br>选择排序|O(n^2)|O(n^2)|O(n^2)|O(1)|不稳定<br>希尔排序|O(n)|O(n^1.3)|O(n^2)|O(1)|不稳定<br>堆排序|O(n<em>log(n))|O(n</em>log(n))|O(n<em>log(n))|O(1)|不稳定<br>快速排序|O(n</em>log(n))|O(n<em>log(n))|O(n^2)|O(log(n))~O(n)|不稳定<br>归并排序|O(n</em>log(n))|O(n<em>log(n))|O(n</em>log(n))|O(n)|稳定</p><h2 id="11-其他非基于比较的排序"><a href="#11-其他非基于比较的排序" class="headerlink" title="11. 其他非基于比较的排序"></a>11. 其他非基于比较的排序</h2><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a><a href="https://zhuanlan.zhihu.com/p/26595385?group_id=842495057868226560" target="_blank" rel="noopener">计数排序</a></h3><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a><a href="https://www.runoob.com/w3cnote/radix-sort.html" target="_blank" rel="noopener">基数排序</a></h3><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a><a href="https://www.cnblogs.com/bqwzx/p/11029264.html" target="_blank" rel="noopener">桶排序</a></h3>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SearchEngine</title>
      <link href="/2019/12/21/SearchEngine/"/>
      <url>/2019/12/21/SearchEngine/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> Http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap和TreeMap对比</title>
      <link href="/2019/12/04/HashMap%E5%92%8CTreeMap%E5%AF%B9%E6%AF%94/"/>
      <url>/2019/12/04/HashMap%E5%92%8CTreeMap%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap主要用来存放键值对，它基于哈希表的Map接口实现，是常用的Java集合之一，数据是无序的</p><p><img src="/2019/12/04/HashMap%E5%92%8CTreeMap%E5%AF%B9%E6%AF%94/HashMap%E5%AD%98%E6%94%BE.png" alt="HashMap存放"></p><p>jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p><p><img src="/2019/12/04/HashMap%E5%92%8CTreeMap%E5%AF%B9%E6%AF%94/jdk1.8%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81.png" alt="jdk1.8解决哈希冲突"></p><p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的.</p><p>HashMap的时间复杂度O(1),但是如果冲突较多，链表的时间复杂度是O(n)，所以在JDK1.8 以后，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间，红黑树的时间复杂度是O(log n)。 所以查询一个HashMap数据的时间为 O(1) + O(n)或O(1) + O(log n）平均为O(1)<br>总结：HashMap根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度，插入、删除和定位元素，HashMap是最好的选择。</p><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap是基于红黑树实现的一个保证有序性的Map 基于红黑树，所以TreeMap的时间复杂度是O(log n)，如果需要有排序的数据，直接存放进TreeMap中就行，TreeMap自己会给排序，不需要再写排序代码。</p><p>总结：TreeMap取出来的是排序后的键值对。插入、删除需要维护平衡会牺牲一些效率。但如果要按自然顺序或自定义顺序遍历，那么TreeMap会更好。</p><p>HashMap通过hashcode对其内容进行快速查找，而 TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap。HashMap通常比TreeMap效率要高一些，一个是哈希表，一个是二叉树，建议多使用HashMap，在需要排序的Map时候才用TreeMap。HashMap的查询速度比TreeMap要快</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> HashMap </tag>
            
            <tag> TreeMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合类：Set、List、Map使用场景</title>
      <link href="/2019/11/08/Java%E9%9B%86%E5%90%88%E7%B1%BB%EF%BC%9ASet%E3%80%81List%E3%80%81Map%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2019/11/08/Java%E9%9B%86%E5%90%88%E7%B1%BB%EF%BC%9ASet%E3%80%81List%E3%80%81Map%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-Java集合类基本概念"><a href="#1-Java集合类基本概念" class="headerlink" title="1. Java集合类基本概念"></a>1. Java集合类基本概念</h2><p>&emsp;在编程中，常常需要集中存放多个数据。从传统意义上讲，数组是我们的一个很好的选择，前提是我们事先已经明确知道我们将要保存的对象的数量。一旦在数组初始化时指定了这个数组长度，这个数组长度就是不可变的，如果我们需要保存一个可以动态增长的数据(在编译时无法确定具体的数量)，java的集合类就是一个很好的设计方案了。</p><p>&emsp;集合类主要负责保存、盛装其他数据，因此集合类也被称为容器类。所以的集合类都位于java.util包下，后来为了处理多线程环境下的并发安全问题，java5还在java.util.concurrent包下提供了一些多线程支持的集合类。</p><p>&emsp;在学习Java中的集合类的API、编程原理的时候，我们一定要明白，”集合”是一个很古老的数学概念，它远远早于Java的出现。从数学概念的角度来理解集合能帮助我们更好的理解编程中什么时候该使用什么类型的集合类。</p><p><img src="/2019/11/08/Java%E9%9B%86%E5%90%88%E7%B1%BB%EF%BC%9ASet%E3%80%81List%E3%80%81Map%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.jpg" alt="java集合框架"></p><p>Java容器类类库的用途是”保存对象”，并将其划分为两个不同的概念：</p><h3 id="1-Collection"><a href="#1-Collection" class="headerlink" title="1) Collection"></a>1) Collection</h3><p>一组”对立”的元素，通常这些元素都服从某种规则</p><ul><li><p>1.1) List必须保持元素特定的顺序</p></li><li><p>1.2) Set不能有重复元素</p></li><li><p>1.3) Queue保持一个队列(先进先出)的顺序</p></li></ul><h3 id="2-Map"><a href="#2-Map" class="headerlink" title="2) Map"></a>2) Map</h3><p>一组成对的”键值对”对象</p><p>Collection和Map的区别在于容器中每个位置保存的元素个数:</p><ul><li>1) Collection 每个位置只能保存一个元素(对象)</li><li>2) Map保存的是”键值对”，就像一个小型数据库。我们可以通过”键”找到该键对应的”值”</li></ul><h2 id="2-Java集合类架构层次关系"><a href="#2-Java集合类架构层次关系" class="headerlink" title="2. Java集合类架构层次关系"></a>2. Java集合类架构层次关系</h2><h3 id="1）Interface-Iterable"><a href="#1）Interface-Iterable" class="headerlink" title="1）Interface Iterable"></a>1）Interface Iterable</h3><blockquote><p>迭代器接口，这是Collection类的父接口。实现这个Iterable接口的对象允许使用foreach进行遍历，也就是说，所有的Collection集合对象都具有”foreach可遍历性”。这个Iterable接口只有一个方法: iterator()。它返回一个代表当前集合对象的泛型&lt; T &gt;迭代器，用于之后的遍历操作</p></blockquote><h4 id="1-1-Collection"><a href="#1-1-Collection" class="headerlink" title="1.1 Collection"></a>1.1 Collection</h4><blockquote><p>Collection是最基本的集合接口，一个Collection代表一组Object的集合，这些Object被称作Collection的元素。Collection是一个接口，用以提供规范定义，不能被实例化使用</p></blockquote><h5 id="1-Set"><a href="#1-Set" class="headerlink" title="1) Set"></a>1) Set</h5><blockquote><p>Set集合类似于一个罐子，”丢进”Set集合里的多个对象之间没有明显的顺序。Set继承自Collection接口，不能包含有重复元素(记住，这是整个Set类层次的共有属性)。</p></blockquote><p>Set判断两个对象相同不是使用”==”运算符，而是根据equals方法。也就是说，我们在加入一个新元素的时候，如果这个新元素对象和Set中已有对象进行注意equals比较都返回false，　　<br>则Set就会接受这个新元素对象，否则拒绝。</p><p>因为Set的这个制约，在使用Set集合的时候，应该注意两点：</p><ul><li><p>1) 为Set集合里的元素的实现类实现一个有效的equals(Object)方法</p></li><li><p>2) 对Set的构造函数，传入的Collection参数不能包<br>　　含重复的元素</p></li></ul><h6 id="1-1-HashSet"><a href="#1-1-HashSet" class="headerlink" title="1.1) HashSet"></a>1.1) HashSet</h6><blockquote><p>HashSet是Set接口的典型实现，HashSet使用HASH算法来存储集合中的元素，因此具有良好的存取和查找性能。当向HashSet集合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据该HashCode值决定该对象在HashSet中的存储位置。</p></blockquote><p>值得主要的是，HashSet集合判断两个元素相等的标准是两个对象通过equals()方法比较相等，并且两个对象的hashCode()方法的返回值相等</p><ul><li>1.1.1) LinkedHashSet</li></ul><blockquote><p>LinkedHashSet集合也是根据元素的hashCode值来决定元素的存储位置，但和HashSet不同的是，它同时使用链表维护元素的次序，这样使得元素看起来是以插入的顺序保存的。当遍历LinkedHashSet集合里的元素时,LinkedHashSet将会按元素的添加顺序来访问集合里的元素。</p></blockquote><p>LinkedHashSet需要维护元素的插入顺序，因此性能略低于HashSet的性能，但在迭代访问Set里的全部元素时(遍历)将有很好的性能(链表很适合进行遍历)</p><h6 id="1-2-SortedSet"><a href="#1-2-SortedSet" class="headerlink" title="1.2) SortedSet"></a>1.2) SortedSet</h6><blockquote><p>此接口主要用于排序操作，即实现此接口的子类都属于排序的子类</p></blockquote><ul><li>1.2.1) TreeSet</li></ul><blockquote><p>TreeSet是SortedSet接口的实现类，TreeSet可以确保集合元素处于排序状态</p></blockquote><h6 id="1-3-EnumSet"><a href="#1-3-EnumSet" class="headerlink" title="1.3) EnumSet"></a>1.3) EnumSet</h6><blockquote><p>EnumSet是一个专门为枚举类设计的集合类，EnumSet中所有元素都必须是指定枚举类型的枚举值，该枚举类型在创建EnumSet时显式、或隐式地指定。EnumSet的集合元素也是有序的，<br>它们以枚举值在Enum类内的定义顺序来决定集合元素的顺序</p></blockquote><h5 id="2-List"><a href="#2-List" class="headerlink" title="2) List"></a>2) List</h5><blockquote><p>List集合代表一个元素有序、可重复的集合，集合中每个元素都有其对应的顺序索引。List集合允许加入重复元素，因为它可以通过索引来访问指定位置的集合元素。List集合默认按元素的添加顺序设置元素的索引</p></blockquote><h6 id="2-1-ArrayList"><a href="#2-1-ArrayList" class="headerlink" title="2.1) ArrayList"></a>2.1) ArrayList</h6><blockquote><p>ArrayList是基于数组实现的List类，它封装了一个动态的增长的、允许再分配的Object[]数组。</p></blockquote><h6 id="2-2-Vector"><a href="#2-2-Vector" class="headerlink" title="2.2) Vector"></a>2.2) Vector</h6><blockquote><p>Vector和ArrayList在用法上几乎完全相同，但由于Vector是一个古老的集合，所以Vector提供了一些方法名很长的方法，但随着JDK1.2以后，java提供了系统的集合框架，就将<br>Vector改为实现List接口，统一归入集合框架体系中</p></blockquote><ul><li>2.2.1) Stack</li></ul><blockquote><p>Stack是Vector提供的一个子类，用于模拟”栈”这种数据结构(LIFO后进先出)</p></blockquote><h6 id="2-3-LinkedList"><a href="#2-3-LinkedList" class="headerlink" title="2.3) LinkedList"></a>2.3) LinkedList</h6><blockquote><p>implements List&lt; E &gt;, Deque&lt; E &gt;。实现List接口，能对它进行队列操作，即可以根据索引来随机访问集合中的元素。同时它还实现Deque接口，即能将LinkedList当作双端队列<br>使用。自然也可以被当作”栈来使用”</p></blockquote><h5 id="3-Queue"><a href="#3-Queue" class="headerlink" title="3) Queue"></a>3) Queue</h5><blockquote><p>Queue用于模拟”队列”这种数据结构(先进先出 FIFO)。队列的头部保存着队列中存放时间最长的元素，队列的尾部保存着队列中存放时间最短的元素。新元素插入(offer)到队列的尾部，访问元素(poll)操作会返回队列头部的元素，队列不允许随机访问队列中的元素。结合生活中常见的排队就会很好理解这个概念</p></blockquote><h6 id="3-1-PriorityQueue"><a href="#3-1-PriorityQueue" class="headerlink" title="3.1) PriorityQueue"></a>3.1) PriorityQueue</h6><blockquote><p>PriorityQueue并不是一个比较标准的队列实现，PriorityQueue保存队列元素的顺序并不是按照加入队列的顺序，而是按照队列元素的大小进行重新排序，这点从它的类名也可以看出来。</p></blockquote><h6 id="3-2-Deque"><a href="#3-2-Deque" class="headerlink" title="3.2) Deque"></a>3.2) Deque</h6><blockquote><p>Deque接口代表一个”双端队列”，双端队列可以同时从两端来添加、删除元素，因此Deque的实现类既可以当成队列使用、也可以当成栈使用</p></blockquote><ul><li>3.2.1) ArrayDeque</li></ul><blockquote><p>是一个基于数组的双端队列，和ArrayList类似，它们的底层都采用一个动态的、可重分配的Object[]数组来存储集合元素，当集合元素超出该数组的容量时，系统会在底层重新分配一个Object[]数组来存储集合元素</p></blockquote><ul><li>3.2.2) LinkedList</li></ul><blockquote><p>LinkedList基于链表的数据结构,地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址，对于新增和删除操作add和remove，LinedList比较占优势。</p></blockquote><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><blockquote><p>Map用于保存具有”映射关系”的数据，因此Map集合里保存着两组值，一组值用于保存Map里的key，另外一组值用于保存Map里的value。key和value都可以是任何引用类型的数据。Map的key不允许重复，即同一个Map对象的任何两个key通过equals方法比较结果总是返回false。关于Map，我们要从代码复用的角度去理解，java是先实现了Map，然后通过包装了一个所有value都为null的Map就实现了Set集合</p></blockquote><p>Map的这些实现类和子接口中key集的存储形式和Set集合完全相同(即key不能重复)</p><p>Map的这些实现类和子接口中value集的存储形式和List非常类似(即value可以重复、根据索引来查找)</p><h5 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1) HashMap"></a>1) HashMap</h5><blockquote><p>和HashSet集合不能保证元素的顺序一样，HashMap也不能保证key-value对的顺序。并且类似于HashSet判断两个key是否相等的标准也是: 两个key通过equals()方法比较返回true、<br>同时两个key的hashCode值也必须相等</p></blockquote><h6 id="1-1-LinkedHashMap"><a href="#1-1-LinkedHashMap" class="headerlink" title="1.1) LinkedHashMap"></a>1.1) LinkedHashMap</h6><blockquote><p>LinkedHashMap也使用双向链表来维护key-value对的次序，该链表负责维护Map的迭代顺序，与key-value对的插入顺序一致(注意和TreeMap对所有的key-value进行排序进行区<br>分)</p></blockquote><h5 id="2-Hashtable"><a href="#2-Hashtable" class="headerlink" title="2) Hashtable"></a>2) Hashtable</h5><blockquote><p>是一个古老的Map实现类</p></blockquote><h6 id="2-1-Properties"><a href="#2-1-Properties" class="headerlink" title="2.1) Properties"></a>2.1) Properties</h6><blockquote><p>Properties对象在处理属性文件时特别方便(windows平台上的.ini文件)，Properties类可以把Map对象和属性文件关联起来，从而可以把Map对象中的key-value对写入到属性文件中，也可以把属性文件中的”属性名-属性值”加载到Map对象中</p></blockquote><h5 id="3-SortedMap"><a href="#3-SortedMap" class="headerlink" title="3) SortedMap"></a>3) SortedMap</h5><blockquote><p>正如Set接口派生出SortedSet子接口，SortedSet接口有一个TreeSet实现类一样，Map接口也派生出一个SortedMap子接口，SortedMap接口也有一个TreeMap实现类</p></blockquote><h6 id="3-1-TreeMap"><a href="#3-1-TreeMap" class="headerlink" title="3.1) TreeMap"></a>3.1) TreeMap</h6><blockquote><p>TreeMap就是一个红黑树数据结构，每个key-value对即作为红黑树的一个节点。TreeMap存储key-value对(节点)时，需要根据key对节点进行排序。TreeMap可以保证所有的<br>key-value对处于有序状态。同样，TreeMap也有两种排序方式: 自然排序、定制排序</p></blockquote><h5 id="4-WeakHashMap"><a href="#4-WeakHashMap" class="headerlink" title="4) WeakHashMap"></a>4) WeakHashMap</h5><blockquote><p>WeakHashMap与HashMap的用法基本相似。区别在于，HashMap的key保留了对实际对象的”强引用”，这意味着只要该HashMap对象不被销毁，该HashMap所引用的对象就不会被垃圾回收。但WeakHashMap的key只保留了对实际对象的弱引用，这意味着如果WeakHashMap对象的key所引用的对象没有被其他强引用变量所引用，则这些key所引用的对象可能被垃圾回收，当垃圾回收了该key所对应的实际对象之后，WeakHashMap也可能自动删除这些key所对应的key-value对</p></blockquote><h5 id="5-IdentityHashMap"><a href="#5-IdentityHashMap" class="headerlink" title="5) IdentityHashMap"></a>5) IdentityHashMap</h5><blockquote><p>IdentityHashMap的实现机制与HashMap基本相似，在IdentityHashMap中，当且仅当两个key严格相等(key1 == key2)时，IdentityHashMap才认为两个key相等</p></blockquote><h5 id="6-EnumMap"><a href="#6-EnumMap" class="headerlink" title="6) EnumMap"></a>6) EnumMap</h5><blockquote><p>EnumMap是一个与枚举类一起使用的Map实现，EnumMap中的所有key都必须是单个枚举类的枚举值。创建EnumMap时必须显式或隐式指定它对应的枚举类。EnumMap根据key的自然顺序<br>(即枚举值在枚举类中的定义顺序)</p></blockquote><h2 id="3-Java集合类的应用场景代码"><a href="#3-Java集合类的应用场景代码" class="headerlink" title="3. Java集合类的应用场景代码"></a>3. Java集合类的应用场景代码</h2><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">//类A的equals方法总是返回true,但没有重写其hashCode()方法。不能保证当前对象是HashSet中的唯一对象class A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类B的hashCode()方法总是返回1,但没有重写其equals()方法。不能保证当前对象是HashSet中的唯一对象class B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类C的hashCode()方法总是返回2,且有重写其equals()方法class C</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        HashSet books = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="comment">//分别向books集合中添加两个A对象，两个B对象，两个C对象</span></span><br><span class="line">        books.add(<span class="keyword">new</span> A());</span><br><span class="line">        books.add(<span class="keyword">new</span> A());</span><br><span class="line">        books.add(<span class="keyword">new</span> B());</span><br><span class="line">        books.add(<span class="keyword">new</span> B());</span><br><span class="line">        books.add(<span class="keyword">new</span> C());</span><br><span class="line">        books.add(<span class="keyword">new</span> C());</span><br><span class="line">        System.out.println(books);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">result:</span><br><span class="line">[B@<span class="number">1</span>, B@<span class="number">1</span>, C@<span class="number">2</span>, A@<span class="number">3</span>bc257, A@<span class="number">785</span>d65]</span><br></pre></td></tr></table></figure><p>可以看到，如果两个对象通过equals()方法比较返回true，但这两个对象的hashCode()方法返回不同的hashCode值时，这将导致HashSet会把这两个对象保存在Hash表的不同位置，从而使对象可以添加成功，这就与Set集合的规则有些出入了。所以，我们要明确的是: equals()决定是否可以加入HashSet、而hashCode()决定存放的位置，它们两者必须同时满足才能允许一个新元素加入HashSet<br>但是要注意的是: 如果两个对象的hashCode相同，但是它们的equlas返回值不同，HashSet会在这个位置用链式结构来保存多个对象。而HashSet访问集合元素时也是根据元素的HashCode值来快速定位的，这种链式结构会导致性能下降。<br>所以如果需要把某个类的对象保存到HashSet集合中，我们在重写这个类的equlas()方法和hashCode()方法时，应该尽量保证两个对象通过equals()方法比较返回true时，它们的hashCode()方法返回值也相等</p><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSetTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LinkedHashSet books = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">        books.add(<span class="string">"Java"</span>);</span><br><span class="line">        books.add(<span class="string">"LittleHann"</span>);</span><br><span class="line">        System.out.println(books);</span><br><span class="line">        <span class="comment">//删除 Java</span></span><br><span class="line">      books.remove(<span class="string">"Java"</span>);</span><br><span class="line">        <span class="comment">//重新添加 Java</span></span><br><span class="line">        books.add(<span class="string">"Java"</span>);</span><br><span class="line">        System.out.println(books);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>元素的顺序总是与添加顺序一致，同时要明白的是，LinkedHashSetTest是HashSet的子类，因此它不允许集合元素重复</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TreeSet nums = <span class="keyword">new</span> TreeSet();</span><br><span class="line">        <span class="comment">//向TreeSet中添加四个Integer对象</span></span><br><span class="line">        nums.add(<span class="number">5</span>);</span><br><span class="line">        nums.add(<span class="number">2</span>);</span><br><span class="line">        nums.add(<span class="number">10</span>);</span><br><span class="line">        nums.add(-<span class="number">9</span>);</span><br><span class="line">        <span class="comment">//输出集合元素，看到集合元素已经处于排序状态</span></span><br><span class="line">        System.out.println(nums);</span><br><span class="line">        <span class="comment">//输出集合里的第一个元素</span></span><br><span class="line">        System.out.println(nums.first());</span><br><span class="line">        <span class="comment">//输出集合里的最后一个元素</span></span><br><span class="line">        System.out.println(nums.last());</span><br><span class="line">        <span class="comment">//返回小于4的子集，不包含4</span></span><br><span class="line">        System.out.println(nums.headSet(<span class="number">4</span>));</span><br><span class="line">        <span class="comment">//返回大于5的子集，如果Set中包含5，子集中还包含5</span></span><br><span class="line">        System.out.println(nums.tailSet(<span class="number">5</span>));</span><br><span class="line">        <span class="comment">//返回大于等于-3，小于4的子集。</span></span><br><span class="line">        System.out.println(nums.subSet(-<span class="number">3</span> , <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与HashSet集合采用hash算法来决定元素的存储位置不同，TreeSet采用红黑树的数据结构来存储集合元素。TreeSet支持两种排序方式: 自然排序、定制排序</p><ul><li>自然排序:</li></ul><blockquote><p>TreeSet会调用集合元素的compareTo(Object obj)方法来比较元素之间的大小关系，然后将集合元素按升序排序，即自然排序。如果试图把一个对象添加到TreeSet时，则该对象的类必须实现Comparable接口，否则程序会抛出异常。当把一个对象加入TreeSet集合中时，TreeSet会调用该对象的compareTo(Object obj)方法与容器中的其他对象比较大小，然后根据红黑树结构找到它的存储位置。如果两个对象通过compareTo(Object obj)方法比较相等，新对象将无法添加到TreeSet集合中(牢记Set是不允许重复的概念)。</p></blockquote><p>注意: 当需要把一个对象放入TreeSet中，重写该对象对应类的equals()方法时，应该保证该方法与compareTo(Object obj)方法有一致的结果，即如果两个对象通过equals()方法比较返回true时，这两个对象通过compareTo(Object obj)方法比较结果应该也为0(即相等)</p><p>看到这里，我们应该明白：</p><p>1) 对与Set来说，它定义了equals()为唯一性判断的标准，而对于到了具体的实现，HashSet、TreeSet来说，它们又会有自己特有的唯一性判断标准，只有同时满足了才能判定为唯一性</p><p>2) 我们在操作这些集合类的时候，对和唯一性判断有关的函数重写要重点关注</p><ul><li>定制排序</li></ul><blockquote><p>TreeSet的自然排序是根据集合元素的大小，TreeSet将它们以升序排序。如果我们需要实现定制排序，则可以通过Comparator接口的帮助(类似PHP中的array_map回调处理函数的思想)。该接口里包含一个int compare(T o1， T o2)方法，该方法用于比较大小</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">M</span><span class="params">(<span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"M[age:"</span> + age + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest4</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TreeSet ts = <span class="keyword">new</span> TreeSet(<span class="keyword">new</span> Comparator()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//根据M对象的age属性来决定大小</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                M m1 = (M)o1;</span><br><span class="line">                M m2 = (M)o2;</span><br><span class="line">                <span class="keyword">return</span> m1.age &gt; m2.age ? -<span class="number">1</span></span><br><span class="line">                    : m1.age &lt; m2.age ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ts.add(<span class="keyword">new</span> M(<span class="number">5</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> M(-<span class="number">3</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> M(<span class="number">9</span>));</span><br><span class="line">        System.out.println(ts);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1) equals、compareTo决定的是怎么比的问题，即用什么field进行大小比较<br>2) 自然排序、定制排序、Comparator决定的是谁大的问题，即按什么顺序(升序、降序)进行排序它们的关注点是不同的，一定要注意区分</p><h3 id="EnumSet"><a href="#EnumSet" class="headerlink" title="EnumSet"></a>EnumSet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">enum</span> Season</span><br><span class="line">&#123;</span><br><span class="line">    SPRING,SUMMER,FALL,WINTER</span><br><span class="line">&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSetTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个EnumSet集合，集合元素就是Season枚举类的全部枚举值</span></span><br><span class="line">        EnumSet es1 = EnumSet.allOf(Season<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//输出[SPRING,SUMMER,FALL,WINTER]</span></span><br><span class="line">        System.out.println(es1);</span><br><span class="line">        <span class="comment">//创建一个EnumSet空集合，指定其集合元素是Season类的枚举值。</span></span><br><span class="line">        EnumSet es2 = EnumSet.noneOf(Season<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//输出[]</span></span><br><span class="line">        System.out.println(es2);</span><br><span class="line">        <span class="comment">//手动添加两个元素        es2.add(Season.WINTER);</span></span><br><span class="line">        es2.add(Season.SPRING);</span><br><span class="line">        <span class="comment">//输出[SPRING,WINTER]</span></span><br><span class="line">        System.out.println(es2);</span><br><span class="line">        <span class="comment">//以指定枚举值创建EnumSet集合</span></span><br><span class="line">        EnumSet es3 = EnumSet.of(Season.SUMMER , Season.WINTER);</span><br><span class="line">        <span class="comment">//输出[SUMMER,WINTER]</span></span><br><span class="line">        System.out.println(es3);</span><br><span class="line">        EnumSet es4 = EnumSet.range(Season.SUMMER , Season.WINTER);</span><br><span class="line">        <span class="comment">//输出[SUMMER,FALL,WINTER]</span></span><br><span class="line">        System.out.println(es4);</span><br><span class="line">        <span class="comment">//新创建的EnumSet集合的元素和es4集合的元素有相同类型，</span></span><br><span class="line">        <span class="comment">//es5的集合元素 + es4集合元素 = Season枚举类的全部枚举值</span></span><br><span class="line">        EnumSet es5 = EnumSet.complementOf(es4);</span><br><span class="line">        <span class="comment">//输出[SPRING]</span></span><br><span class="line">        System.out.println(es5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是Set集合类的编程应用场景。那么应该怎样选择何时使用这些集合类呢？</p><p>1) HashSet的性能总是比TreeSet好(特别是最常用的添加、查询元素等操作)，因为TreeSet需要额外的红黑树算法来维护集合元素的次序。只有当需要一个保持排序的Set时，才应该使用TreeSet，否则都应该使用HashSet</p><p>2) 对于普通的插入、删除操作，LinkedHashSet比HashSet要略慢一点，这是由维护链表所带来的开销造成的。不过，因为有了链表的存在，遍历LinkedHashSet会更快</p><p>3) EnumSet是所有Set实现类中性能最好的，但它只能保存同一个枚举类的枚举值作为集合元素</p><p>4) HashSet、TreeSet、EnumSet都是”线程不安全”的，通常可以通过Collections工具类的synchronizedSortedSet方法来”包装”该Set集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SortedSet s = Collections.synchronizedSortedSet(<span class="keyword">new</span> TreeSet(...));</span><br></pre></td></tr></table></figure><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>如果一开始就知道ArrayList集合需要保存多少元素，则可以在创建它们时就指定initialCapacity大小，这样可以减少重新分配的次数，提供性能，ArrayList还提供了如下方法来重新分配Object[]数组</p><p>1) ensureCapacity(int minCapacity): 将ArrayList集合的Object[]数组长度增加minCapacity</p><p>2) trimToSize(): 调整ArrayList集合的Object[]数组长度为当前元素的个数。程序可以通过此方法来减少ArrayList集合对象占用的内存空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List books = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="comment">//向books集合中添加三个元素</span></span><br><span class="line">        books.add(<span class="keyword">new</span> String(<span class="string">"轻量级Java EE应用"</span>));</span><br><span class="line">        books.add(<span class="keyword">new</span> String(<span class="string">"疯狂Java"</span>));</span><br><span class="line">        books.add(<span class="keyword">new</span> String(<span class="string">"疯狂Android"</span>));</span><br><span class="line">        System.out.println(books);</span><br><span class="line">        <span class="comment">//将新字符串对象插入在第二个位置</span></span><br><span class="line">        books.add(<span class="number">1</span> , <span class="keyword">new</span> String(<span class="string">"疯狂Ajax"</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; books.size() ; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(books.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除第三个元素</span></span><br><span class="line">        books.remove(<span class="number">2</span>);</span><br><span class="line">        System.out.println(books);</span><br><span class="line">        <span class="comment">//判断指定元素在List集合中位置：输出1，表明位于第二位</span></span><br><span class="line">        System.out.println(books.indexOf(<span class="keyword">new</span> String(<span class="string">"疯狂Ajax"</span>)));  <span class="comment">//①</span></span><br><span class="line">        <span class="comment">//将第二个元素替换成新的字符串对象</span></span><br><span class="line">        books.set(<span class="number">1</span>, <span class="keyword">new</span> String(<span class="string">"LittleHann"</span>));</span><br><span class="line">        System.out.println(books);</span><br><span class="line">        <span class="comment">//将books集合的第二个元素（包括）</span></span><br><span class="line">        <span class="comment">//到第三个元素（不包括）截取成子集合</span></span><br><span class="line">        System.out.println(books.subList(<span class="number">1</span> , <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>List集合类的编程应用场景。我们来梳理一下</p><ol><li><p>java提供的List就是一个”线性表接口”，ArrayList(基于数组的线性表)、LinkedList(基于链的线性表)是线性表的两种典型实现</p></li><li><p>因为数组以一块连续内存来保存所有的数组元素，所以数组在随机访问时性能最好。所以的内部以数组作为底层实现的集合在随机访问时性能最好。</p></li><li><p>内部以链表作为底层实现的集合在执行插入、删除操作时有很好的性能</p></li><li><p>进行迭代操作时，以链表作为底层实现的集合比以数组作为底层实现的集合性能好</p></li></ol><p>我们之前说过，Collection接口继承了Iterable接口，也就是说，我们以上学习到的所有的Collection集合类都具有”可遍历性”</p><p>Iterable接口也是java集合框架的成员，它隐藏了各种Collection实现类的底层细节，向应用程序提供了遍历Collection集合元素的统一编程接口:</p><p>1) boolean hasNext(): 是否还有下一个未遍历过的元素</p><p>2) Object next(): 返回集合里的下一个元素</p><p>3) void remove(): 删除集合里上一次next方法返回的元素</p><p><strong>iterator实现遍历:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个集合</span></span><br><span class="line">        Collection books = <span class="keyword">new</span> HashSet();</span><br><span class="line">        books.add(<span class="string">"轻量级Java EE应用"</span>);</span><br><span class="line">        books.add(<span class="string">"疯狂Java"</span>);</span><br><span class="line">        books.add(<span class="string">"疯狂Android"</span>);</span><br><span class="line">        <span class="comment">//获取books集合对应的迭代器</span></span><br><span class="line">        Iterator it = books.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//it.next()方法返回的数据类型是Object类型，</span></span><br><span class="line">            <span class="comment">//需要强制类型转换</span></span><br><span class="line">            String book = (String)it.next();</span><br><span class="line">            System.out.println(book);</span><br><span class="line">            <span class="keyword">if</span> (book.equals(<span class="string">"疯狂Java"</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//从集合中删除上一次next方法返回的元素                it.remove();</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//对book变量赋值，不会改变集合元素本身</span></span><br><span class="line">            book = <span class="string">"测试字符串"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(books);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码可以看出，iterator必须依附于Collection对象，若有一个iterator对象，必然有一个与之关联的Collection对象。</p><p>除了可以使用iterator接口迭代访问Collection集合里的元素之外，使用java5提供的foreach循环迭代访问集合元素更加便捷</p><p><strong>foreach实现遍历:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForeachTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个集合</span></span><br><span class="line">        Collection books = <span class="keyword">new</span> HashSet();</span><br><span class="line">        books.add(<span class="keyword">new</span> String(<span class="string">"轻量级Java EE应用"</span>));</span><br><span class="line">        books.add(<span class="keyword">new</span> String(<span class="string">"疯狂Java"</span>));</span><br><span class="line">        books.add(<span class="keyword">new</span> String(<span class="string">"疯狂Android"</span>));</span><br><span class="line">        <span class="keyword">for</span> (Object obj : books)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//此处的book变量也不是集合元素本身</span></span><br><span class="line">            String book = (String)obj;</span><br><span class="line">            System.out.println(book);</span><br><span class="line">            <span class="keyword">if</span> (book.equals(<span class="string">"疯狂Android"</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//下面代码会引发ConcurrentModificationException异常</span></span><br><span class="line">                <span class="comment">//books.remove(book);                  &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(books);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了Collection固有的iterator()方法，List还额外提供了一个listIterator()方法，该方法返回一个ListIterator对象，ListIterator接口继承了Iterator接口，提供了专门操作List的方法。ListIterator接口在Iterator接口的继承上增加了如下方法:</p><p>1) boolean hasPrevious(): 返回该迭代器关联的集合是否还有上一个元素</p><p>2) Object previous(): 返回该迭代器的上一个元素(向前迭代)</p><p>3) void add(): 在指定位置插入一个元素</p><p><strong>ListIterator实现遍历:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListIteratorTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String[] books = &#123;</span><br><span class="line">            <span class="string">"疯狂Java"</span>,</span><br><span class="line">            <span class="string">"轻量级Java EE应用"</span></span><br><span class="line">        &#125;;</span><br><span class="line">        List bookList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; books.length ; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            bookList.add(books[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ListIterator lit = bookList.listIterator();</span><br><span class="line">        <span class="keyword">while</span> (lit.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(lit.next());</span><br><span class="line">            lit.add(<span class="string">"-------分隔符-------"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"=======下面开始反向迭代======="</span>);</span><br><span class="line">        <span class="keyword">while</span>(lit.hasPrevious())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(lit.previous());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map实现"><a href="#Map实现" class="headerlink" title="Map实现"></a>Map实现</h3><h4 id="HashMap、Hashtable"><a href="#HashMap、Hashtable" class="headerlink" title="HashMap、Hashtable"></a>HashMap、Hashtable</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据count的值来判断两个对象是否相等。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj!=<span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            obj.getClass()==A<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        </span>&#123;</span><br><span class="line">            A a = (A)obj;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.count == a.count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据count来计算hashCode值。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//重写equals()方法，B对象与任何对象通过equals()方法比较都相等</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashtableTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Hashtable ht = <span class="keyword">new</span> Hashtable();</span><br><span class="line">        ht.put(<span class="keyword">new</span> A(<span class="number">60000</span>) , <span class="string">"疯狂Java"</span>);</span><br><span class="line">        ht.put(<span class="keyword">new</span> A(<span class="number">87563</span>) , <span class="string">"轻量级Java EE应用"</span>);</span><br><span class="line">        ht.put(<span class="keyword">new</span> A(<span class="number">1232</span>) , <span class="keyword">new</span> B());</span><br><span class="line">        System.out.println(ht);</span><br><span class="line">        <span class="comment">//只要两个对象通过equals比较返回true，</span></span><br><span class="line">        <span class="comment">//Hashtable就认为它们是相等的value。</span></span><br><span class="line">        <span class="comment">//由于Hashtable中有一个B对象，</span></span><br><span class="line">        <span class="comment">//它与任何对象通过equals比较都相等，所以下面输出true。</span></span><br><span class="line">        System.out.println(ht.containsValue(<span class="string">"测试字符串"</span>));  <span class="comment">//①</span></span><br><span class="line">        <span class="comment">//只要两个A对象的count相等，它们通过equals比较返回true，且hashCode相等</span></span><br><span class="line">        <span class="comment">//Hashtable即认为它们是相同的key，所以下面输出true。</span></span><br><span class="line">        System.out.println(ht.containsKey(<span class="keyword">new</span> A(<span class="number">87563</span>)));   <span class="comment">//②</span></span><br><span class="line">        <span class="comment">//下面语句可以删除最后一个key-value对</span></span><br><span class="line">        ht.remove(<span class="keyword">new</span> A(<span class="number">1232</span>));    <span class="comment">//③</span></span><br><span class="line">        <span class="comment">//通过返回Hashtable的所有key组成的Set集合，</span></span><br><span class="line">        <span class="comment">//从而遍历Hashtable每个key-value对</span></span><br><span class="line">        <span class="keyword">for</span> (Object key : ht.keySet())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(key + <span class="string">"----&gt;"</span>);</span><br><span class="line">            System.out.print(ht.get(key) + <span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用自定义类作为HashMap、Hashtable的key时，如果重写该类的equals(Object obj)和hashCode()方法，则应该保证两个方法的判断标准一致–当两个key通过equals()方法比较返回true时，两个key的hashCode()的返回值也应该相同</p><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMapTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LinkedHashMap scores = <span class="keyword">new</span> LinkedHashMap();</span><br><span class="line">        scores.put(<span class="string">"语文"</span> , <span class="number">80</span>);</span><br><span class="line">        scores.put(<span class="string">"英文"</span> , <span class="number">82</span>);</span><br><span class="line">        scores.put(<span class="string">"数学"</span> , <span class="number">76</span>);</span><br><span class="line">        <span class="comment">//遍历scores里的所有的key-value对</span></span><br><span class="line">        <span class="keyword">for</span> (Object key : scores.keySet())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(key + <span class="string">"------&gt;"</span> + scores.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">R</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">R</span><span class="params">(<span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"R[count:"</span> + count + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据count来判断两个对象是否相等。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj!=<span class="keyword">null</span></span><br><span class="line">            &amp;&amp; obj.getClass()==R<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        </span>&#123;</span><br><span class="line">            R r = (R)obj;</span><br><span class="line">            <span class="keyword">return</span> r.count == <span class="keyword">this</span>.count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据count属性值来判断两个对象的大小。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        R r = (R)obj;</span><br><span class="line">        <span class="keyword">return</span> count &gt; r.count ? <span class="number">1</span> :</span><br><span class="line">            count &lt; r.count ? -<span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMapTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TreeMap tm = <span class="keyword">new</span> TreeMap();</span><br><span class="line">        tm.put(<span class="keyword">new</span> R(<span class="number">3</span>) , <span class="string">"轻量级Java EE应用"</span>);</span><br><span class="line">        tm.put(<span class="keyword">new</span> R(-<span class="number">5</span>) , <span class="string">"疯狂Java"</span>);</span><br><span class="line">        tm.put(<span class="keyword">new</span> R(<span class="number">9</span>) , <span class="string">"疯狂Android"</span>);</span><br><span class="line">        System.out.println(tm);</span><br><span class="line">        <span class="comment">//返回该TreeMap的第一个Entry对象</span></span><br><span class="line">        System.out.println(tm.firstEntry());</span><br><span class="line">        <span class="comment">//返回该TreeMap的最后一个key值</span></span><br><span class="line">        System.out.println(tm.lastKey());</span><br><span class="line">        <span class="comment">//返回该TreeMap的比new R(2)大的最小key值。</span></span><br><span class="line">        System.out.println(tm.higherKey(<span class="keyword">new</span> R(<span class="number">2</span>)));</span><br><span class="line">        <span class="comment">//返回该TreeMap的比new R(2)小的最大的key-value对。</span></span><br><span class="line">        System.out.println(tm.lowerEntry(<span class="keyword">new</span> R(<span class="number">2</span>)));</span><br><span class="line">        <span class="comment">//返回该TreeMap的子TreeMap</span></span><br><span class="line">        System.out.println(tm.subMap(<span class="keyword">new</span> R(-<span class="number">1</span>) , <span class="keyword">new</span> R(<span class="number">4</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，类似于TreeSet中判断两个元素是否相等的标准，TreeMap中判断两个key相等的标准是:</p><p>1) 两个key通过compareTo()方法返回0</p><p>2) equals()放回true</p><p>我们在重写这两个方法的时候一定要保证它们的逻辑关系一致。</p><p>强调一下:</p><p>Set和Map的关系十分密切，java源码就是先实现了HashMap、TreeMap等集合，然后通过包装一个所有的value都为null的Map集合实现了Set集合类</p><p>以上就是Map集合类的编程应用场景。我们来梳理一下思路</p><p>1) HashMap和Hashtable的效率大致相同，因为它们的实现机制几乎完全一样。但HashMap通常比Hashtable要快一点，因为Hashtable需要额外的线程同步控制</p><p>2) TreeMap通常比HashMap、Hashtable要慢(尤其是在插入、删除key-value对时更慢)，因为TreeMap底层采用红黑树来管理key-value对</p><p>3) 使用TreeMap的一个好处就是： TreeMap中的key-value对总是处于有序状态，无须专门进行排序操作</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Set </tag>
            
            <tag> List </tag>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HotSpot的算法实现</title>
      <link href="/2019/10/15/HotSpot%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/10/15/HotSpot%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2019/10/15/HotSpot%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/1.jpg" alt=" "></p><h2 id="1-枚举根节点"><a href="#1-枚举根节点" class="headerlink" title="1.枚举根节点"></a>1.枚举根节点</h2><p>　　在可达性分析中，可以作为GC Roots的节点有很多，但是现在很多应用仅仅方法区就有上百MB，如果逐个检查的话，效率就会变得不可接受。</p><p>　　而且，可达性分析必须在一个一致性的快照中进行-即整个分析期间，系统就像冻结了一样。否则如果一边分析，系统一边动态表化，得到的结果就没有准确性。这就导致了系统GC时必须停顿所有的Java执行线程。</p><p>　　目前主流Java虚拟机使用的都是准确式GC，所以当执行系统都停顿下来之后，并不需要一个不漏的检查完所有执行上下文和全局的引用位置，虚拟机应该有办法直接知道哪些地方存放着对象引用。在HotSpot实现中，使用一组称为 OopMap 的数据结构来达到这个目的。OopMap会在类加载完成的时候，记录对象内什么偏移量上是什么类型的数据，在JTI编译过程中，也会在特定的位置记录下栈和寄存器哪些位置是引用。这样，在GC扫描的时候就可以直接得到这些信息了。</p><h2 id="2-安全点"><a href="#2-安全点" class="headerlink" title="2.安全点"></a>2.安全点</h2><p>　　如果OopMap内容变化的指令非常多，HotSpot并不会为每条指令都产生OopMap，只是在特定的位置记录了这些信息，这些位置成为“安全点”（SafePoint）。程序执行时只有在达到安全点的时候才停顿开始GC。一般具有较长运行时间的指令才能被选为安全点，如方法调用、循环跳转、异常跳转等。</p><p>　　接下来要考虑的便是，如何在GC时保证所有的线程都“跑”到安全点上停顿下来。这里有两种方案： 抢先式中断 （Preemptive Suspension） 和主动式中断 （Voluntary Suspension）。</p><p>　　抢先式中断会把所有线程中断，如果某个线程不在安全点上，就恢复线程让它跑到安全点上。几乎没有虚拟机采用这种方式。</p><p>　　主动式中断思想是需要中断线程时，不直接对线程操作，而是设置一个GC标志，各个线程会轮询这个标志并在需要时自己中断挂起。这样，轮询标志的地方和安全点是重合的。</p><h2 id="3-安全区域"><a href="#3-安全区域" class="headerlink" title="3.安全区域"></a>3.安全区域</h2><p>　　安全点机制保证程序执行时，在不太长的时间内就会遇到可进入GC的安全点，但是，程序“不执行”的时候呢，程序不执行就是没有分配CPU时间，这时线程无法响应JVM的中断请求，JVM显然不太可能的等待线程重新被分配CPU时间。</p><p>　　安全区域是指一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。</p><p>　　在线程执行到安全区域代码时，首先标识自己进入安全区域，当这段时间里JVM发起GC，不用管标识为安全区域的线程了。在线程要离开安全区域时，要检查系统是否已经完成了根节点枚举，如果完成，线程继续执行，否则等待直到收到可以安全离开安全区域的信号为止。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机（JVM）你只要看这一篇就够了！</title>
      <link href="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/"/>
      <url>/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/JVM.png" alt="JVM"></p><h2 id="1-Java-内存区域与内存溢出异常"><a href="#1-Java-内存区域与内存溢出异常" class="headerlink" title="1.Java 内存区域与内存溢出异常"></a>1.Java 内存区域与内存溢出异常</h2><h3 id="1-1-运行时数据区域"><a href="#1-1-运行时数据区域" class="headerlink" title="1.1 运行时数据区域"></a>1.1 运行时数据区域</h3><blockquote><p>根据《Java 虚拟机规范(Java SE 7 版)》规定，Java 虚拟机所管理的内存如下图所示。</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.jpg" alt="Java虚拟机运行时数据区"></p><h4 id="1-1-1-程序计数器"><a href="#1-1-1-程序计数器" class="headerlink" title="1.1.1 程序计数器"></a>1.1.1 程序计数器</h4><blockquote><p>内存空间小，线程私有。字节码解释器工作是就是通过改变这个计数器的值来选取下一条需要执行指令的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成</p></blockquote><p>如果线程正在执行一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器的值则为 (Undefined)。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</p><h4 id="1-1-2-Java-虚拟机栈"><a href="#1-1-2-Java-虚拟机栈" class="headerlink" title="1.1.2 Java 虚拟机栈"></a>1.1.2 Java 虚拟机栈</h4><blockquote><p>线程私有，生命周期和线程一致。描述的是 Java 方法执行的内存模型：每个方法在执行时都会床创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。</p></blockquote><p>局部变量表：存放了编译期可知的各种基本类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference 类型)和 returnAddress 类型(指向了一条字节码指令的地址)</p><p>StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度。<br>OutOfMemoryError：如果虚拟机栈可以动态扩展，而扩展时无法申请到足够的内存。</p><h4 id="1-1-3-本地方法栈"><a href="#1-1-3-本地方法栈" class="headerlink" title="1.1.3 本地方法栈"></a>1.1.3 本地方法栈</h4><blockquote><p>区别于 Java 虚拟机栈的是，Java 虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。也会有 StackOverflowError 和 OutOfMemoryError 异常。</p></blockquote><h4 id="1-1-4-Java-堆"><a href="#1-1-4-Java-堆" class="headerlink" title="1.1.4 Java 堆"></a>1.1.4 Java 堆</h4><blockquote><p>对于绝大多数应用来说，这块区域是 JVM 所管理的内存中最大的一块。线程共享，主要是存放对象实例和数组。内部会划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)。可以位于物理上不连续的空间，但是逻辑上要连续。</p></blockquote><p>OutOfMemoryError：如果堆中没有内存完成实例分配，并且堆也无法再扩展时，抛出该异常。</p><h4 id="1-1-5-方法区"><a href="#1-1-5-方法区" class="headerlink" title="1.1.5 方法区"></a>1.1.5 方法区</h4><blockquote><p>属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p></blockquote><h4 id="1-1-6-运行时常量池"><a href="#1-1-6-运行时常量池" class="headerlink" title="1.1.6 运行时常量池"></a>1.1.6 运行时常量池</h4><blockquote><p>属于方法区一部分，用于存放编译期生成的各种字面量和符号引用。编译器和运行期(String 的 intern() )都可以将常量放入池中。内存有限，无法申请时抛出 OutOfMemoryError。</p></blockquote><h4 id="1-1-7-直接内存"><a href="#1-1-7-直接内存" class="headerlink" title="1.1.7 直接内存"></a>1.1.7 直接内存</h4><blockquote><p>非虚拟机运行时数据区的部分</p></blockquote><p>在 JDK 1.4 中新加入 NIO (New Input/Output) 类，引入了一种基于通道(Channel)和缓存(Buffer)的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。可以避免在 Java 堆和 Native 堆中来回的数据耗时操作。<br>OutOfMemoryError：会受到本机内存限制，如果内存区域总和大于物理内存限制从而导致动态扩展时出现该异常。</p><h3 id="1-2-HotSpot-虚拟机对象探秘"><a href="#1-2-HotSpot-虚拟机对象探秘" class="headerlink" title="1.2 HotSpot 虚拟机对象探秘"></a>1.2 HotSpot 虚拟机对象探秘</h3><blockquote><p>主要介绍数据是如何创建、如何布局以及如何访问的。</p></blockquote><h4 id="1-2-1-对象的创建"><a href="#1-2-1-对象的创建" class="headerlink" title="1.2.1 对象的创建"></a>1.2.1 对象的创建</h4><p>遇到 new 指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，执行相应的类加载。</p><p>类加载检查通过之后，为新对象分配内存(内存大小在类加载完成后便可确认)。在堆的空闲内存中划分一块区域(‘指针碰撞-内存规整’或‘空闲列表-内存交错’的分配方式)。</p><p>前面讲的每个线程在堆中都会有私有的分配缓冲区(TLAB)，这样可以很大程度避免在并发情况下频繁创建对象造成的线程不安全。</p><p>内存空间分配完成后会初始化为 0(不包括对象头)，接下来就是填充对象头，把对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息存入对象头。</p><p>执行 new 指令后执行 init 方法后才算一份真正可用的对象创建完成。</p><h4 id="1-2-2-对象的内存布局"><a href="#1-2-2-对象的内存布局" class="headerlink" title="1.2.2 对象的内存布局"></a>1.2.2 对象的内存布局</h4><blockquote><p>在 HotSpot 虚拟机中，分为 3 块区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)</p></blockquote><p>对象头(Header)：包含两部分，第一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，32 位虚拟机占 32 bit，64 位虚拟机占 64 bit。官方称为 ‘Mark Word’。第二部分是类型指针，即对象指向它的类的元数据指针，虚拟机通过这个指针确定这个对象是哪个类的实例。另外，如果是 Java 数组，对象头中还必须有一块用于记录数组长度的数据，因为普通对象可以通过 Java 对象元数据确定大小，而数组对象不可以。</p><p>实例数据(Instance Data)：程序代码中所定义的各种类型的字段内容(包含父类继承下来的和子类中定义的)。</p><p>对齐填充(Padding)：不是必然需要，主要是占位，保证对象大小是某个字节的整数倍。</p><h4 id="1-2-3-对象的访问定位"><a href="#1-2-3-对象的访问定位" class="headerlink" title="1.2.3 对象的访问定位"></a>1.2.3 对象的访问定位</h4><blockquote><p>使用对象时，通过栈上的 reference 数据来操作堆上的具体对象。</p></blockquote><p>通过句柄访问</p><blockquote><p>Java 堆中会分配一块内存作为句柄池。reference 存储的是句柄地址。详情见图。</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.jpg" alt="通过句柄访问对象"></p><p>使用直接指针访问</p><blockquote><p>reference 中直接存储对象地址</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/%E9%80%9A%E8%BF%87%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.jpg" alt="通过直接指针访问对象"></p><p>比较：使用句柄的最大好处是 reference 中存储的是稳定的句柄地址，在对象移动(GC)是只改变实例数据指针地址，reference 自身不需要修改。直接指针访问的最大好处是速度快，节省了一次指针定位的时间开销。如果是对象频繁 GC 那么句柄方法好，如果是对象频繁访问则直接指针访问好。</p><h2 id="2-垃圾回收器与内存分配策略"><a href="#2-垃圾回收器与内存分配策略" class="headerlink" title="2. 垃圾回收器与内存分配策略"></a>2. 垃圾回收器与内存分配策略</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><blockquote><p>程序计数器、虚拟机栈、本地方法栈 3 个区域随线程生灭(因为是线程私有)，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。而 Java 堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期才知道那些对象会创建，这部分内存的分配和回收都是动态的，垃圾回收期所关注的就是这部分内存。</p></blockquote><h3 id="2-2-对象已死吗"><a href="#2-2-对象已死吗" class="headerlink" title="2.2 对象已死吗"></a>2.2 对象已死吗</h3><blockquote><p>在进行内存回收之前要做的事情就是判断那些对象是‘死’的，哪些是‘活’的。</p></blockquote><h4 id="2-2-1-引用计数法"><a href="#2-2-1-引用计数法" class="headerlink" title="2.2.1 引用计数法"></a>2.2.1 引用计数法</h4><blockquote><p>给对象添加一个引用计数器。但是难以解决循环引用问题。</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/java%E5%A0%86%E6%A0%88%E5%BC%95%E7%94%A8.jpg" alt="java堆栈引用"></p><p>从图中可以看出，如果不下小心直接把 Obj1-reference 和 Obj2-reference 置 null。则在 Java 堆当中的两块内存依然保持着互相引用无法回收。</p><h4 id="2-2-2-可达性分析法"><a href="#2-2-2-可达性分析法" class="headerlink" title="2.2.2 可达性分析法"></a>2.2.2 可达性分析法</h4><blockquote><p>通过一系列的 ‘GC Roots’ 的对象作为起始点，从这些节点出发所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连的时候说明对象不可用。</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E6%B3%95.jpg" alt="可达性分析"></p><p>可作为 GC Roots 的对象：</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI(即一般说的 Native 方法) 引用的对象</li></ul><h4 id="2-2-3-引用"><a href="#2-2-3-引用" class="headerlink" title="2.2.3 引用"></a>2.2.3 引用</h4><blockquote><p>前面的两种方式判断存活时都与‘引用’有关。但是 JDK 1.2 之后，引用概念进行了扩充</p></blockquote><p>种引用强度一次逐渐减弱</p><p>强引用</p><blockquote><p>类似于 Object obj = new Object(); 创建的，只要强引用在就不回收。</p></blockquote><p>软引用</p><blockquote><p>SoftReference 类实现软引用。在系统要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。</p></blockquote><p>弱引用</p><blockquote><p>WeakReference 类实现弱引用。对象只能生存到下一次垃圾收集之前。在垃圾收集器工作时，无论内存是否足够都会回收掉只被弱引用关联的对象。</p></blockquote><p>虚引用</p><blockquote><p>PhantomReference 类实现虚引用。无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</p></blockquote><h4 id="2-2-4-生存还是死亡"><a href="#2-2-4-生存还是死亡" class="headerlink" title="2.2.4 生存还是死亡"></a>2.2.4 生存还是死亡</h4><p>即使在可达性分析算法中不可达的对象，也并非是“facebook”的，这时候它们暂时出于“缓刑”阶段，一个对象的真正死亡至少要经历两次标记过程：如果对象在进行中可达性分析后发现没有与 GC Roots 相连接的引用链，那他将会被第一次标记并且进行一次筛选，筛选条件是此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p><p>如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象竟会放置在一个叫做 F-Queue 的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。这里所谓的“执行”是指虚拟机会出发这个方法，并不承诺或等待他运行结束。finalize() 方法是对象逃脱死亡命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记，如果对象要在 finalize() 中成功拯救自己 —— 只要重新与引用链上的任何一个对象简历关联即可。</p><p>finalize() 方法只会被系统自动调用一次。</p><h4 id="2-2-5-回收方法区"><a href="#2-2-5-回收方法区" class="headerlink" title="2.2.5 回收方法区"></a>2.2.5 回收方法区</h4><blockquote><p>在堆中，尤其是在新生代中，一次垃圾回收一般可以回收 70% ~ 95% 的空间，而永久代的垃圾收集效率远低于此。<br>永久代垃圾回收主要两部分内容：废弃的常量和无用的类。</p></blockquote><p>判断废弃常量：一般是判断没有该常量的引用。</p><p>判断无用的类：要以下三个条件都满足</p><ul><li>该类所有的实例都已经回收，也就是 Java 堆中不存在该类的任何实例</li><li>加载该类的 ClassLoader 已经被回收</li><li>该类对应的 java.lang.Class 对象没有任何地方呗引用，无法在任何地方通过反射访问该类的方法</li></ul><h3 id="2-3-垃圾回收算法"><a href="#2-3-垃圾回收算法" class="headerlink" title="2.3 垃圾回收算法"></a>2.3 垃圾回收算法</h3><h4 id="2-3-1-标记-——-清除算法"><a href="#2-3-1-标记-——-清除算法" class="headerlink" title="2.3.1 标记 —— 清除算法"></a>2.3.1 标记 —— 清除算法</h4><blockquote><p>直接标记清除就可。</p></blockquote><p>两个不足：</p><ul><li>效率不高</li><li>空间会产生大量碎片</li></ul><h4 id="2-3-2-复制算法"><a href="#2-3-2-复制算法" class="headerlink" title="2.3.2 复制算法"></a>2.3.2 复制算法</h4><blockquote><p>把空间分成两块，每次只对其中一块进行 GC。当这块内存使用完时，就将还存活的对象复制到另一块上面。</p></blockquote><p>解决前一种方法的不足，但是会造成空间利用率低下。因为大多数新生代对象都不会熬过第一次 GC。所以没必要 1 : 1 划分空间。可以分一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另一块 Survivor 上，最后清理 Eden 和 Survivor 空间。大小比例一般是 8 : 1 : 1，每次浪费 10% 的 Survivor 空间。但是这里有一个问题就是如果存活的大于 10% 怎么办？这里采用一种分配担保策略：多出来的对象直接进入老年代。</p><h4 id="2-3-3-标记-整理算法"><a href="#2-3-3-标记-整理算法" class="headerlink" title="2.3.3 标记-整理算法"></a>2.3.3 标记-整理算法</h4><blockquote><p>不同于针对新生代的复制算法，针对老年代的特点，创建该算法。主要是把存活对象移到内存的一端。</p></blockquote><h4 id="2-3-4-分代回收"><a href="#2-3-4-分代回收" class="headerlink" title="2.3.4 分代回收"></a>2.3.4 分代回收</h4><blockquote><p>根据存活对象划分几块内存区，一般是分为新生代和老年代。然后根据各个年代的特点制定相应的回收算法。</p></blockquote><ul><li>新生代</li></ul><blockquote><p>每次垃圾回收都有大量对象死去，只有少量存活，选用复制算法比较合理。</p></blockquote><ul><li>老年代</li></ul><blockquote><p>老年代中对象存活率较高、没有额外的空间分配对它进行担保。所以必须使用 标记 —— 清除 或者 标记 —— 整理 算法回收。</p></blockquote><h3 id="2-4-HotSpot-的算法实现"><a href="#2-4-HotSpot-的算法实现" class="headerlink" title="2.4 HotSpot 的算法实现"></a>2.4 HotSpot 的算法实现</h3><p><a href="http://www.theoak.online/2019/10/15/HotSpot%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">HotSpot的算法实现</a></p><h3 id="2-5-垃圾回收器"><a href="#2-5-垃圾回收器" class="headerlink" title="2.5 垃圾回收器"></a>2.5 垃圾回收器</h3><blockquote><p>收集算法是内存回收的理论，而垃圾回收器是内存回收的实践。</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="HotSpot虚拟机的垃圾收集器"></p><p><strong>说明：</strong> 如果两个收集器之间存在连线说明他们之间可以搭配使用。</p><h4 id="2-5-1-Serial-收集器"><a href="#2-5-1-Serial-收集器" class="headerlink" title="2.5.1 Serial 收集器"></a>2.5.1 Serial 收集器</h4><blockquote><p>这是一个单线程收集器。意味着它只会使用一个 CPU 或一条收集线程去完成收集工作，并且在进行垃圾回收时必须暂停其它所有的工作线程直到收集结束。</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/Serial&SerialOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="Serial&amp;SerialOld收集器运行示意图"></p><h4 id="2-5-2-ParNew-收集器"><a href="#2-5-2-ParNew-收集器" class="headerlink" title="2.5.2 ParNew 收集器"></a>2.5.2 ParNew 收集器</h4><blockquote><p>可以认为是 Serial 收集器的多线程版本。</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/ParNew%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="ParNew收集器运行示意图"></p><p>并行：Parallel</p><blockquote><p>指多条垃圾收集线程并行工作，此时用户线程处于等待状态</p></blockquote><p>并发：Concurrent</p><blockquote><p>指用户线程和垃圾回收线程同时执行(不一定是并行，有可能是交叉执行)，用户进程在运行，而垃圾回收线程在另一个 CPU 上运行。</p></blockquote><h4 id="2-5-3-Parallel-Scavenge-收集器"><a href="#2-5-3-Parallel-Scavenge-收集器" class="headerlink" title="2.5.3 Parallel Scavenge 收集器"></a>2.5.3 Parallel Scavenge 收集器</h4><blockquote><p>这是一个新生代收集器，也是使用复制算法实现，同时也是并行的多线程收集器。</p></blockquote><p>CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程所停顿的时间，而 Parallel Scavenge 收集器的目的是达到一个可控制的吞吐量(Throughput = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间))。</p><p>作为一个吞吐量优先的收集器，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整停顿时间。这就是 GC 的自适应调整策略(GC Ergonomics)。</p><h4 id="2-5-4-Serial-Old-收集器"><a href="#2-5-4-Serial-Old-收集器" class="headerlink" title="2.5.4 Serial Old 收集器"></a>2.5.4 Serial Old 收集器</h4><blockquote><p>收集器的老年代版本，单线程，使用 标记 —— 整理。</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/Serial&SerialOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="SerialOld收集器运行示意图"></p><h4 id="2-5-5-Parallel-Old-收集器"><a href="#2-5-5-Parallel-Old-收集器" class="headerlink" title="2.5.5 Parallel Old 收集器"></a>2.5.5 Parallel Old 收集器</h4><blockquote><p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本。多线程，使用 标记 —— 整理</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/ParallelOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="ParallelOld收集器运行示意图"></p><h4 id="2-5-6-CMS-收集器"><a href="#2-5-6-CMS-收集器" class="headerlink" title="2.5.6 CMS 收集器"></a>2.5.6 CMS 收集器</h4><blockquote><p>CMS (Concurrent Mark Sweep) 收集器是一种以获取最短回收停顿时间为目标的收集器。基于 标记 —— 清除 算法实现。</p></blockquote><p>运作步骤:</p><ul><li>初始标记(CMS initial mark)：标记 GC Roots 能直接关联到的对象</li><li>并发标记(CMS concurrent mark)：进行 GC Roots Tracing</li><li>重新标记(CMS remark)：修正并发标记期间的变动部分</li><li>并发清除(CMS concurrent sweep)</li></ul><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/ConcurrentMarkSweep%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="ConcurrentMarkSweep收集器运行示意图"></p><p>缺点：对 CPU 资源敏感、无法收集浮动垃圾、标记 —— 清除 算法带来的空间碎片</p><h4 id="2-5-7-G1-收集器"><a href="#2-5-7-G1-收集器" class="headerlink" title="2.5.7 G1 收集器"></a>2.5.7 G1 收集器</h4><blockquote><p>面向服务端的垃圾回收器。</p></blockquote><p>优点：并行与并发、分代收集、空间整合、可预测停顿。</p><p>运作步骤:</p><ul><li>初始标记(Initial Marking)</li><li>并发标记(Concurrent Marking)</li><li>最终标记(Final Marking)</li><li>筛选回收(Live Data Counting and Evacuation)</li></ul><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/G1%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="G1收集器运行示意图"></p><h3 id="2-6-内存分配与回收策略"><a href="#2-6-内存分配与回收策略" class="headerlink" title="2.6 内存分配与回收策略"></a>2.6 内存分配与回收策略</h3><h4 id="2-6-1-对象优先在-Eden-分配"><a href="#2-6-1-对象优先在-Eden-分配" class="headerlink" title="2.6.1 对象优先在 Eden 分配"></a>2.6.1 对象优先在 Eden 分配</h4><blockquote><p>对象主要分配在新生代的 Eden 区上，如果启动了本地线程分配缓冲区，将线程优先在 (TLAB) 上分配。少数情况会直接分配在老年代中。</p></blockquote><p>一般来说 Java 堆的内存模型如下图所示：</p><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/java%E5%A0%86%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.jpg" alt="java堆的内存模型"></p><p>新生代 GC (Minor GC)</p><blockquote><p>发生在新生代的垃圾回收动作，频繁，速度快。</p></blockquote><p>老年代 GC (Major GC / Full GC)</p><blockquote><p>发生在老年代的垃圾回收动作，出现了 Major GC 经常会伴随至少一次 Minor GC(非绝对)。Major GC 的速度一般会比 Minor GC 慢十倍以上。</p></blockquote><h4 id="2-6-2-大对象直接进入老年代"><a href="#2-6-2-大对象直接进入老年代" class="headerlink" title="2.6.2 大对象直接进入老年代"></a>2.6.2 大对象直接进入老年代</h4><h4 id="2-6-3-长期存活的对象将进入老年代"><a href="#2-6-3-长期存活的对象将进入老年代" class="headerlink" title="2.6.3 长期存活的对象将进入老年代"></a>2.6.3 长期存活的对象将进入老年代</h4><h4 id="2-6-4-动态对象年龄判定"><a href="#2-6-4-动态对象年龄判定" class="headerlink" title="2.6.4 动态对象年龄判定"></a>2.6.4 动态对象年龄判定</h4><h4 id="2-6-5-空间分配担保"><a href="#2-6-5-空间分配担保" class="headerlink" title="2.6.5 空间分配担保"></a>2.6.5 空间分配担保</h4><h2 id="3-Java-内存模型与线程"><a href="#3-Java-内存模型与线程" class="headerlink" title="3. Java 内存模型与线程"></a>3. Java 内存模型与线程</h2><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/%E5%A4%84%E7%90%86%E5%99%A8%E3%80%81%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E3%80%81%E4%B8%BB%E5%86%85%E5%AD%98%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB.jpg" alt="处理器、高速缓存、主内存间的交互关系"></p><h3 id="3-1-Java-内存模型"><a href="#3-1-Java-内存模型" class="headerlink" title="3.1 Java 内存模型"></a>3.1 Java 内存模型</h3><h4 id="3-1-1-主内存和工作内存之间的交互"><a href="#3-1-1-主内存和工作内存之间的交互" class="headerlink" title="3.1.1 主内存和工作内存之间的交互"></a>3.1.1 主内存和工作内存之间的交互</h4><table><thead><tr><th align="center">操作</th><th align="center">作用对象</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">lock</td><td align="center">主内存</td><td align="center">把一个变量标识为一条线程独占的状态</td></tr><tr><td align="center">unlock</td><td align="center">主内存</td><td align="center">把一个处于锁定状态的变量释放出来，释放后才可被其他线程锁定</td></tr><tr><td align="center">read</td><td align="center">主内存</td><td align="center">把一个变量的值从主内存传输到线程工作内存中，以便 load 操作使用</td></tr><tr><td align="center">load</td><td align="center">工作内存</td><td align="center">把 read 操作从主内存中得到的变量值放入工作内存中</td></tr><tr><td align="center">use</td><td align="center">工作内存</td><td align="center">把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量值的字节码指令时将会执行这个操作</td></tr><tr><td align="center">assign</td><td align="center">工作内存</td><td align="center">把一个从执行引擎接收到的值赋接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</td></tr><tr><td align="center">store</td><td align="center">工作内存</td><td align="center">把工作内存中的一个变量的值传送到主内存中，以便 write 操作</td></tr><tr><td align="center">write</td><td align="center">工作内存</td><td align="center">把 store 操作从工作内存中得到的变量的值放入主内存的变量中</td></tr></tbody></table><h4 id="3-1-2-对于-volatile-型变量的特殊规则"><a href="#3-1-2-对于-volatile-型变量的特殊规则" class="headerlink" title="3.1.2 对于 volatile 型变量的特殊规则"></a>3.1.2 对于 volatile 型变量的特殊规则</h4><blockquote><p>关键字 volatile 是 Java 虚拟机提供的最轻量级的同步机制。</p></blockquote><p>一个变量被定义为 volatile 的特性：</p><p>保证此变量对所有线程的可见性。但是操作并非原子操作，并发情况下不安全。</p><blockquote><p>果不符合 运算结果并不依赖变量当前值，或者能够确保只有单一的线程修改变量的值 和 变量不需要与其他的状态变量共同参与不变约束 就要通过加锁(使用 synchronize 或 java.util.concurrent 中的原子类)来保证原子性。</p></blockquote><p>禁止指令重排序优化。</p><blockquote><p>通过插入内存屏障保证一致性。</p></blockquote><h4 id="3-1-3-对于-long-和-double-型变量的特殊规则"><a href="#3-1-3-对于-long-和-double-型变量的特殊规则" class="headerlink" title="3.1.3 对于 long 和 double 型变量的特殊规则"></a>3.1.3 对于 long 和 double 型变量的特殊规则</h4><blockquote><p>Java 要求对于主内存和工作内存之间的八个操作都是原子性的，但是对于 64 位的数据类型，有一条宽松的规定：允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虚拟机实现选择可以不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性。这就是 long 和 double 的非原子性协定。</p></blockquote><h4 id="3-1-4-原子性、可见性与有序性"><a href="#3-1-4-原子性、可见性与有序性" class="headerlink" title="3.1.4 原子性、可见性与有序性"></a>3.1.4 原子性、可见性与有序性</h4><ul><li>原子性(Atomicity)</li></ul><blockquote><p>由 Java 内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store 和 write。大致可以认为基本数据类型的操作是原子性的。同时 lock 和 unlock 可以保证更大范围操作的原子性。而 synchronize 同步块操作的原子性是用更高层次的字节码指令 monitorenter 和 monitorexit 来隐式操作的。</p></blockquote><ul><li>可见性(Visibility)</li></ul><blockquote><p>是指当一个线程修改了共享变量的值，其他线程也能够立即得知这个通知。主要操作细节就是修改值后将值同步至主内存(volatile 值使用前都会从主内存刷新)，除了 volatile 还有 synchronize 和 final 可以保证可见性。同步块的可见性是由“对一个变量执行 unlock 操作之前，必须先把此变量同步会主内存中( store、write 操作)”这条规则获得。而 final 可见性是指：被 final 修饰的字段在构造器中一旦完成，并且构造器没有把 “this” 的引用传递出去( this 引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象)，那在其他线程中就能看见 final 字段的值。</p></blockquote><ul><li>有序性(Ordering)</li></ul><blockquote><p>如果在被线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。前半句指“线程内表现为串行的语义”，后半句是指“指令重排”现象和“工作内存与主内存同步延迟”现象。Java 语言通过 volatile 和 synchronize 两个关键字来保证线程之间操作的有序性。volatile 自身就禁止指令重排，而 synchronize 则是由“一个变量在同一时刻指允许一条线程对其进行 lock 操作”这条规则获得，这条规则决定了持有同一个锁的两个同步块只能串行的进入。</p></blockquote><h4 id="3-1-5-先行发生原则"><a href="#3-1-5-先行发生原则" class="headerlink" title="3.1.5 先行发生原则"></a>3.1.5 先行发生原则</h4><blockquote><p>也就是 happens-before 原则。这个原则是判断数据是否存在竞争、线程是否安全的主要依据。先行发生是 Java 内存模型中定义的两项操作之间的偏序关系。</p></blockquote><p>天然的先行发生关系</p><table><thead><tr><th align="center">规则</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">程序次序规则</td><td align="center">在一个线程内，代码按照书写的控制流顺序执行</td></tr><tr><td align="center">管程锁定规则</td><td align="center">一个 unlock 操作先行发生于后面对同一个锁的 lock 操作</td></tr><tr><td align="center">volatile 变量规则</td><td align="center">volatile 变量的写操作先行发生于后面对这个变量的读操作</td></tr><tr><td align="center">线程启动规则</td><td align="center">Thread 对象的 start() 方法先行发生于此线程的每一个动作线程终止规则</td></tr><tr><td align="center">线程中断规则</td><td align="center">对线程 interrupt() 方法调用优先发生于被中断线程的代码检测到中断事件的发生(通过 Thread.interrupted() 方法检测)</td></tr><tr><td align="center">对象终结规则</td><td align="center">一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始</td></tr><tr><td align="center">传递性</td><td align="center">如果操作 A 先于 操作 B 发生，操作 B 先于 操作 C 发生，那么操作 A 先于 操作 C</td></tr></tbody></table><h3 id="3-2-Java-与线程"><a href="#3-2-Java-与线程" class="headerlink" title="3.2 Java 与线程"></a>3.2 Java 与线程</h3><h4 id="3-2-1-线程的实现"><a href="#3-2-1-线程的实现" class="headerlink" title="3.2.1 线程的实现"></a>3.2.1 线程的实现</h4><p>使用内核线程实现</p><blockquote><p>直接由操作系统内核支持的线程，这种线程由内核完成切换。程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口 —— 轻量级进程(LWP)，轻量级进程就是我们通常意义上所讲的线程，每个轻量级进程都有一个内核级线程支持。</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0.jpg" alt="内核线程实现"></p><p>使用用户线程实现</p><blockquote><p>广义上来说，只要不是内核线程就可以认为是用户线程，因此可以认为轻量级进程也属于用户线程。狭义上说是完全建立在用户空间的线程库上的并且内核系统不可感知的。</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0.jpg" alt="用户线程实现"></p><p>使用用户线程夹加轻量级进程混合实现</p><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/%E6%B7%B7%E5%90%88%E5%AE%9E%E7%8E%B0.jpg" alt="混合实现"></p><p>Java 线程实现</p><blockquote><p>平台不同实现方式不同，可以认为是一条 Java 线程映射到一条轻量级进程。</p></blockquote><h4 id="3-2-2-Java-线程调度"><a href="#3-2-2-Java-线程调度" class="headerlink" title="3.2.2 Java 线程调度"></a>3.2.2 Java 线程调度</h4><p>协同式线程调度</p><blockquote><p>线程执行时间由线程自身控制，实现简单，切换线程自己可知，所以基本没有线程同步问题。坏处是执行时间不可控，容易阻塞。</p></blockquote><p>抢占式线程调度</p><blockquote><p>每个线程由系统来分配执行时间。</p></blockquote><h4 id="3-2-3-状态转换"><a href="#3-2-3-状态转换" class="headerlink" title="3.2.3 状态转换"></a>3.2.3 状态转换</h4><p>五种状态：</p><ul><li>新建(new)</li></ul><blockquote><p>创建后尚未启动的线程。</p></blockquote><ul><li>运行(Runable)</li></ul><blockquote><p>Runable 包括了操作系统线程状态中的 Running 和 Ready，也就是出于此状态的线程有可能正在执行，也有可能正在等待 CPU 为他分配时间。</p></blockquote><ul><li>无限期等待(Waiting)</li></ul><blockquote><p>出于这种状态的线程不会被 CPU 分配时间，它们要等其他线程显示的唤醒。</p></blockquote><p>以下方法会然线程进入无限期等待状态：<br>没有设置 Timeout 参数的 Object.wait() 方法。<br>没有设置 Timeout 参数的 Thread.join() 方法。<br>LookSupport.park() 方法。</p><ul><li>限期等待(Timed Waiting)</li></ul><blockquote><p>处于这种状态的线程也不会分配时间，不过无需等待配其他线程显示地唤醒，在一定时间后他们会由系统自动唤醒。</p></blockquote><p>以下方法会让线程进入限期等待状态：<br>Thread.sleep() 方法。<br>设置了 Timeout 参数的 Object.wait() 方法。<br>设置了 Timeout 参数的 Thread.join() 方法。<br>LockSupport.parkNanos() 方法。<br>LockSupport.parkUntil() 方法。</p><ul><li>阻塞(Blocked)</li></ul><blockquote><p>线程被阻塞了，“阻塞状态”和“等待状态”的区别是：“阻塞状态”在等待着获取一个排他锁，这个时间将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。</p></blockquote><ul><li>结束(Terminated)</li></ul><blockquote><p>已终止线程的线程状态。</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.jpg" alt="线程状态转换图"></p><h2 id="4-虚拟机类加载机制"><a href="#4-虚拟机类加载机制" class="headerlink" title="4. 虚拟机类加载机制"></a>4. 虚拟机类加载机制</h2><blockquote><p>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、装换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。</p></blockquote><p>在 Java 语言中，类型的加载、连接和初始化过程都是在程序运行期间完成的。</p><h3 id="4-1-类加载时机"><a href="#4-1-类加载时机" class="headerlink" title="4.1 类加载时机"></a>4.1 类加载时机</h3><p>类的生命周期( 7 个阶段)</p><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E6%97%B6%E6%9C%9F.jpg" alt="类的生命时期"></p><p>其中加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的。解析阶段可以在初始化之后再开始(运行时绑定或动态绑定或晚期绑定)。</p><p>以下五种情况必须对类进行初始化(而加载、验证、准备自然需要在此之前完成)：</p><ul><li>遇到 new、getstatic、putstatic 或 invokestatic 这 4 条字节码指令时没初始化触发初始化。使用场景：使用 new 关键字实例化对象、读取一个类的静态字段(被 final 修饰、已在编译期把结果放入常量池的静态字段除外)、调用一个类的静态方法。</li><li>使用 java.lang.reflect 包的方法对类进行反射调用的时候。</li><li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需先触发其父类的初始化。</li><li>当虚拟机启动时，用户需指定一个要加载的主类(包含 main() 方法的那个类)，虚拟机会先初始化这个主类。</li><li>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需先触发其初始化。</li></ul><p>举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SuperClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">1127</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"ConstClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD = <span class="string">"hello world!"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  output : SuperClass init!</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 通过子类引用父类的静态对象不会导致子类的初始化</span></span><br><span class="line"><span class="comment">         * 只有直接定义这个字段的类才会被初始化</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  output :</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 通过数组定义来引用类不会触发此类的初始化</span></span><br><span class="line"><span class="comment">         * 虚拟机在运行时动态创建了一个数组类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(ConstClass.HELLOWORLD);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  output :</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 常量在编译阶段会存入调用类的常量池当中，本质上并没有直接引用到定义类常量的类，</span></span><br><span class="line"><span class="comment">         * 因此不会触发定义常量的类的初始化。</span></span><br><span class="line"><span class="comment">         * “hello world” 在编译期常量传播优化时已经存储到 NotInitialization 常量池中了。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-类的加载过程"><a href="#4-2-类的加载过程" class="headerlink" title="4.2 类的加载过程"></a>4.2 类的加载过程</h3><h4 id="4-2-1-加载"><a href="#4-2-1-加载" class="headerlink" title="4.2.1 加载"></a>4.2.1 加载</h4><ul><li>通过一个类的全限定名来获取定义次类的二进制流(ZIP 包、网络、运算生成、JSP 生成、数据库读取)。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法去这个类的各种数据的访问入口。</li></ul><p>数组类的特殊性：数组类本身不通过类加载器创建，它是由 Java 虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型最终是要靠类加载器去创建的，数组创建过程如下：</p><ul><li>如果数组的组件类型是引用类型，那就递归采用类加载加载。</li><li>如果数组的组件类型不是引用类型，Java 虚拟机会把数组标记为引导类加载器关联。</li><li>数组类的可见性与他的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为 public。</li></ul><p>内存中实例的 java.lang.Class 对象存在方法区中。作为程序访问方法区中这些类型数据的外部接口。<br>加载阶段与连接阶段的部分内容是交叉进行的，但是开始时间保持先后顺序。</p><h4 id="4-2-2-验证"><a href="#4-2-2-验证" class="headerlink" title="4.2.2 验证"></a>4.2.2 验证</h4><blockquote><p>是连接的第一步，确保 Class 文件的字节流中包含的信息符合当前虚拟机要求。</p></blockquote><p>文件格式验证</p><ul><li>是否以魔数 0xCAFEBABE 开头</li><li>主、次版本号是否在当前虚拟机处理范围之内</li><li>常量池的常量是否有不被支持常量的类型（检查常量 tag 标志）</li><li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量</li><li>CONSTANT_Utf8_info 型的常量中是否有不符合 UTF8 编码的数据</li><li>Class 文件中各个部分集文件本身是否有被删除的附加的其他信息</li></ul><p>只有通过这个阶段的验证后，字节流才会进入内存的方法区进行存储，所以后面 3 个验证阶段全部是基于方法区的存储结构进行的，不再直接操作字节流。</p><p>元数据验证</p><ul><li>这个类是否有父类（除 java.lang.Object 之外）</li><li>这个类的父类是否继承了不允许被继承的类（final 修饰的类）</li><li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法</li><li>类中的字段、方法是否与父类产生矛盾（覆盖父类 final 字段、出现不符合规范的重载）</li></ul><p>这一阶段主要是对类的元数据信息进行语义校验，保证不存在不符合 Java 语言规范的元数据信息。</p><p>字节码验证</p><ul><li>保证任意时刻操作数栈的数据类型与指令代码序列都配合工作（不会出现按照 long 类型读一个 int 型数据）</li><li>保证跳转指令不会跳转到方法体以外的字节码指令上</li><li>保证方法体中的类型转换是有效的（子类对象赋值给父类数据类型是安全的，反过来不合法的）</li></ul><p>这是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。这个阶段对类的方法体进行校验分析，保证校验类的方法在运行时不会做出危害虚拟机安全的事件。</p><p>符号引用验证</p><ul><li>符号引用中通过字符创描述的全限定名是否能找到对应的类</li><li>在指定类中是否存在符方法的字段描述符以及简单名称所描述的方法和字段</li><li>符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问</li></ul><p>最后一个阶段的校验发生在迅疾将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，还有以上提及的内容。<br>符号引用的目的是确保解析动作能正常执行，如果无法通过符号引用验证将抛出一个 java.lang.IncompatibleClass.ChangeError 异常的子类。如 java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError 等。</p><h4 id="4-2-3-准备"><a href="#4-2-3-准备" class="headerlink" title="4.2.3 准备"></a>4.2.3 准备</h4><blockquote><p>这个阶段正式为类分配内存并设置类变量初始值，内存在方法去中分配(含 static 修饰的变量不含实例变量)。</p></blockquote><p>public static int value = 1127;<br>这句代码在初始值设置之后为 0，因为这时候尚未开始执行任何 Java 方法。而把 value 赋值为 1127 的 putstatic 指令是程序被编译后，存放于 clinit() 方法中，所以初始化阶段才会对 value 进行赋值。</p><p>基本数据类型的零值</p><table><thead><tr><th align="center">数据类型</th><th align="center">零值</th><th align="center">数据类型</th><th align="center">零值</th></tr></thead><tbody><tr><td align="center">int</td><td align="center">0</td><td align="center">boolean</td><td align="center">false</td></tr><tr><td align="center">long</td><td align="center">0L</td><td align="center">float</td><td align="center">0.0f</td></tr><tr><td align="center">short</td><td align="center">(short) 0</td><td align="center">double</td><td align="center">0.0d</td></tr><tr><td align="center">char</td><td align="center">‘\u0000’</td><td align="center">reference</td><td align="center">null</td></tr><tr><td align="center">byte</td><td align="center">(byte) 0</td><td align="center"></td><td align="center"></td></tr></tbody></table><p><strong>特殊情况：</strong> 如果类字段的字段属性表中存在 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 1127。</p><h4 id="4-2-4-解析"><a href="#4-2-4-解析" class="headerlink" title="4.2.4 解析"></a>4.2.4 解析</h4><blockquote><p>这个阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p></blockquote><p>符号引用<br>符号引用以一组符号来描述所引用的目标，符号可以使任何形式的字面量。<br>直接引用<br>直接引用可以使直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用和迅疾的内存布局实现有关</p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行，分别对应于常量池的 7 种常量类型。</p><h4 id="4-2-5-初始化"><a href="#4-2-5-初始化" class="headerlink" title="4.2.5 初始化"></a>4.2.5 初始化</h4><blockquote><p>前面过程都是以虚拟机主导，而初始化阶段开始执行类中的 Java 代码。</p></blockquote><h3 id="4-3-类加载器"><a href="#4-3-类加载器" class="headerlink" title="4.3 类加载器"></a>4.3 类加载器</h3><blockquote><p>通过一个类的全限定名来获取描述此类的二进制字节流。</p></blockquote><h4 id="4-3-1-双亲委派模型"><a href="#4-3-1-双亲委派模型" class="headerlink" title="4.3.1 双亲委派模型"></a>4.3.1 双亲委派模型</h4><blockquote><p>从 Java 虚拟机角度讲，只存在两种类加载器：一种是启动类加载器（C++ 实现，是虚拟机的一部分）；另一种是其他所有类的加载器（Java 实现，独立于虚拟机外部且全继承自 java.lang.ClassLoader）</p></blockquote><p>启动类加载器<br>加载 lib 下或被 -Xbootclasspath 路径下的类</p><p>扩展类加载器<br>加载 lib/ext 或者被 java.ext.dirs 系统变量所指定的路径下的类</p><p>引用程序类加载器<br>ClassLoader负责，加载用户路径上所指定的类库。</p><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.jpg" alt="类加载过程"></p><p>除顶层启动类加载器之外，其他都有自己的父类加载器。<br>工作过程：如果一个类加载器收到一个类加载的请求，它首先不会自己加载，而是把这个请求委派给父类加载器。只有父类无法完成时子类才会尝试加载。</p><h4 id="4-3-2-破坏双亲委派模型"><a href="#4-3-2-破坏双亲委派模型" class="headerlink" title="4.3.2 破坏双亲委派模型"></a>4.3.2 破坏双亲委派模型</h4><p>keyword：线程上下文加载器(Thread Context ClassLoader)</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的static关键字解析</title>
      <link href="/2019/09/23/Java%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/"/>
      <url>/2019/09/23/Java%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;static关键字是很多朋友在编写代码和阅读代码时碰到的比较难以理解的一个关键字，我打算写这边博客的起因是在牛客上刷到一道题，特别强调static关键词的重要性，使我意识到我在这方面的基础有着很大的方面欠缺，于是打算查阅资料进行补充。<br><img src="/2019/09/23/Java%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/static.png" alt="static"></p><hr><h3 id="一、static关键字的用途"><a href="#一、static关键字的用途" class="headerlink" title="一、static关键字的用途"></a>一、static关键字的用途</h3><a id="more"></a><p>&emsp;查阅资料，有这样一句话说明了static方法的的特殊之处</p><blockquote><p>“static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。”</p></blockquote><p>&emsp;可以看出static关键字的基本作用，简而言之，一句话来描述就是：</p><blockquote><p>方便在没有创建对象的情况下来进行调用（方法/变量）。</p></blockquote><p>&emsp;被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。</p><p>&emsp;static可以用来修饰类的成员方法、类的成员变量，另外可以编写static代码块来优化程序性能。</p><h4 id="（1）static方法"><a href="#（1）static方法" class="headerlink" title="（1）static方法"></a>（1）static方法</h4><p>&emsp;static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。<br>&emsp;虽然在静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法/变量的。举个简单的例子：<br><img src="/2019/09/23/Java%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F.png" alt="静态方法调用非静态成员变量"><br>&emsp;在上面的代码中，由于print2方法是独立于对象存在的，可以直接用过类名调用。假如说可以在静态方法中访问非静态方法/变量的话，那么如果在main方法中有下面一条语句：</p><p>&emsp;MyStr.print2();</p><p>&emsp;此时对象都没有，str2根本就不存在，所以就会产生矛盾了。同样对于方法也是一样，由于你无法预知在print1方法中是否访问了非静态成员变量，所以也禁止在静态成员方法中访问非静态成员方法。</p><p>&emsp;而对于非静态成员方法，它访问静态成员方法/变量显然是毫无限制的。</p><p>&emsp;因此，如果说想在不创建对象的情况下调用某个方法，就可以将这个方法设置为static。我们最常见的static方法就是main方法，至于为什么main方法必须是static的，现在就很清楚了。因为程序在执行main方法的时候没有创建任何对象，因此只有通过类名来访问。</p><h4 id="（2）static变量"><a href="#（2）static变量" class="headerlink" title="（2）static变量"></a>（2）static变量</h4><p>&emsp;static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</p><p>&emsp;static成员变量的初始化顺序按照定义的顺序进行初始化</p><h4 id="（3）static代码块"><a href="#（3）static代码块" class="headerlink" title="（3）static代码块"></a>（3）static代码块</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date birthDate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Date birthDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthDate = birthDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isBornBoomer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date startDate = Date.valueOf(<span class="string">"1997"</span>);</span><br><span class="line">        Date endDate = Date.valueOf(<span class="string">"1999"</span>);</span><br><span class="line">        <span class="keyword">return</span> birthDate.compareTo(startDate)&gt;=<span class="number">0</span> &amp;&amp; birthDate.compareTo(endDate) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isBornBoomer是用来这个人是否是1997-1999年出生的，而每次isBornBoomer被调用的时候，都会生成startDate和birthDate两个对象，造成了空间浪费，如果改成这样效率会更好：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date birthDate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Date startDate,endDate;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        startDate = Date.valueOf(<span class="string">"1997"</span>);</span><br><span class="line">        endDate = Date.valueOf(<span class="string">"1999"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Date birthDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthDate = birthDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isBornBoomer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birthDate.compareTo(startDate)&gt;=<span class="number">0</span> &amp;&amp; birthDate.compareTo(endDate) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</p><hr><h3 id="二、static关键字的误区"><a href="#二、static关键字的误区" class="headerlink" title="二、static关键字的误区"></a>二、static关键字的误区</h3><h4 id="1-static关键字会改变类中成员的访问权限吗"><a href="#1-static关键字会改变类中成员的访问权限吗" class="headerlink" title="1.static关键字会改变类中成员的访问权限吗"></a>1.static关键字会改变类中成员的访问权限吗</h4><p>比较容易java中的static与C/C++中的static关键字的功能混淆。在这里只需要记住一点：与C/C++中的static不同，Java中的static关键字不会影响到变量或者方法的作用域。在Java中能够影响到访问权限的只有private、public、protected（包括包访问权限）这几个关键字。看下面的例子就明白了：<br><img src="/2019/09/23/Java%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/static%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8D%E5%8F%AF%E6%94%B9%E5%8F%98%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90.jpg" alt="static关键字不可改变成员变量访问权限"></p><p>提示’age’ has private access in ‘person’，这说明static关键字并不会改变变量和方法的访问权限。</p><h4 id="2-能通过this访问静态成员变量吗"><a href="#2-能通过this访问静态成员变量吗" class="headerlink" title="2.能通过this访问静态成员变量吗"></a>2.能通过this访问静态成员变量吗</h4><p>虽然对于静态方法来说没有this，那么在非静态方法中能够通过this访问静态成员变量吗？先看下面的一个例子，这段代码输出的结果是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">33</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Main().printValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">3</span>;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">33</span></span><br></pre></td></tr></table></figure><p>这里面主要考察队this和static的理解。this代表什么？this代表当前对象，那么通过new Main()来调用printValue的话，当前对象就是通过new Main()生成的对象。而static变量是被对象所享有的，因此在printValue中的this.value的值毫无疑问是33。在printValue方法内部的value是局部变量，根本不可能与this关联，所以输出结果是33。在这里永远要记住一点：静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够）</p><h4 id="3-static能作用于局部变量么"><a href="#3-static能作用于局部变量么" class="headerlink" title="3.static能作用于局部变量么"></a>3.static能作用于局部变量么</h4><p>　　在C/C++中static是可以作用域局部变量的，但是在Java中切记：static是不允许用来修饰局部变量。不要问为什么，这是Java语法的规定。<br>局部变量最好不要设成静态变量，局变变量是有生命周期的，用完后JAVA很快就回收资源了。如果设成静态变量，那JAVA怎么回收被其占用的内存。</p><hr><h3 id="三、常见的笔试面试题"><a href="#三、常见的笔试面试题" class="headerlink" title="三、常见的笔试面试题"></a>三、常见的笔试面试题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"base static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"base constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">base <span class="keyword">static</span></span><br><span class="line">test <span class="keyword">static</span></span><br><span class="line">base constructor</span><br><span class="line">test constructor</span><br></pre></td></tr></table></figure><p>代码具体的执行过程，在执行开始，先要寻找到main方法，因为main方法是程序的入口，但是在执行main方法之前，必须先加载Test类，而在加载Test类的时候发现Test类继承自Base类，因此会转去先加载Base类，在加载Base类的时候，发现有static块，便执行了static块。在Base类加载完成之后，便继续加载Test类，然后发现Test类中也有static块，便执行static块。在加载完所需的类之后，便开始执行main方法。在main方法中执行new Test()的时候会先调用父类的构造器，然后再调用自身的构造器。因此，便出现了上面的输出结果。</p><hr><p>2.这段代码的输出结果是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">"Test"</span>);</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"person static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"person "</span>+str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">"MyClass"</span>);</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"myclass static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"myclass constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test <span class="keyword">static</span></span><br><span class="line">myclass <span class="keyword">static</span></span><br><span class="line">person <span class="keyword">static</span></span><br><span class="line">person Test</span><br><span class="line">test constructor</span><br><span class="line">person MyClass</span><br><span class="line">myclass constructor</span><br></pre></td></tr></table></figure><p>首先加载Test类，因此会执行Test类中的static块。接着执行new MyClass()，而MyClass类还没有被加载，因此需要加载MyClass类。在加载MyClass类的时候，发现MyClass类继承自Test类，但是由于Test类已经被加载了，所以只需要加载MyClass类，那么就会执行MyClass类的中的static块。在加载完之后，就通过构造器来生成对象。而在生成对象的时候，必须先初始化父类的成员变量，因此会执行Test中的Person person = new Person()，而Person类还没有被加载过，因此会先加载Person类并执行Person类中的static块，接着执行父类的构造器，完成了父类的初始化，然后就来初始化自身了，因此会接着执行MyClass中的Person person = new Person()，最后执行MyClass的构造器。</p><hr><p>3.这段代码的输出结果是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test static 1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test static 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test <span class="keyword">static</span> <span class="number">1</span></span><br><span class="line">test <span class="keyword">static</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>虽然在main方法中没有任何语句，但是还是会输出，原因上面已经讲述过了。另外，static块可以出现类中的任何地方（只要不是方法内部，记住，任何方法内部都不行），并且执行是按照static块的顺序执行的。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> static </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo从零开始搭建个人博客</title>
      <link href="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo+github.jpg" alt="hexo+github"></p><h3 id="1-什么是-Hexo"><a href="#1-什么是-Hexo" class="headerlink" title="1.什么是 Hexo"></a>1.什么是 Hexo</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页<br>具体参考<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">Hexo官方文档</a><br><a href="http://www.theoak.online" target="_blank" rel="noopener">Hexo博客</a></p><a id="more"></a><h3 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2.安装Git"></a>2.安装Git</h3><p>我一直不太喜欢在cmd中操作各种命令，所以挑了这个比较好使的Git, 我的是windows环境，所以下载windows版本并安装就可以了。</p><ul><li><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">下载地址</a></li><li>安装步骤：双击下载好的exe文件，一路next就好啦</li><li>安装好后，打开gitbash，查看版本：<br>命令：git version (写这篇博客的时候最新版本：2.12.2)<br><img src="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/gitVersion.jpg" alt="Git版本"></li></ul><h3 id="3-安装NodeJs"><a href="#3-安装NodeJs" class="headerlink" title="3. 安装NodeJs"></a>3. 安装NodeJs</h3><p>Hexo是基于nodeJS环境的静态博客，里面的npm工具很有用啊，所以还是老老实实把这玩意儿装了吧</p><ul><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">下载地址</a>(说明：LTS为长期支持版，Current为当前最新版)</li><li>安装步骤：反正下载好msi文件后，双击打开安装，也是一路next，不过在Custom Setup这一步记得选 Add to PATH ,这样你就不用自己去配置电脑上环境变量了，装完在按 win + r 快捷键调出运行，然后输入cmd确定，在cmd中输入path可以看到你的node是否配置在里面（环境变量），没有的话你就自由发挥吧。</li><li>查看版本：<br><img src="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/node%E7%89%88%E6%9C%AC.jpg" alt="node版本"></li></ul><h3 id="4-安装hexo"><a href="#4-安装hexo" class="headerlink" title="4. 安装hexo"></a>4. 安装hexo</h3><p>后面的东西都是在gitbash中用npm工具安装就好了。</p><ul><li><p>先创建一个文件夹（用来存放所有blog的东西），然后cd到该文件夹下。</p></li><li><p>安装hexo命令：npm i -g hexo</p></li><li><p>安装完成后，查看版本：<br><img src="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Hexo%E7%89%88%E6%9C%AC.jpg" alt="hexo版本"></p></li><li><p>初始化命令：hexo init ，初始化完成之后打开所在的文件夹可以看到以下文件：<br><img src="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.jpg" alt="目录结构"></p></li><li><p>解释一下：</p><ul><li>node_modules：是依赖包</li><li>public：存放的是生成的页面</li><li>scaffolds：命令生成文章等的模板</li><li>source：用命令创建的各种文章</li><li>themes：主题</li><li>_config.yml：整个博客的配置</li><li>db.json：source解析所得到的</li><li>package.json：项目所需模块项目的配置信息</li></ul></li><li><p>做好这些前置工作之后接下来的就是各种配置了</p></li></ul><h3 id="5-桥接到github"><a href="#5-桥接到github" class="headerlink" title="5.桥接到github"></a>5.桥接到github</h3><ul><li><p>没账号的创建账号，有账号的看下面。</p></li><li><p>创建一个repo，名称为yourname.github.io, 其中yourname是你的github名称，按照这个规则创建才有用哦，如下：<br><img src="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/github%E4%BB%93%E5%BA%93.jpg" alt="github仓库"><br><img src="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95.jpg" alt="创建方法"></p></li><li><p>回到gitbash中，配置github账户信息（YourName和YourEail都替换成你自己的github用户名和注册github使用的邮箱）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;YourName&quot;</span><br><span class="line">git config --global user.email &quot;YourEmail&quot;</span><br></pre></td></tr></table></figure></li><li><p>创建SSH<br>在gitbash中输入：ssh-keygen -t rsa -C “<a href="mailto:youremail@example.com">youremail@example.com</a>，生成ssh。然后按下图的方式找到id_rsa.pub文件的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;. ssh #检查本机已存在的ssh密钥</span><br></pre></td></tr></table></figure><p>如果提示：No such file or directory 说明你是第一次使用git。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure><p>然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：<br><img src="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E9%85%8D%E7%BD%AESSHKey.jpg" alt="配置SSHKey"><br>将刚复制的内容粘贴到key那里，title随便填，保存。</p></li></ul><h3 id="6-做到这里就快接近成功了"><a href="#6-做到这里就快接近成功了" class="headerlink" title="6.做到这里就快接近成功了"></a>6.做到这里就快接近成功了</h3><ul><li><p>用编辑器打开你的blog项目，修改_config.yml文件的一些配置(冒号之后都是有一个半角空格的)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:YourName&#x2F;YourName.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p>回到gitbash中，进入你的blog目录，分别执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server</span><br></pre></td></tr></table></figure></li></ul><p>注：hexo 3.0把服务器独立成个别模块，需要单独安装：npm i hexo-server。</p><p>打开浏览器输入：<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p><p>接着你就可以遇见天使的微笑了</p><h3 id="7-上传到github"><a href="#7-上传到github" class="headerlink" title="7. 上传到github"></a>7. 上传到github</h3><ul><li><p>先安装一波：npm install hexo-deployer-git –save（这样才能将你写好的文章部署到github服务器上并让别人浏览到）</p></li><li><p>执行命令(建议每次都按照如下步骤部署)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean #(或hexo cl)</span><br><span class="line">hexo generate #(或hexo g)</span><br><span class="line">hexo deploy #(或hexo d)部署到GitHub</span><br></pre></td></tr></table></figure><p><strong>注意</strong>deploy的过程中要输入你的username及passward。如下：<br><img src="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E9%83%A8%E7%BD%B2%E5%88%B0github.jpg" alt="部署到github"></p></li><li><p>在浏览器中输入<a href="http://yourgithubname.github.io" target="_blank" rel="noopener">http://yourgithubname.github.io</a>就可以看到你的个人博客啦，是不是很兴奋！</p></li><li><p>感觉gitbash中东西太多的时候输入clear命令清空。</p></li></ul><h3 id="8-绑定个人域名"><a href="#8-绑定个人域名" class="headerlink" title="8. 绑定个人域名"></a>8. 绑定个人域名</h3><ul><li>不想绑定的自行忽略</li><li>第一步购买域名：随便在哪个网站买一个就好了，小花是在* 阿里云购买的visugar.com, DNS也是顺道在那买的。</li><li>第二步添加CNAME：在项目的source文件夹下新建一个名为CNAME的文件，在里面添加你购买的域名，比如我添加的是visugar.com，只能添加一个哦。</li><li>到DNS中添加一条记录(域名解析)：<br><img src="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90.jpg" alt="域名解析"></li><li>其中ip地址为你的github的地址，可在cmd中ping一下就能看到(ping yourname.github.io)</li><li>接着再次部署一下，用你购买的域名打开，就可以看到你的博客啦</li></ul><h3 id="9-修改及配置主题"><a href="#9-修改及配置主题" class="headerlink" title="9. 修改及配置主题"></a>9. 修改及配置主题</h3><ul><li>hexo初始化之后默认的主题是landscape , 然后你可以去<a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo主题</a>里面找到你想要的主题。在github中搜索你要的主题名称，里面都会有该主题的如何使用的介绍，按着来就好了，反正就是改改改！我选的是icarus,看起来挺不错，至少是我喜欢的类型,简洁。<br><img src="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/icarus.jpg" alt="icarus"></li><li>在根目录下./_config.yml里theme：里配置上你需要的主题就可以了</li><li>跟该主题相关的配置在themes/icarus/_config.yml里面,然后根据你的需要在这就行了，可以修改前端的一些信息。</li><li>重新部署一下就OK啦！</li></ul><h3 id="10-常用hexo命令"><a href="#10-常用hexo命令" class="headerlink" title="10.常用hexo命令"></a>10.常用hexo命令</h3><ul><li>总结一些常用的hexo命令相信可以用到后期你还需了解些markdown语法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure><p>缩写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo n &#x3D;&#x3D; hexo new</span><br><span class="line">hexo g &#x3D;&#x3D; hexo generate</span><br><span class="line">hexo s &#x3D;&#x3D; hexo server</span><br><span class="line">hexo d &#x3D;&#x3D; hexo deploy</span><br></pre></td></tr></table></figure><p>组合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo s -g #生成并本地预览</span><br><span class="line">hexo d -g #生成并上传</span><br></pre></td></tr></table></figure><p>同时如需也可以使用&amp;&amp;组合hexo命令使用</p><p>如需了解跟多关注<a href="https://github.com/EricGerry" target="_blank" rel="noopener">github</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> git </tag>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSP简介及其与HTML的区别</title>
      <link href="/2019/08/15/JSP%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%85%B6%E4%B8%8EHTML%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/08/15/JSP%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%85%B6%E4%B8%8EHTML%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-什么是JSP"><a href="#1-什么是JSP" class="headerlink" title="1. 什么是JSP"></a>1. 什么是JSP</h3><blockquote><p>JSP全称Java Server Pages，是一种动态网页开发技术。它使用JSP标签在HTML网页中插入Java代码。标签通常以&lt;%开头以%&gt;结束。</p></blockquote><p>JSP是一种Java servlet，主要用于实现Java web应用程序的用户界面部分。网页开发者们通过结合HTML代码、XHTML代码、XML元素以及嵌入JSP操作和命令来编写JSP。</p><p><img src="/2019/08/15/JSP%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%85%B6%E4%B8%8EHTML%E7%9A%84%E5%8C%BA%E5%88%AB/Jsp.jpg" alt=" "></p><p>JSP通过网页表单获取用户输入数据、访问数据库及其他数据源，然后动态地创建网页。</p><p>JSP标签有多种功能，比如访问数据库、记录用户选择信息、访问JavaBeans组件等，还可以在不同的网页中传递控制信息和共享信息。</p><h3 id="2-什么是HTML"><a href="#2-什么是HTML" class="headerlink" title="2. 什么是HTML"></a>2. 什么是HTML</h3><blockquote><p>HTML（Hyper Text Mark-up Language ）即超文本标记语言，是 WWW 的描述语言。最通俗的说法就是一种超链接，比如收藏一个网页就是保存它的链接。</p></blockquote><p><img src="/2019/08/15/JSP%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%85%B6%E4%B8%8EHTML%E7%9A%84%E5%8C%BA%E5%88%AB/html.jpg" alt=" "></p><p>简单说：</p><ul><li>HTML 是用来描述网页的一种语言。</li><li>HTML 指的是超文本标记语言 (Hyper Text Markup Language)</li><li>HTML 不是一种编程语言，而是一种标记语言 (markup language)</li><li>标记语言是一套标记标签 (markup tag)</li><li>HTML 使用标记标签来描述网页</li></ul><h3 id="3-JSP和HTML的区别"><a href="#3-JSP和HTML的区别" class="headerlink" title="3. JSP和HTML的区别"></a>3. JSP和HTML的区别</h3><ul><li><p>HTML页面是静态页面，也就是事先由用户写好放在服务器上，固定内容，不会变，由web服务器向客户端发送，平时上网看的网页都是大部分都是基于html语言的。</p></li><li><p>JSP页面是有JSP容器执行该页面的Java代码部分然后实时生成动态页面，可动态更新页面上的内容。</p></li></ul><p><img src="/2019/08/15/JSP%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%85%B6%E4%B8%8EHTML%E7%9A%84%E5%8C%BA%E5%88%AB/change.png" alt=" "></p><blockquote><p>动态网页，是指跟静态网页相对的一种网页编程技术。动态页面的内容一般都是依靠服务器端的程序来生成的，不同人、不同时候访问页面，显示的内容都可能不同。网页设计者在写好服务器端的页面程序后，不需要手工控制，页面内容会按照页面程序的安排自动更改变换。<br>静态网页，随着html代码的生成，页面的内容和显示效果就基本上不会发生变化了，不管是谁在任何时候看到的页面内容都是一样的，一成不变，除非你修改页面代码。静态html页面文件，可以直接用本地的浏览器打开。</p></blockquote><p>总而言之：</p><ul><li><p>定义上HTML页面是静态页面可以直接运行，JSP页面是动态页它运行时需要转换成servlet</p></li><li><p>HTML能直接打开，jsp只能发布到Tomact等服务器上才能打开</p></li><li><p>html是w3c规范的一种网页书写格式，是一种统一协议语言，静态网页。我们上网看的网页都是大部分都是基于html语言的。jsp是一种基于动态语言，jsp可以实现html的所有任务。</p></li><li><p>HTML（Hypertext Markup Language）文本标记语言，它是静态页面，和JavaScript一样解释性语言，只要你有一个浏览器那么它就可以正常显示出来，而不需要指定的编译工具，只需在TXT文档中写上HTML标记就可以正常显示。</p></li><li><p>JSP（Java Server Page）是Java服务端的页面，所以它是动态的，它是需要经过JDK编译后把内容发给客户端去显示，我们都知道，Java文件编译后会产生一个class文件，最终执行的就是这个class文件。</p></li></ul><p>html和jsp的表头不一样，这个是JSP的头“ &lt;%@ page language=”java” import=”java.util.*” pageEncoding=”gbk”%&gt;”在表头中有编码格式和倒入包等。也是很好区分的，在jsp中用&lt;%%&gt;就可以写Java代码了，而html没有&lt;%%&gt;。</p><ul><li>简单说，jsp在后台通过服务器解析为相应的html，然后在供浏览器识别显示。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jsp </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给俺一首歌的时间：带你了解Git的前世今生</title>
      <link href="/2019/08/15/%E7%BB%99%E4%BF%BA%E4%B8%80%E9%A6%96%E6%AD%8C%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%9A%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3Git%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
      <url>/2019/08/15/%E7%BB%99%E4%BF%BA%E4%B8%80%E9%A6%96%E6%AD%8C%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%9A%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3Git%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2019/08/15/%E7%BB%99%E4%BF%BA%E4%B8%80%E9%A6%96%E6%AD%8C%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%9A%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3Git%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/git.jpg" alt=" "></p><h2 id="Git的诞生原由"><a href="#Git的诞生原由" class="headerlink" title="Git的诞生原由"></a>Git的诞生原由</h2><blockquote><p>Talk is cheap. Show me the code.</p></blockquote><p>这句话就出自 Linux 和 Git 的作者<strong>Linus Torvalds</strong>。</p><p>原本 Linux 内核的版本控制系统是用的 BitKeeper，然而 2005 年，BitMover 公司不再让 Linux 开发团队免费使用了。</p><p>Linus 一听，不给用了？我自己写！</p><p>于是，大佬十天之内完成了 Git 的第一个版本。</p><p>所以 Git 是一个免费的、开源的版本控制系统。</p><h2 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h2><p>版本控制其实每个人都用过，比如修改过的简历。</p><p>没错，这就是本地版本控制系统。</p><p>很明显，好处是简单，但是只能一个人在这改，无法和他人完成合作。那么以下两种主流的版本控制系统应运而生。</p><h3 id="1-集中化版本控制系统Centralized-Version-Control-Systems-CVCS"><a href="#1-集中化版本控制系统Centralized-Version-Control-Systems-CVCS" class="headerlink" title="1. 集中化版本控制系统Centralized Version Control Systems (CVCS)"></a>1. 集中化版本控制系统Centralized Version Control Systems (CVCS)</h3><p>比如：CVS, Subversion, Perforce, etc.</p><p>这种版本控制系统有一个单一的集中管理的服务器，保存所有文件的最新版本，大家可以通过连接到这台服务器上来获取或者提交文件。<br><img src="/2019/08/15/%E7%BB%99%E4%BF%BA%E4%B8%80%E9%A6%96%E6%AD%8C%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%9A%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3Git%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/%E9%9B%86%E4%B8%AD%E5%8C%96%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6.png" alt=" "></p><p>这种模式相对本地版本控制系统是有所改进的，但是缺点也很明显，如果服务器宕机，那么轻则耽误工作、重则数据丢失。于是分布式版本控制系统应运而生。</p><h3 id="2-分布式版本控制系统Distributed-Version-Control-Systems-DVCS"><a href="#2-分布式版本控制系统Distributed-Version-Control-Systems-DVCS" class="headerlink" title="2. 分布式版本控制系统Distributed Version Control Systems (DVCS)"></a>2. 分布式版本控制系统Distributed Version Control Systems (DVCS)</h3><p>比如：Git, Mercurial, Bazaar, etc.</p><p>分布式的版本控制系统会把代码仓库完整地镜像下来，这样任何一个服务器发生故障，都可以用其他的仓库来修复。</p><p>更进一步，这种模式可以更方便的和不同公司的人进行同一项目的开发，因为两个远程代码仓库可以交互，这在之前的集中式系统中是无法做到的。</p><h4 id="那么什么叫“把代码仓库完整地镜像下来”呢"><a href="#那么什么叫“把代码仓库完整地镜像下来”呢" class="headerlink" title="那么什么叫“把代码仓库完整地镜像下来”呢"></a>那么什么叫“把代码仓库完整地镜像下来”呢</h4><p>CVCS 每个版本存放的是当前版本与前一个版本的差异，因此也被称作基于差异的版本控制 (delta-based)；</p><p>Git 存储的是所有文件的一个快照 (snapshot)，如果有的文件没有修改，那就只保留一个 reference 指向之前存储的文件。</p><p>不是很好理解？那接着看吧～</p><h2 id="Git-的数据模型"><a href="#Git-的数据模型" class="headerlink" title="Git 的数据模型"></a>Git 的数据模型</h2><h3 id="1-什么是快照-snapshot-呢"><a href="#1-什么是快照-snapshot-呢" class="headerlink" title="1. 什么是快照 (snapshot) 呢"></a>1. 什么是快照 (snapshot) 呢</h3><p>首先我们来学两个 Git 中的术语：</p><ul><li>blob, 就是单个的文件；</li><li>tree, 就是一个文件夹。<br>快照则是被追踪的最顶层的树。</li></ul><p>文件夹的这么一个结构：<br><img src="/2019/08/15/%E7%BB%99%E4%BF%BA%E4%B8%80%E9%A6%96%E6%AD%8C%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%9A%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3Git%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/%E5%BF%AB%E7%85%A7.png" alt=" "></p><p>那么一个快照就是追踪的“公众号”这颗树。</p><h3 id="2-本地库的数据模型"><a href="#2-本地库的数据模型" class="headerlink" title="2. 本地库的数据模型"></a>2. 本地库的数据模型</h3><p>Git 记录了每个快照的 parent，也就是当前这个文件夹的上一个版本。</p><p>那么快照的迭代更新的过程就可以表示为一个有向无环图：</p><p><img src="/2019/08/15/%E7%BB%99%E4%BF%BA%E4%B8%80%E9%A6%96%E6%AD%8C%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%9A%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3Git%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/%E6%9C%AC%E5%9C%B0%E5%BA%93%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B.png" alt=" "></p><p>每个快照其实都对应了一次 commit，用代码来表示一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class commit &#123;</span><br><span class="line">  array&lt;commit&gt; parents</span><br><span class="line">  String author</span><br><span class="line">  String message</span><br><span class="line">  Tree snapshot</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是 Git 的数据模型。</p><p>blob, tree, snapshot 其实都一样，它们在 Git 中都是对象，都可以被引用或者被搜索，会基于它们的 SHA-1 hash 进行寻址。</p><ul><li>git cat-file -t: 查看每个 SHA-1 的类型;</li><li>git cat-file -p: 查看每个</li><li>对象的内容和简单的数据结构。<br>但是通过这个哈希值来搜索也太不方便了，毕竟这是一串 40 位的十六进制字符，就是第二部分 git log 里输出的那个编码。</li></ul><p>因此，Git 还给了一个引用 reference。</p><p>比如，我们常见的 HEAD 就是一个特殊的引用。</p><p>本地库就是由 对象 和 引用 构成的，或者叫 Repositories.</p><p>在硬盘上，Git 只存储 对象 和 引用，所有的 Git 命令都对应提交一个快照。</p><p>那有哪些常用命令呢？</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>本章分三大部分，介绍日常常用命令：</p><ul><li>本地操作</li><li>和远程库的交互</li><li>团队协作 - 分支</li></ul><h3 id="本地操作"><a href="#本地操作" class="headerlink" title="本地操作"></a>本地操作</h3><p>在学习常用命令之前，你首先需要知道的 Git 的「三个分区」和对应的文件的「三种状态」：</p><p><img src="/2019/08/15/%E7%BB%99%E4%BF%BA%E4%B8%80%E9%A6%96%E6%AD%8C%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%9A%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3Git%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/%E6%9C%AC%E5%9C%B0%E6%93%8D%E4%BD%9C.png" alt=" "></p><p><strong>工作区：</strong> 就是你本地实际写代码的地方，无论你是用 vim 直接改也好，还是在 IDE 里写，都无所谓。<br>对应的文件状态是：modified，已修改，但还没保存到数据库中。</p><p><strong>暂存区：</strong> 就是临时存放的地方。<br>对应的文件状态是：staged，Git 已经对该文件做了标记，下次提交知道要包含它。</p><p><strong>本地库：</strong> 存放本地历史版本信息。<br>对应的文件状态是：committed，文件已经安全的保存在本地数据库中。</p><h4 id="1-git-add"><a href="#1-git-add" class="headerlink" title="1. $ git add"></a>1. $ git add</h4><p>工作区改完了代码，就用 git add 提交到暂存区。</p><p>这里如果文件改动的比较多，但又不是每个都需要提交，我会设置 git ignore file，就表示这些文件不要提交，比如在 build project 的时候会自动生成的那些文件等等。</p><h4 id="2-git-commit-m-“comment”"><a href="#2-git-commit-m-“comment”" class="headerlink" title="2. $ git commit -m “comment”"></a>2. $ git commit -m “comment”</h4><p>从暂存区提交到本地库，就需要用 commit。</p><p>一般后面都会跟个 -m 加句 comment，简单说下改动的内容或者原因，我们公司大家默认也会把 Jira链接附上，这样就知道这个改动对应哪个任务。</p><p>那如果想再改，再重新 git add 即可，但是 commit 这句需要改成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$git commit --amend</span><br></pre></td></tr></table></figure><p>这样就还是一条 git log 信息。</p><h4 id="3-git-log"><a href="#3-git-log" class="headerlink" title="3. $ git log"></a>3. $ git log</h4><p>git log 可以查看到提交过的信息，从近到远显示每次 commit 的 comment 还有作者、日期等信息，比如大概长这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">commit 5abcd17dggs9s0a7a91nfsagd8ay76875afs7d6</span><br><span class="line">Author: Xiaoqi&lt;xxx@163.com&gt;</span><br><span class="line">Date: xxx xxx xxx</span><br><span class="line">改了 Test 文件</span><br></pre></td></tr></table></figure><p>commit 后面的这个编号，是每次历史记录的一个索引。比如如果需要对版本进行前进或者后退的时候，就需要用到它。</p><p>这样打印的 log 太多，更简洁的打印方式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$git log --oneline</span><br></pre></td></tr></table></figure><p>就一行打印出来了。</p><p>或者：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$git reflog</span><br></pre></td></tr></table></figure><p>更常用一些。</p><h4 id="4-git-reset"><a href="#4-git-reset" class="headerlink" title="4. $ git reset"></a>4. $ git reset</h4><p>那我们刚刚说过，如果需要前进或退回到某个版本，就用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$git reset --hard &lt;编号&gt;</span><br></pre></td></tr></table></figure><p>这样就直接跳到了这个编号对应的那个版本。</p><p>那么这个 hard 是什么意思呢？</p><p>这里有 3 个参数：hard, soft, mixed，我们一一来说一下。</p><p>回到我们最重要的这张图上来：</p><p><img src="/2019/08/15/%E7%BB%99%E4%BF%BA%E4%B8%80%E9%A6%96%E6%AD%8C%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%9A%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3Git%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/%E6%9C%AC%E5%9C%B0%E5%BA%93.png" alt=" "></p><p>刚刚说的前进或后退到某一版本，是对本地库进行的操作。</p><p>那有个问题：<br>本地库的代码跳到那个版本之后，工作区和暂存区的代码就和本地库的不同步了呀！</p><p>那这些参数就是用来控制这些是否同步的。</p><p><strong>$ git reset –hard xxx.</strong></p><p>三个区都同步，都跳到这个 xxx 的版本上。</p><p><strong>$ git reset –soft xxx.</strong></p><p>前面两个区不同步，就只有本地库跳到这个版本。</p><p><strong>$ git reset –mixed xxx.</strong></p><p>暂存区同步，工作区不动。</p><p>所以呢，用的多的就是 hard.</p><h3 id="远程交互"><a href="#远程交互" class="headerlink" title="远程交互"></a>远程交互</h3><p><img src="/2019/08/15/%E7%BB%99%E4%BF%BA%E4%B8%80%E9%A6%96%E6%AD%8C%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%9A%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3Git%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/%E8%BF%9C%E7%A8%8B%E4%BA%A4%E4%BA%92.png" alt=" "><br>和远程库的交互主要是推、拉，也就是写入和读取。</p><h4 id="5-git-push"><a href="#5-git-push" class="headerlink" title="5. $ git push"></a>5. $ git push</h4><p>写完了代码，要提交到公司的代码库里，这个过程要用 git push.</p><p>当然了，这么用会被打的。。毕竟还要 cr 呢。</p><h4 id="6-git-clone"><a href="#6-git-clone" class="headerlink" title="6. $ git clone"></a>6. $ git clone</h4><p>学习首先要 clone 整个项目到本地来，然后才能增删改查。</p><p>当然了实际工作中也没人这么用。。因为每家公司都会有自己包装的工具。不过如果是做 Github 上的开源项目，就用得上了。</p><h4 id="7-git-pull"><a href="#7-git-pull" class="headerlink" title="7. $ git pull"></a>7. $ git pull</h4><p>提交了新的代码之后，领导要审查呀，所以用 git pull 把最新的代码拉取下来瞅瞅。</p><p>实际上呢，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &#x3D; fetch + merge</span><br></pre></td></tr></table></figure><h4 id="8-git-fetch"><a href="#8-git-fetch" class="headerlink" title="8. $ git fetch"></a>8. $ git fetch</h4><p>git fetch 这个操作是将远程库的数据下载到本地库，但是工作区中的文件没有更新。</p><p><img src="/2019/08/15/%E7%BB%99%E4%BF%BA%E4%B8%80%E9%A6%96%E6%AD%8C%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%9A%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3Git%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/gitfetch.png" alt=" "></p><p>而要谈 get merge，还需要先讲下分支。</p><p>merge 是 git pull 默认的选项，合并其实还有另外一种方法：rebase，中文叫做变基。</p><h4 id="9-git-rebase"><a href="#9-git-rebase" class="headerlink" title="9. $ git rebase"></a>9. $ git rebase</h4><p>rebase 的作用更多的是来整合分叉的历史，可以将某个分支上的所有修改都移到另一分支上，就像是变了基底。</p><h3 id="分支与合并"><a href="#分支与合并" class="headerlink" title="分支与合并"></a>分支与合并</h3><p>首先来看几个关于分支的基本操作：</p><h4 id="10-查看分支"><a href="#10-查看分支" class="headerlink" title="10. 查看分支"></a>10. 查看分支</h4><p>$ git branch</p><p>类似于ls，能够列出当前所有分支。</p><p>git branch -v 能够显示更多信息。</p><h4 id="11-创建分支"><a href="#11-创建分支" class="headerlink" title="11. 创建分支"></a>11. 创建分支</h4><p>$ git branch &lt; branchName &gt;</p><h4 id="12-切换分支"><a href="#12-切换分支" class="headerlink" title="12. 切换分支"></a>12. 切换分支</h4><p>$ git checkout &lt; branchName &gt;</p><p>有了分支之后必然会有合并：</p><h4 id="13-合并分支"><a href="#13-合并分支" class="headerlink" title="13. 合并分支"></a>13. 合并分支</h4><p>$ git merge &lt; branchName &gt;</p><p>而合并时就可能会有冲突，什么时候会有冲突呢？</p><p>在同一个文件的同一个位置修改时。</p><p>因为 Git 会努力的把你们改动不同的地方合并在一起，但如果实在是在同一个地方改的，那它也没办法了，只能留给程序员去手动处理了。</p><h2 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h2><h3 id="git-help"><a href="#git-help" class="headerlink" title="git help"></a>git help</h3><p>其实我个人使用最多的是git help</p><p>真心方便又好用啊！</p><p>比如 git help pull:</p><p><img src="/2019/08/15/%E7%BB%99%E4%BF%BA%E4%B8%80%E9%A6%96%E6%AD%8C%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%9A%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3Git%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/gitHelp.png" alt=" "></p><p>先介绍了有哪些参数，然后 description 详细解释了它的工作原理，下面还有图解，有木有太香！！</p><p>不过这种方式更像是 cheatsheet，当你已经知道了这个命令、只是忘了它的用法的时候去查。</p><h3 id="Pro-Git"><a href="#Pro-Git" class="headerlink" title="Pro Git"></a>Pro Git</h3><p>Pro Git 这本书不仅讲了 Git 的基础用法、高级用法，以及最后还深入讲解了 Git 的原理，非常细致全面。</p><p>书的电子版也能在网站上直接下载。</p><p><a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">英文版</a></p><p><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">中文版</a></p><h3 id="玩游戏"><a href="#玩游戏" class="headerlink" title="玩游戏"></a>玩游戏</h3><p>Practice makes perfect!</p><p>推荐一个宝藏资源：玩游戏来练 Git</p><p><a href="https://github.com/pcottle/learnGitBranching" target="_blank" rel="noopener">项目</a></p><p><a href="https://learngitbranching.js.org/" target="_blank" rel="noopener">网址</a></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的20个Linux命令</title>
      <link href="/2019/08/14/%E5%B8%B8%E7%94%A8%E7%9A%8420%E4%B8%AALinux%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/08/14/%E5%B8%B8%E7%94%A8%E7%9A%8420%E4%B8%AALinux%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2019/08/14/%E5%B8%B8%E7%94%A8%E7%9A%8420%E4%B8%AALinux%E5%91%BD%E4%BB%A4/%E5%B8%B8%E7%94%A8%E7%9A%8420%E4%B8%AALinux%E5%91%BD%E4%BB%A4.png" alt=" "></p><h2 id="1-查看目录以及权限"><a href="#1-查看目录以及权限" class="headerlink" title="1 查看目录以及权限"></a>1 查看目录以及权限</h2><blockquote><p>在windows中，使用dir查看当前目录中文件。在Linux中使用ls(list)查看当前目录文件。</p></blockquote><p>windows中的dir，如下图所示<br><img src="/2019/08/14/%E5%B8%B8%E7%94%A8%E7%9A%8420%E4%B8%AALinux%E5%91%BD%E4%BB%A4/windows%E4%B8%AD%E7%9A%84dir.png" alt=" "></p><blockquote><p>在Linux中，通常使用ls -l列出，其中可以查看文件属性，所属用户组等较为详细的信息。下面详细解释从左到右每一列是什么意思</p></blockquote><p><img src="/2019/08/14/%E5%B8%B8%E7%94%A8%E7%9A%8420%E4%B8%AALinux%E5%91%BD%E4%BB%A4/Linux%E4%B8%ADll.png" alt=" "></p><p><strong>第一列 第一个字段：</strong> 文件类型，后面9个字符是模式，其中分为三组，每一组三个字段。第一组为所属用户权限。第二组为所属组的权限。第三组为其他用户所属权限。其中r(read)代表可读，w(write)代表可写，e(execute)代表可执行。在后面的9个字符中，如果是字母说明有相应的权限，如果为”-“代表没有权限。举一个例子</p><p>-rw-r-r–:此为普通文件，对于所属用户为可读可写不能执行，对于所属组仅仅可读，对于其他用户仅为读。</p><p><strong>第二列 硬链接数目:</strong></p><blockquote><p>硬链接允许作用之一是允许一个文件拥有多个有效路径名，从而防止误删。但是只能在同一文件系统中的文件之间进行连接，不能对目录进行创建。</p></blockquote><p>第三列是所属用户，第四列为所属组，第五列为文件大小，第六列为文件被修改的时间，最后为文件名。其中使用chown改变所属用户，chgrp改变所属组。</p><h2 id="2-nohup-no-hang-up-不要挂起的意思"><a href="#2-nohup-no-hang-up-不要挂起的意思" class="headerlink" title="2 nohup(no hang up 不要挂起的意思)"></a>2 nohup(no hang up 不要挂起的意思)</h2><blockquote><p>这也是常用后台启动程序的常用方法，如果在交互命令行中运行程序，我们很容易就终止它。在交互环境下，我们的输出一般都会直接输出到当前界面，在后台启动的时候通常会定向到文件，那通常情况是下面这个命令。</p></blockquote><p>nohup command &gt;X.file 2 &gt;&amp;1 &amp;</p><blockquote><p>其中1表示标准输出。2表示文件标准错误输出。2&gt;1&amp;即将两者合并，但是合并到哪里，就是X.file.</p></blockquote><h2 id="3-查看进程"><a href="#3-查看进程" class="headerlink" title="3 查看进程"></a>3 查看进程</h2><blockquote><p>有的时候我们需要查看进程是否已经启动或者尝试终止进程。经常使用的命令为ps -ef—列出当前正在运行的程序，那如何定位我们想要查看的进程A，这个时候使用grep，即ps -ef| grep A.</p></blockquote><h2 id="4-awk"><a href="#4-awk" class="headerlink" title="4 awk"></a>4 awk</h2><blockquote><p>如果文件是csv(a.csv)，按照”,”分割，需求为打印第一列和第二列</p></blockquote><p>awk -F “,” ‘{print 2}’ a.csv</p><blockquote><p>获取第三列最大值</p></blockquote><p>awk ‘BEGIN{max=0}{if(3}END{print max}’</p><h2 id="5-tar解压缩"><a href="#5-tar解压缩" class="headerlink" title="5 tar解压缩"></a>5 tar解压缩</h2><blockquote><p>解压缩命令</p></blockquote><p>常用参数</p><ul><li>-c:创建的tar文件</li><li>-x:解开tar文件</li><li>-t:列出tar文件中包含的文件信息</li><li>-r：附加新的文件到tar文件中</li></ul><p>常用命令组合</p><p>tar -xvf /home/a.tar  //打开tar打包文件<br>tar -zxvf /home/a.tar.gz //解压以gzip压缩的文件<br>tar -jxvf /home/a.tar.bz2 //解压以bzip压缩的文件<br>tar -cvf /home/a.tar /home 打包/home下所有文件</p><h2 id="6-scp"><a href="#6-scp" class="headerlink" title="6 scp"></a>6 scp</h2><blockquote><p>通过scp命令在多台服务器中的相互复制 传输文件。为了省下输入密码，可以设置免密登录。</p></blockquote><p>常用组合：</p><p>例子1：将A服务器中/home/a.txt 复制到B服务器的/home中</p><p>scp -r /home/a.txt root@B_ip:/home</p><h2 id="7-不敢用的命令-rm-rf"><a href="#7-不敢用的命令-rm-rf" class="headerlink" title="7 不敢用的命令 rm -rf"></a>7 不敢用的命令 rm -rf</h2><blockquote><p>保持清醒，慎用！</p></blockquote><h2 id="8-watch"><a href="#8-watch" class="headerlink" title="8 watch"></a>8 watch</h2><blockquote><p>这个命令是动态查看命令执行的结果。比如如果需要每隔一秒高亮显示网络连接数的变化情况。则 watch -n 1 -d netstat -ant</p></blockquote><p>例子：每隔一秒高亮显示http连接数的变化情况</p><p>watch -n 1 -d ‘pstree | grep http’</p><p>例子:十秒一次输出系统的平均负载</p><p>watch -n 10 ‘cat /proc/loadavg’</p><h2 id="9-df"><a href="#9-df" class="headerlink" title="9 df"></a>9 df</h2><blockquote><p>查看磁盘大小</p></blockquote><p>df -h</p><p><img src="/2019/08/14/%E5%B8%B8%E7%94%A8%E7%9A%8420%E4%B8%AALinux%E5%91%BD%E4%BB%A4/%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98%E5%A4%A7%E5%B0%8F.png" alt=" "></p><h2 id="10-tcpdump"><a href="#10-tcpdump" class="headerlink" title="10 tcpdump"></a>10 tcpdump</h2><blockquote><p>和它类似的工具在windows中是wireshark，其采用底层库winpcap/libpcap实现。采用了bpf过滤机制。下面我们看看提供的不同参数的含义。</p></blockquote><table><thead><tr><th align="center">参数名</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-n</td><td align="center">使用IP地址表示主机。使用数字表示端口</td></tr><tr><td align="center">-i</td><td align="center">指定要监听的端口。如果为”-i any”表示住区所有网卡数据包</td></tr><tr><td align="center">-v</td><td align="center">输出诸如ip数据包中的TTL更加详细的信息</td></tr><tr><td align="center">-t</td><td align="center">不打印时间戳</td></tr><tr><td align="center">-e</td><td align="center">显示以太网帧头部信息</td></tr><tr><td align="center">-c</td><td align="center">仅仅抓取指定数量的数据包</td></tr><tr><td align="center">-x</td><td align="center">按照十六进制显示数据包内容</td></tr><tr><td align="center">-X</td><td align="center">不仅仅输出-x结果还输出十六进制对应的ASCII字符</td></tr><tr><td align="center">-s</td><td align="center">设置抓包时的抓包长度</td></tr><tr><td align="center">-w</td><td align="center">将输出结果定向到某个文件，一般为pcap后缀</td></tr><tr><td align="center">-r</td><td align="center">从文件读取数据包并显示数字表示端口</td></tr><tr><td align="center">-i</td><td align="center">指定要监听的端口。如果为”-i any”表示住区所有网卡数据包</td></tr><tr><td align="center">-v</td><td align="center">输出诸如ip数据包中的TTL更加详细的信息</td></tr><tr><td align="center">-t</td><td align="center">不打印时间戳</td></tr><tr><td align="center">-e</td><td align="center">显示以太网帧头部信息</td></tr><tr><td align="center">-c</td><td align="center">仅仅抓取指定数量的数据包</td></tr><tr><td align="center">-x</td><td align="center">按照十六进制显示数据包内容</td></tr><tr><td align="center">-X</td><td align="center">不仅仅输出-x结果还输出十六进制对应的ASCII字符</td></tr><tr><td align="center">-s</td><td align="center">设置抓包时的抓包长度</td></tr><tr><td align="center">-w</td><td align="center">将输出结果定向到某个文件，一般为pcap后缀</td></tr><tr><td align="center">-r</td><td align="center">从文件读取数据包并显示</td></tr></tbody></table><p>知道了相关参数，下面看几个案例</p><table><thead><tr><th align="center">执行任务</th><th align="center">执行命令</th></tr></thead><tbody><tr><td align="center">捕获特定网口数据包</td><td align="center">tcpdump -i eth0</td></tr><tr><td align="center">捕获特定个数(1000)的包</td><td align="center">tcpdump -c 1000 -i eth0</td></tr><tr><td align="center">将捕获的包保存到文件</td><td align="center">tcpdump -w a.pcap -i eth0</td></tr><tr><td align="center">读取pcap格式的包</td><td align="center">tcpdump -r a.pcap</td></tr><tr><td align="center">增加捕获包的时间戳</td><td align="center">tcpdump -n -ttt -i eth0</td></tr><tr><td align="center">指定捕获包的协议类型</td><td align="center">tcpdump -i eth0 arp</td></tr><tr><td align="center">捕获指定端口</td><td align="center">tcpdump -i eth0 post 22</td></tr><tr><td align="center">捕获特定目标ip+port的包</td><td align="center">tcpdump -i eth0 dst address and port 22</td></tr><tr><td align="center">捕获DNS请求和响应</td><td align="center">tcpdump -i eth0 -s0 port 53</td></tr><tr><td align="center">匹配Http请求头</td><td align="center">tcpdump -s 0 -v -n -l</td></tr><tr><td align="center">将捕获的包保存到文件</td><td align="center">tcpdump -w a.pcap -i eth0</td></tr><tr><td align="center">读取pcap格式的包</td><td align="center">tcpdump -r a.pcap</td></tr><tr><td align="center">增加捕获包的时间戳</td><td align="center">tcpdump -n -ttt -i eth0</td></tr><tr><td align="center">指定捕获包的协议类型</td><td align="center">tcpdump -i eth0 arp</td></tr><tr><td align="center">捕获指定端口</td><td align="center">tcpdump -i eth0 post 22</td></tr><tr><td align="center">捕获特定目标ip+port的包</td><td align="center">tcpdump -i eth0 dst address and port 22</td></tr><tr><td align="center">捕获DNS请求和响应</td><td align="center">tcpdump -i eth0 -s0 port 53</td></tr><tr><td align="center">匹配Http请求头</td><td align="center">tcpdump -s 0 -v -n -l</td></tr></tbody></table><h2 id="11-lsof"><a href="#11-lsof" class="headerlink" title="11 lsof"></a>11 lsof</h2><blockquote><p>列出当前系统打开的文件描述符工具。可以得知感兴趣的描述符是被哪些进程使用</p></blockquote><p>同样，我们看看相关参数</p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-i</td><td align="center">显示sokcet文件描述符</td></tr><tr><td align="center">-c</td><td align="center">显示指定的命令打开的所有文件描述符</td></tr><tr><td align="center">-t</td><td align="center">仅显示打开了目标文件描述符的进程pid</td></tr></tbody></table><p>老规矩，上几个例子</p><table><thead><tr><th align="center">执行任务</th><th align="center">命令</th></tr></thead><tbody><tr><td align="center">列出所有的网络链接</td><td align="center">lsof -i</td></tr><tr><td align="center">列出所有udp的网络链接</td><td align="center">lsof -i udp</td></tr><tr><td align="center">列出谁在使用某个端口</td><td align="center">lsof -i :3306</td></tr><tr><td align="center">列出谁在使用特定的tcp端口</td><td align="center">lsof -i tcp:80</td></tr><tr><td align="center">根据文件描述范围列出文件信息</td><td align="center">lsof -d 2-3</td></tr></tbody></table><h2 id="12-nc"><a href="#12-nc" class="headerlink" title="12 nc"></a>12 nc</h2><blockquote><p>nc–&gt;“瑞士军刀”。不知大家在渗透过程中，拿了shell有没有使用nc搞点事儿。它用来快速构建网络链接。常用来调试客户端程序。</p></blockquote><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-i</td><td align="center">设置数据包传送的时间间隔</td></tr><tr><td align="center">-l</td><td align="center">以服务器方式运行。默认为客户端运行</td></tr><tr><td align="center">-k</td><td align="center">重复接受并处理某个端口上的所有链接</td></tr><tr><td align="center">-p</td><td align="center">以客户端运行时强制其使用指定端口</td></tr><tr><td align="center">-C</td><td align="center">将CR和LF两个字符作为结束符</td></tr><tr><td align="center">-u</td><td align="center">使用udp协议。默认tcp协议</td></tr><tr><td align="center">-X</td><td align="center">nc客户端余代理服务器通信时默认为socks5协议。</td></tr><tr><td align="center">-z</td><td align="center">扫描目标机器某个范围服务是否开启</td></tr></tbody></table><p>案例</p><table><thead><tr><th align="center">执行任务</th><th align="center">执行命令</th></tr></thead><tbody><tr><td align="center">扫描机器A端口号在30-40的服务</td><td align="center">nc -z A 30-40</td></tr><tr><td align="center">连接服务器A 端口号为5000</td><td align="center">nc -C A 5000</td></tr><tr><td align="center">传送文件</td><td align="center">MachineA:nc -v -n ip portE:\a.exe</td></tr></tbody></table><h2 id="13-netstat"><a href="#13-netstat" class="headerlink" title="13 netstat"></a>13 netstat</h2><blockquote><p>netstat是一个网络信息统计工具。它可以得到网卡接口上全部了解，路由表信息，网卡接口信息等。通常在网络编程中我们用它来显示TCP连接以及状态信息。</p></blockquote><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-n</td><td align="center">使用IP地址表示主机</td></tr><tr><td align="center">-a</td><td align="center">显示结果中包含监听的socket</td></tr><tr><td align="center">-t</td><td align="center">仅显示TCP连接</td></tr><tr><td align="center">-r</td><td align="center">显示路由信息</td></tr><tr><td align="center">-i</td><td align="center">显示网卡接口数据流量</td></tr><tr><td align="center">-c</td><td align="center">每隔1s输出一次</td></tr><tr><td align="center">-o</td><td align="center">显示socket定时器的信息</td></tr><tr><td align="center">-p</td><td align="center">显示socket所属的进程的PID和名字</td></tr></tbody></table><p>下面列举几个常用例子</p><table><thead><tr><th align="center">执行任务</th><th align="center">执行命令</th></tr></thead><tbody><tr><td align="center">列出所有连接</td><td align="center">netstat -a</td></tr><tr><td align="center">只列出TCP或者UDP</td><td align="center">netstat -at/netstat -au</td></tr><tr><td align="center">列出监听中的连接</td><td align="center">netstat -tnl</td></tr><tr><td align="center">获取进程名、进程号以及用户 ID</td><td align="center">nestat  -nlpt</td></tr><tr><td align="center">打印统计信息</td><td align="center">netstat -s</td></tr><tr><td align="center">netstat持续输出</td><td align="center">netstat -ct</td></tr><tr><td align="center">打印active状态的连接</td><td align="center">netstat -atnp</td></tr><tr><td align="center">查看服务是否运行(npt)</td><td align="center">netstat -aple</td></tr></tbody></table><h2 id="14-vmstat"><a href="#14-vmstat" class="headerlink" title="14 vmstat"></a>14 vmstat</h2><blockquote><p>vmstat能够实时输出系统的进程信息，内存使用，cpu使用等资源的使用情况</p></blockquote><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-f</td><td align="center">显示系统自启动以来执行的fork次数</td></tr><tr><td align="center">-s</td><td align="center">显示内存相关统计信息</td></tr><tr><td align="center">-d</td><td align="center">显示磁盘相关统计信息</td></tr><tr><td align="center">-p</td><td align="center">显示指定磁盘分区统计信息</td></tr><tr><td align="center">count</td><td align="center">采样次数。</td></tr></tbody></table><p>看一下vmstat都有哪些输出字段。</p><p><img src="/2019/08/14/%E5%B8%B8%E7%94%A8%E7%9A%8420%E4%B8%AALinux%E5%91%BD%E4%BB%A4/vmstat.png" alt=" "><br>字段名|描述<br>:-:|:-:<br>procs|r表示等待运行的而进程数目。b表示处于不可中断睡眠状态的进程数目<br>memory|swpd：使用的虚拟内存量。free：空闲内存量。buff：用作缓冲区的内存量。cache：用作缓存的内存量。<br>swap|si：从磁盘换入的内存量（/s）。so：交换到磁盘的内存量（/s）。<br>io|bi：从块设备接收的块（blocks/s）。bo：发送到块设备的块（blocks/s）。<br>system|in：每秒中断的次数，包括时钟。cs：每秒上下文切换的次数。</p><h2 id="15-mpstat"><a href="#15-mpstat" class="headerlink" title="15 mpstat"></a>15 mpstat</h2><blockquote><p>能够实时监测多处理器系统中各个cpu的使用情况。这个命令的执行需要安装sysstat，在centos中执行yum install systat就好了。</p></blockquote><p><img src="/2019/08/14/%E5%B8%B8%E7%94%A8%E7%9A%8420%E4%B8%AALinux%E5%91%BD%E4%BB%A4/mpstat.png" alt=" "></p><table><thead><tr><th align="center">字段</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">cpu</td><td align="center">表示当前条信息属于哪个cpu的数据</td></tr><tr><td align="center">%usr</td><td align="center">进程运行在用户空间所占cpu运行时间的比例</td></tr><tr><td align="center">%nice</td><td align="center">nice值为负的进程运行在用户空间的时间占cpu总运行时间的比例</td></tr><tr><td align="center">%iowait</td><td align="center">cpu等待磁盘操作的时间占cpu总运行时间的比例</td></tr><tr><td align="center">%irq</td><td align="center">cpu用于处理硬件中断时间占cpu总运行时间的比例</td></tr><tr><td align="center">%soft</td><td align="center">cpu用于处理软件中断的时间占cpu用运行时间的比例</td></tr><tr><td align="center">%steal</td><td align="center">一对虚拟cpu。当超级管理员在处理某个虚拟cpu时，另一个等待它处理完才能运行。这段等待时间表示为steal时间占总运行时间的比例</td></tr><tr><td align="center">%guest</td><td align="center">运行虚拟cpu时间占cpu总运行时间的比例</td></tr><tr><td align="center">%idle</td><td align="center">系统空闲时间占cpu总运行时间的比例</td></tr></tbody></table><h2 id="16-split"><a href="#16-split" class="headerlink" title="16 split"></a>16 split</h2><blockquote><p>将文件分割为数个。</p></blockquote><p>split -5 a.txt//将a.txt每5行分割为一个文件</p><h2 id="17-wc-c-filename"><a href="#17-wc-c-filename" class="headerlink" title="17 wc -c +filename"></a>17 wc -c +filename</h2><blockquote><p>统计文件中单词的个数。</p></blockquote><h2 id="18-more-less"><a href="#18-more-less" class="headerlink" title="18 more/less"></a>18 more/less</h2><blockquote><p>一页一页显示，通过空白键显示下一页/上一页</p></blockquote><h2 id="19-head-tail"><a href="#19-head-tail" class="headerlink" title="19 head/tail"></a>19 head/tail</h2><blockquote><p>查看某文件前几行或者后几行</p></blockquote><h2 id="20-diff"><a href="#20-diff" class="headerlink" title="20 diff"></a>20 diff</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff -c file1 file2 &#x2F;&#x2F;显示两个文件的差异</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SqlOrNoSql，看完这一篇你就懂了</title>
      <link href="/2019/07/26/SqlOrNoSql%EF%BC%8C%E7%9C%8B%E5%AE%8C%E8%BF%99%E4%B8%80%E7%AF%87%E4%BD%A0%E5%B0%B1%E6%87%82%E4%BA%86/"/>
      <url>/2019/07/26/SqlOrNoSql%EF%BC%8C%E7%9C%8B%E5%AE%8C%E8%BF%99%E4%B8%80%E7%AF%87%E4%BD%A0%E5%B0%B1%E6%87%82%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="结构化数据、非结构化数据与半结构化数据"><a href="#结构化数据、非结构化数据与半结构化数据" class="headerlink" title="结构化数据、非结构化数据与半结构化数据"></a>结构化数据、非结构化数据与半结构化数据</h2><blockquote><p>结构化数据，根据定义结构化数据指的是由二维表结构来逻辑表达和实现的数据，严格遵循数据格式与长度规范，也称作为行数据，特点为：数据以行为单位，一行数据表示一个实体的信息，每一行数据的属性是相同的。例如：</p></blockquote><table><thead><tr><th align="center">id</th><th align="center">Name</th><th align="center">age</th><th align="center">phone</th><th align="center">adress</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">张三</td><td align="center">18</td><td align="center">123</td><td align="center">北京</td></tr><tr><td align="center">2</td><td align="center">李四</td><td align="center">19</td><td align="center">234</td><td align="center">杭州</td></tr><tr><td align="center">3</td><td align="center">王五</td><td align="center">20</td><td align="center">345</td><td align="center">上海</td></tr></tbody></table><p>因此关系型数据库完美契合结构化数据的特点，关系型数据库也是关系型数据最主要的存储与管理引擎。</p><p>非结构化数据，指的是<strong>数据结构不规则或不完整，没有任何预定义的数据模型，不方便用二维逻辑表来表现的数据</strong>，例如办公文档（Word）、文本、图片、HTML、各类报表、视频音频等。</p><p>介于结构化与非结构化数据之间的数据就是半结构化数据了，它是结构化数据的一种形式，虽然<strong>不符合二维逻辑这种数据模型结构，但是包含相关标记，用来分割语义元素以及对记录和字段进行分层</strong>。常见的半结构化数据有XML和JSON，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">age</span>&gt;</span>18<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">phone</span>&gt;</span>12345<span class="tag">&lt;/<span class="name">phone</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种结构也被成为自描述的结构。</p><h2 id="以关系型数据库的方式做存储的架构演进"><a href="#以关系型数据库的方式做存储的架构演进" class="headerlink" title="以关系型数据库的方式做存储的架构演进"></a>以关系型数据库的方式做存储的架构演进</h2><p>首先，看一下使用关系型数据库的方式，企业一个系统发展的几个阶段的架构演进（由于本文写的是Sql与NoSql，因此只以存储方式作为切入点，不会涉及类似MQ、ZK这些中间件内容）：</p><p><img src="/2019/07/26/SqlOrNoSql%EF%BC%8C%E7%9C%8B%E5%AE%8C%E8%BF%99%E4%B8%80%E7%AF%87%E4%BD%A0%E5%B0%B1%E6%87%82%E4%BA%86/sql%E5%B8%B8%E7%94%A8%E6%9E%B6%E6%9E%84.png" alt=" "></p><p>阶段一：企业刚发展的阶段，最简单，一个应用服务器配一个关系型数据库，每次读写数据库。</p><p>阶段二：无论是使用MySQL还是Oracle还是别的关系型数据库，数据库通常不会先成为性能瓶颈，通常随着企业规模的扩大，一台应用服务器扛不住上游过来的流量且一台应用服务器会产生单点故障的问题，因此加应用服务器并且在流量入口使用Nginx做一层负载均衡，保证把流量均匀打到应用服务器上。</p><p>阶段三：随着企业规模的继续扩大，此时由于读写都在同一个数据库上，数据库性能出现一定的瓶颈，此时简单地做一层读写分离，每次写主库，读备库，主备库之间通过binlog同步数据，就能很大程度上解决这个阶段的数据库性能问题</p><p>阶段四：企业发展越来越好了，业务越来越大了，做了读写分离数据库压力还是越来越大，这时候怎么办呢，一台数据库扛不住，那我们就分几台吧，做分库分表，对表做垂直拆分，对库做水平拆分。以扩数据库为例，扩出两台数据库，以一定的单号（例如交易单号），以一定的规则（例如取模），交易单号对2取模为0的丢到数据库1去，交易单号对2取模为1的丢到数据库2去，通过这样的方式将写数据库的流量均分到两台数据库上。一般分库分表会使用Shard的方式，通过一个中间件，便于连接管理、数据监控且客户端无需感知数据库ip</p><h2 id="关系型数据库的优点"><a href="#关系型数据库的优点" class="headerlink" title="关系型数据库的优点"></a>关系型数据库的优点</h2><p>上面的方式，看似可以解决问题（实际上确实也能解决很多问题），正常对关系型数据库做一下读写分离 + 分库分表，支撑个1W+的读写QPS还是问题不大的。但是受限于关系型数据库本身，这套架构方案依然有着明显的不足，下面对利用关系型数据库方式做存储的方案的优点先进行一下分析，后一部分再分析一下缺点，对某个技术的优缺点的充分理解是技术选型的前提。</p><h3 id="易理解"><a href="#易理解" class="headerlink" title="易理解"></a>易理解</h3><p>　　因为行 + 列的二维表逻辑是非常贴近逻辑世界的一个概念，关系模型相对网状、层次等其他模型更加容易被理解</p><h3 id="操作方便"><a href="#操作方便" class="headerlink" title="操作方便"></a>操作方便</h3><p>　　通用的SQL语言使得操作关系型数据库非常方便，支持join等复杂查询，Sql + 二维关系是关系型数据库最无可比拟的优点，这种易用性非常贴近开发者</p><h3 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h3><p>　　支持ACID特性，可以维护数据之间的一致性，这是使用数据库非常重要的一个理由之一，例如同银行转账，张三转给李四100元钱，张三扣100元，李四加100元，而且必须同时成功或者同时失败，否则就会造成用户的资损</p><h3 id="数据稳定"><a href="#数据稳定" class="headerlink" title="数据稳定"></a>数据稳定</h3><p>　　数据持久化到磁盘，没有丢失数据风险，支持海量数据存储</p><h3 id="服务稳定"><a href="#服务稳定" class="headerlink" title="服务稳定"></a>服务稳定</h3><p>　　最常用的关系型数据库产品MySql、Oracle服务器性能卓越，服务稳定，通常很少出现宕机异常</p><h2 id="关系型数据库的缺点"><a href="#关系型数据库的缺点" class="headerlink" title="关系型数据库的缺点"></a>关系型数据库的缺点</h2><h3 id="高并发下IO压力大"><a href="#高并发下IO压力大" class="headerlink" title="高并发下IO压力大"></a>高并发下IO压力大</h3><p>　　数据按行存储，即使只针对其中某一列进行运算，也会将整行数据从存储设备中读入内存，导致IO较高</p><h3 id="为维护索引付出的代价大"><a href="#为维护索引付出的代价大" class="headerlink" title="为维护索引付出的代价大"></a>为维护索引付出的代价大</h3><p>　　为了提供丰富的查询能力，通常热点表都会有多个二级索引，一旦有了二级索引，数据的新增必然伴随着所有二级索引的新增，数据的更新也必然伴随着所有二级索引的更新，这不可避免地降低了关系型数据库的读写能力，且索引越多读写能力越差。有机会的话可以看一下自己公司的数据库，除了数据文件不可避免地占空间外，索引占的空间其实也并不少</p><h3 id="为维护数据一致性付出的代价大"><a href="#为维护数据一致性付出的代价大" class="headerlink" title="为维护数据一致性付出的代价大"></a>为维护数据一致性付出的代价大</h3><p>　　数据一致性是关系型数据库的核心，但是同样为了维护数据一致性的代价也是非常大的。我们都知道SQL标准为事务定义了不同的隔离级别，从低到高依次是读未提交、读已提交、可重复度、串行化，事务隔离级别越低，可能出现的并发异常越多，但是通常而言能提供的并发能力越强。那么为了保证事务一致性，数据库就需要提供并发控制与故障恢复两种技术，前者用于减少并发异常，后者可以在系统异常的时候保证事务与数据库状态不会被破坏。对于并发控制，其核心思想就是加锁，无论是乐观锁还是悲观锁，只要提供的隔离级别越高，那么读写性能必然越差</p><h3 id="水平扩展后带来的种种问题难处理"><a href="#水平扩展后带来的种种问题难处理" class="headerlink" title="水平扩展后带来的种种问题难处理"></a>水平扩展后带来的种种问题难处理</h3><p>　　前文提过，随着企业规模扩大，一种方式是对数据库做分库，做了分库之后，数据迁移（1个库的数据按照一定规则打到2个库中）、跨库join（订单数据里有用户数据，两条数据不在同一个库中）、分布式事务处理都是需要考虑的问题，尤其是分布式事务处理，业界当前都没有特别好的解决方案</p><h3 id="表结构扩展不方便"><a href="#表结构扩展不方便" class="headerlink" title="表结构扩展不方便"></a>表结构扩展不方便</h3><p>　　由于数据库存储的是结构化数据，因此表结构schema是固定的，扩展不方便，如果需要修改表结构，需要执行DDL（data definition language）语句修改，修改期间会导致锁表，部分服务不可用</p><h3 id="全文搜索功能弱"><a href="#全文搜索功能弱" class="headerlink" title="全文搜索功能弱"></a>全文搜索功能弱</h3><p>　　例如like “%中国真伟大%”，只能搜索到”2019年中国真伟大，爱祖国”，无法搜索到”中国真是太伟大了”这样的文本，即不具备分词能力，且like查询在”%中国真伟大”这样的搜索条件下，无法命中索引，将会导致查询效率大大降低</p><p>写了这么多，我的理解核心还是前三点，它反映出的一个问题是关系型数据库在高并发下的能力是有瓶颈的，尤其是写入/更新频繁的情况下，出现瓶颈的结果就是数据库CPU高、Sql执行慢、客户端报数据库连接池不够等错误，因此例如万人秒杀这种场景，我们绝对不可能通过数据库直接去扣减库存。</p><p>可能有人会说，数据库在高并发下的能力有瓶颈，如果公司有钱，加CPU、换固态硬盘、继续买服务器加数据库做分库不就好了，问题是这是一种性价比非常低的方式，花1000万达到的效果，换其他方式可能100万就达到了，不考虑人员、服务器投入产出比的Leader就是个不合格的Leader，且关系型数据库的方式，受限于它本身的特点，可能花了钱都未必能达到想要的效果。至于什么是花100万就能达到花1000万效果的方式呢？可以继续往下看，这就是我们要说的NoSql。</p><h2 id="结合NoSql的方式做存储的架构演进"><a href="#结合NoSql的方式做存储的架构演进" class="headerlink" title="结合NoSql的方式做存储的架构演进"></a>结合NoSql的方式做存储的架构演进</h2><p>数据库作为一种关系型数据的存储引擎，存储的是关系型数据，它有优点，同时也有明显的缺点，因此通常在企业规模不断扩大的情况下，不会一味指望通过增强数据库的能力来解决数据存储问题，而是会引入其他存储，也就是我们说的NoSql。</p><p>NoSql的全称为Not Only SQL，泛指非关系型数据库，是对关系型数据库的一种补充，特别注意补充这两个字，这意味着NoSql与关系型数据库并不是对立关系，二者各有优劣，取长补短，在合适的场景下选择合适的存储引擎才是正确的做法。</p><p>比较简单的NoSql就是缓存：</p><p><img src="/2019/07/26/SqlOrNoSql%EF%BC%8C%E7%9C%8B%E5%AE%8C%E8%BF%99%E4%B8%80%E7%AF%87%E4%BD%A0%E5%B0%B1%E6%87%82%E4%BA%86/%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98.png" alt=" "></p><p>针对那些读远多于写的数据，引入一层缓存，每次读从缓存中读取，缓存中读取不到，再去数据库中取，取完之后再写入到缓存，对数据做好失效机制通常就没有大问题了。通常来说，缓存是性能优化的第一选择也是见效最明显的方案。</p><p>但是，缓存通常都是KV型存储且容量有限（基于内存），无法解决所有问题，于是再进一步的优化，继续引入其他NoSql：</p><p><img src="/2019/07/26/SqlOrNoSql%EF%BC%8C%E7%9C%8B%E5%AE%8C%E8%BF%99%E4%B8%80%E7%AF%87%E4%BD%A0%E5%B0%B1%E6%87%82%E4%BA%86/%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98.png" alt=" "></p><p>数据库、缓存与其他NoSql并行工作，充分发挥每种NoSql的特点。当然NoSql在性能方面大大优于关系挺数据库的同时，往往也伴随着一些特性的缺失，比较常见的就是事务功能的缺失。</p><p>下面看一下常用的NoSql及他们的代表产品，并对每种NoSql的优缺点和适用场景做一下分析，便于熟悉每种NoSql的特点，方便技术选型。</p><h2 id="KV型NoSql（代表—-Redis）"><a href="#KV型NoSql（代表—-Redis）" class="headerlink" title="KV型NoSql（代表—-Redis）"></a>KV型NoSql（代表—-Redis）</h2><p>KV型NoSql顾名思义就是以键值对形式存储的非关系型数据库，是最简单、最容易理解也是大家最熟悉的一种NoSql，因此比较快地带过。Redis、MemCache是其中的代表，Redis又是KV型NoSql中应用最广泛的NoSql，KV型数据库以Redis为例，最大的优点我总结下来就两点：</p><ul><li><p>数据基于内存，读写效率高</p></li><li><p>KV型数据，时间复杂度为O(1)，查询速度快<br>因此，KV型NoSql最大的优点就是高性能，利用Redis自带的BenchMark做基准测试，TPS可达到10万的级别，性能非常强劲。同样的Redis也有所有KV型NoSql都有的比较明显的缺点：</p></li><li><p>只能根据K查V，无法根据V查K</p></li><li><p>查询方式单一，只有KV的方式，不支持条件查询，多条件查询唯一的做法就是数据冗余，但这会极大的浪费存储空间</p></li><li><p>内存是有限的，无法支持海量数据存储</p></li><li><p>同样的，由于KV型NoSql的存储是基于内存的，会有丢失数据的风险</p></li></ul><p>综上所述，KV型NoSql最合适的场景就是缓存的场景：</p><ul><li>读远多于写</li><li>读取能力强</li><li>没有持久化的需求，可以容忍数据丢失，反正丢了再查询一把写入就是了</li></ul><p>例如根据用户id查询用户信息，每次根据用户id去缓存中查询一把，查到数据直接返回，查不到去关系型数据库里面根据id查询一把数据写到缓存中去。</p><h2 id="搜索型NoSql（代表—-ElasticSearch）"><a href="#搜索型NoSql（代表—-ElasticSearch）" class="headerlink" title="搜索型NoSql（代表—-ElasticSearch）"></a>搜索型NoSql（代表—-ElasticSearch）</h2><p>传统关系型数据库主要通过索引来达到快速查询的目的，但是在全文搜索的场景下，索引是无能为力的，like查询一来无法满足所有模糊匹配需求，二来使用限制太大且使用不当容易造成慢查询，搜索型NoSql的诞生正是为了解决关系型数据库全文搜索能力较弱的问题，ElasticSearch是搜索型NoSql的代表产品。</p><p>全文搜索的原理是倒排索引，我们看一下什么是倒排索引。要说倒排索引我们先看下什么是正排索引，传统的正排索引是文档–&gt;关键字的映射，例如”Tom is my friend”这句话，会将其切分为”Tom”、”is”、”my”、”friend”四个单词，在搜索的时候对文档进行扫描，符合条件的查出来。这种方式原理非常简单，但是由于其检索效率太低，基本没什么实用价值。</p><p>倒排索引则完全相反，它是关键字–&gt;文档的映射，我用张表格展示一下就比较清楚了：</p><table><thead><tr><th align="center"></th><th align="center">Tom is Tom</th><th align="center">Tom is my friend</th><th align="center">Thank you, Betty</th><th align="center">Tom is Betty’s husband</th></tr></thead><tbody><tr><td align="center">Tom</td><td align="center">2</td><td align="center">1</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">is</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">my</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">friend</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">Thank</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">you</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">Betty</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">husband</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td></tr></tbody></table><p> 意思现在这里有四个短句：</p><ul><li>“Tom is Tom”</li><li>“Tom is my friend”</li><li>“Thank you, Betty”</li><li>“Tom is Betty’s husband”</li></ul><p>搜索引擎会根据一定的切分规则将这句话切成N个关键字，并以关键字的维度维护关键字在每个文本中的出现次数。这样下次搜索”Tom”的时候，由于Tom这个词语在”Tom is Tom”、”Tom is my friend”、”Tom is Betty’s husband”三句话中都有出现，因此这三条记录都会被检索出来，且由于”Tom is Tom”这句话中”Tom”出现了2次，因此这条记录对”Tom”这个单词的匹配度最高，最先展示。这就是搜索引擎倒排索引的基本原理，假设某个关键字在某个文档中出现，那么倒排索引中有两部分内容：</p><ul><li>文档ID</li><li>在该文档中出现的位置情况</li></ul><p>可以举一反三，搜索”Betty Tom”这两个词语也是一样，搜索引擎将”Betty Tom”切分为”Tom”、”Betty”两个单词，根据开发者指定的满足率，比如满足率=50%，那么只要记录中出现了两个单词之一的记录都会被检索出来，再按照匹配度进行展示。</p><p>搜索型NoSql以ElasticSearch为例，它的优点为：</p><ul><li>支持分词场景、全文搜索，这是区别于关系型数据库最大特点</li><li>支持条件查询，支持聚合操作，类似关系型数据库的Group By，但是功能更加强大，适合做数据分析</li><li>数据写文件无丢失风险，在集群环境下可以方便横向扩展，可承载PB级别的数据</li><li>高可用，自动发现新的或者失败的节点，重组和重新平衡数据，确保数据是安全和可访问的</li></ul><p>同样，ElasticSearch也有比较明显的缺点：</p><ul><li>性能全靠内存来顶，也是使用的时候最需要注意的点，非常吃硬件资源、吃内存，大数据量下64G + SSD基本是标配，算得上是数据库中的爱马仕了。为什么要专门提一下内存呢，因为内存这个东西是很值钱的，相同的配置多一倍内存，一个月差不多就要多花几百块钱，至于ElasticSearch内存用在什么地方，大概有如下这些：</li></ul><p>1、Indexing Buffer—-ElasticSearch基于Luence，Lucene的倒排索引是先在内存里生成，然后定期以Segment File的方式刷磁盘的，每个Segment File实际就是一个完整的倒排索引<br>2、Segment Memory—-倒排索引前面说过是基于关键字的，Lucene在4.0后会将所有关键字以FST这种数据结构的方式将所有关键字在启动的时候全量加载到内存，加快查询速度，官方建议至少留系统一半内存给Lucene<br>3、各类缓存—-Filter Cache、Field Cache、Indexing Cache等，用于提升查询分析性能，例如Filter Cache用于缓存使用过的Filter的结果集<br>4、Cluter State Buffer—-ElasticSearch被设计为每个Node都可以响应用户请求，因此每个Node的内存中都包含有一份集群状态的拷贝，一个规模很大的集群这个状态信息可能会非常大</p><ul><li>读写之间有延迟，写入的数据差不多1s样子会被读取到，这也正常，写入的时候自动加入这么多索引肯定影响性能</li><li>数据结构灵活性不高，ElasticSearch这个东西，字段一旦建立就没法修改类型了，假如建立的数据表某个字段没有加全文索引，想加上，那么只能把整个表删了再重建</li></ul><p>因此，搜索型NoSql最适用的场景就是有条件搜索尤其是全文搜索的场景，作为关系型数据库的一种替代方案。</p><p>另外，搜索型数据库还有一种特别重要的应用场景。我们可以想，一旦对数据库做了分库分表后，原来可以在单表中做的聚合操作、统计操作是否统统失效？例如我把订单表分16个库，1024张表，那么订单数据就散落在1024张表中，我想要统计昨天浙江省单笔成交金额最高的订单是哪笔如何做？我想要把昨天的所有订单按照时间排序分页展示如何做？这就是搜索型NoSql的另一大作用了，我们可以把分表之后的数据统一打在搜索型NoSql中，利用搜索型NoSql的搜索与聚合能力完成对全量数据的查询。</p><p>至于为什么把它放在KV型NoSql后面作为第二个写呢，因为通常搜索型NoSql也会作为一层前置缓存，来对关系型数据库进行保护。</p><h2 id="列式NoSql（代表—-HBase）"><a href="#列式NoSql（代表—-HBase）" class="headerlink" title="列式NoSql（代表—-HBase）"></a>列式NoSql（代表—-HBase）</h2><p>列式NoSql，大数据时代最具代表性的技术之一了，以HBase为代表。</p><p>列式NoSql是基于列式存储的，那么什么是列式存储呢，列式NoSql和关系型数据库一样都有主键的概念，区别在于关系型数据库是按照行组织的数据：</p><table><thead><tr><th align="center">id</th><th align="center">name</th><th align="center">phone</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">张三</td><td align="center">123</td></tr><tr><td align="center">2</td><td align="center">李四</td><td align="center"></td></tr></tbody></table><p>看到每行有name、phone、address三个字段，这是行式存储的方式，且可以观察id = 2的这条数据，即使phone字段没有，它也是占空间的。</p><p>列式存储完全是另一种方式，它是按每一列进行组织的数据：</p><table><thead><tr><th align="center">id</th><th align="center">name</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">张三</td></tr><tr><td align="center">2</td><td align="center">李四</td></tr></tbody></table><table><thead><tr><th align="center">id</th><th align="center">phone</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">123</td></tr></tbody></table><p>这么做有什么好处呢？大致有以下几点：</p><ul><li>查询时只有指定的列会被读取，不会读取所有列</li><li>存储上节约空间，Null值不会被存储，一列中有时候会有很多重复数据（尤其是枚举数据，性别、状态等），这类数据可压缩，行式数据库压缩率通常在3:1<del>5:1之间，列式数据库的压缩率一般在8:1</del>30:1左右</li><li>列数据被组织到一起，一次磁盘IO可以将一列数据一次性读取到内存中<br>第二点说到了数据压缩，什么意思呢，以比较常见的字典表压缩方式举例：<br><img src="/2019/07/26/SqlOrNoSql%EF%BC%8C%E7%9C%8B%E5%AE%8C%E8%BF%99%E4%B8%80%E7%AF%87%E4%BD%A0%E5%B0%B1%E6%87%82%E4%BA%86/%E9%80%9A%E8%BF%87%E5%AD%97%E5%85%B8%E8%A1%A8%E5%8E%8B%E7%BC%A9%E6%95%B0%E6%8D%AE.jpg" alt="通过字典表压缩数据"></li></ul><p>自己看图理解一下，应该就懂了。</p><p>接着继续讲讲优缺点，列式NoSql，以HBase为代表的，优点为：</p><ul><li><p>海量数据无限存储，PB级别数据随便存，底层基于HDFS（Hadoop文件系统），数据持久化</p></li><li><p>读写性能好，只要没有滥用造成数据热点，读写基本随便玩</p></li><li><p>横向扩展在关系型数据库及非关系型数据库中都是最方便的之一，只需要添加新机器就可以实现数据容量的线性增长，且可用在廉价服务器上，节省成本</p></li><li><p>本身没有单点故障，可用性高</p></li><li><p>可存储结构化或者半结构化的数据</p></li><li><p>列数理论上无限，HBase本身只对列族数量有要求，建议1~3个<br>说了这么多HBase的优点，又到了说HBase缺点的时候了：</p></li><li><p>HBase是Hadoop生态的一部分，因此它本身是一款比较重的产品，依赖很多Hadoop组件，数据规模不大没必要用，运维还是有点复杂的</p></li><li><p>KV式，不支持条件查询，或者说条件查询非常非常弱吧，HBase在Scan扫描一批数据的情况下还是提供了前缀匹配这种API的，条件查询除非定义多个RowKey做数据冗余</p></li><li><p>不支持分页查询，因为统计不了数据总数<br>因此<strong>HBase比较适用于那种KV型的且未来无法预估数据增长量的场景</strong>，另外HBase使用还是需要一定的经验，主要体现在RowKey的设计上。</p></li></ul><h2 id="文档型NoSql（代表—-MongoDB）"><a href="#文档型NoSql（代表—-MongoDB）" class="headerlink" title="文档型NoSql（代表—-MongoDB）"></a>文档型NoSql（代表—-MongoDB）</h2><p>什么是文档型NoSql呢，文档型NoSql指的是将半结构化数据存储为文档的一种NoSql，文档型NoSql通常以JSON或者XML格式存储数据，因此文档型NoSql是没有Schema的，由于没有Schema的特性，我们可以随意地存储与读取数据，因此文档型NoSql的出现是解决关系型数据库表结构扩展不方便的问题的。</p><p>MongoDB是文档型NoSql的代表产品，同时也是所有NoSql产品中的明星产品之一，因此这里以MongoDB为例。按我的理解，作为文档型NoSql，MongoDB是一款完全和关系型数据库对标的产品，就我们从存储上来看：</p><p><img src="/2019/07/26/SqlOrNoSql%EF%BC%8C%E7%9C%8B%E5%AE%8C%E8%BF%99%E4%B8%80%E7%AF%87%E4%BD%A0%E5%B0%B1%E6%87%82%E4%BA%86/MongoDB.png" alt=" "></p><p>关系型数据库是按部就班地每个字段一列存，在MongDB里面就是一个JSON字符串存储。关系型数据可以为name、phone建立索引，MongoDB使用createIndex命令一样可以为列建立索引，建立索引之后可以大大提升查询效率。其他方面而言，就大的基本概念，二者之间基本也是类似的：</p><p><img src="/2019/07/26/SqlOrNoSql%EF%BC%8C%E7%9C%8B%E5%AE%8C%E8%BF%99%E4%B8%80%E7%AF%87%E4%BD%A0%E5%B0%B1%E6%87%82%E4%BA%86/MongoDB.png" alt=" "></p><p>因此，对于MongDB，我们只要理解成一个Free-Schema的关系型数据库就完事了，它的优缺点比较一目了然，优点：</p><ul><li>没有预定义的字段，扩展字段容易</li><li>相较于关系型数据库，读写性能优越，命中二级索引的- 查询不会比关系型数据库慢，对于非索引字段的查询则是全面胜出</li></ul><p>缺点在于：</p><ul><li>不支持事务操作，虽然Mongodb4.0之后宣称支持事务，但是效果待观测</li><li>多表之间的关联查询不支持（虽然有嵌入文档的方式），join查询还是需要多次操作</li><li>空间占用较大，这个是MongDB的设计问题，空间预分配机制 + 删除数据后空间不释放，只有用db.repairDatabase()去修复才能释放</li><li>目前没发现MongoDB有关系型数据库例如MySql的Navicat这种成熟的运维工具<br>总而言之，MongDB的使用场景很大程度上可以对标关系型数据库，但是比较适合处理那些没有join、没有强一致性要求且表Schema会常变化的数据</li></ul><h2 id="总结：数据库与NoSql及各种NoSql间的对比"><a href="#总结：数据库与NoSql及各种NoSql间的对比" class="headerlink" title="总结：数据库与NoSql及各种NoSql间的对比"></a>总结：数据库与NoSql及各种NoSql间的对比</h2><p>最后一部分，做一个总结，本文归根到底是两个话题：</p><ul><li>何时选用关系型数据库，何时选用非关系型数据库</li><li>选用非关系型数据库，使用哪种非关系型数据库<br>首先是第一个话题，关系型数据库与非关系型数据库的选择，在我理解里面无非就是两点考虑：</li></ul><p><img src="/2019/07/26/SqlOrNoSql%EF%BC%8C%E7%9C%8B%E5%AE%8C%E8%BF%99%E4%B8%80%E7%AF%87%E4%BD%A0%E5%B0%B1%E6%87%82%E4%BA%86/%E5%85%B3%E7%B3%BB%E5%9E%8B%E4%B8%8E%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B.png" alt=" "></p><p>第一点，不多解释应该都理解，非关系型数据库都是通过牺牲了ACID特性来获取更高的性能的，假设两张表之间有比较强的一致性需求，那么这类数据是不适合放在非关系型数据库中的。</p><p>第二点，核心数据不走非关系型数据库，例如用户表、订单表，但是这有一个前提，就是这一类核心数据会有多种查询模式，例如用户表有ABCD四个字段，可能根据AB查，可能根据AC查，可能根据D查，假设核心数据，但是就是个KV形式，比如用户的聊天记录，那么HBase一存就完事了。</p><p>非核心数据尤其是日志、流水一类中间数据千万不要写在关系型数据库中，这一类数据通常有两个特点：</p><ul><li>写远高于读</li><li>写入量巨大</li></ul><p><img src="/2019/07/26/SqlOrNoSql%EF%BC%8C%E7%9C%8B%E5%AE%8C%E8%BF%99%E4%B8%80%E7%AF%87%E4%BD%A0%E5%B0%B1%E6%87%82%E4%BA%86/%E6%80%BB%E7%BB%93.png" alt=" "></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sql </tag>
            
            <tag> NoSql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>StackAndQueue</title>
      <link href="/2019/07/10/StackAndQueue/"/>
      <url>/2019/07/10/StackAndQueue/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2019/07/10/StackAndQueue/1.jpg" alt=" "></p><h2 id="实现一个简单的栈"><a href="#实现一个简单的栈" class="headerlink" title="实现一个简单的栈"></a>实现一个简单的栈</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        array[size] = x;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = array[size - <span class="number">1</span>];</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[size - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用链表和数组实现队列"><a href="#用链表和数组实现队列" class="headerlink" title="用链表和数组实现队列"></a>用链表和数组实现队列</h2><h3 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Node Tail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(x);</span><br><span class="line">        <span class="comment">//处理头结点为空的情况，直接插入</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = newNode;</span><br><span class="line">            Tail = newNode;</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//头结点不为空</span></span><br><span class="line">        Tail.next = newNode;</span><br><span class="line">        Tail = Tail.next;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//头结点为空直接返回null</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回头结点的val</span></span><br><span class="line">        Integer ret = head.val;</span><br><span class="line">        head = head.next;</span><br><span class="line">        <span class="comment">//处理队列里只有一个元素的情况</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//修改Tail的指向</span></span><br><span class="line">            Tail = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取队首元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判定队列为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyQueue MyQueue = <span class="keyword">new</span> MyQueue();</span><br><span class="line">        MyQueue.offer(<span class="number">1</span>);</span><br><span class="line">        MyQueue.offer(<span class="number">2</span>);</span><br><span class="line">        MyQueue.offer(<span class="number">3</span>);</span><br><span class="line">        MyQueue.offer(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">while</span> (!MyQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> curFront = MyQueue.peek();</span><br><span class="line">            System.out.print(curFront+<span class="string">"\t"</span>);</span><br><span class="line">            MyQueue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="comment">// [head, tail)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>; <span class="comment">// 队首元素的下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>; <span class="comment">// 队尾元素的下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 入队列, 如果插入成功, 返回 true, 否则返回 false</span></span><br><span class="line">    <span class="comment">//    如果队列满了, 再插入就会失败</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == data.length) &#123;</span><br><span class="line">                       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新元素放到 tail 的位置上</span></span><br><span class="line">        data[tail] = x;</span><br><span class="line">        tail++;</span><br><span class="line">        <span class="keyword">if</span> (tail == data.length) &#123;</span><br><span class="line">            tail = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 出队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Integer ret = data[head];</span><br><span class="line">        head++;</span><br><span class="line">        <span class="keyword">if</span> (head == data.length) &#123;</span><br><span class="line">            head = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 取队首元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[head];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 判定为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 取长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyQueue2 myQueue2 = <span class="keyword">new</span> MyQueue2();</span><br><span class="line">        myQueue2.offer(<span class="number">1</span>);</span><br><span class="line">        myQueue2.offer(<span class="number">2</span>);</span><br><span class="line">        myQueue2.offer(<span class="number">3</span>);</span><br><span class="line">        myQueue2.offer(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">while</span> (!myQueue2.isEmpty()) &#123;</span><br><span class="line">            Integer cur = myQueue2.peek();</span><br><span class="line">            System.out.print(cur+<span class="string">"\t"</span>);</span><br><span class="line">            myQueue2.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="括号匹配问题"><a href="#括号匹配问题" class="headerlink" title="括号匹配问题"></a>括号匹配问题</h2><ul><li>采用遇到左括号入栈</li><li>再从栈顶区出，与右括号匹配</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'['</span> || c == <span class="string">'('</span> || c == <span class="string">'&lt;'</span>) &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> top = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (top == <span class="string">'('</span> &amp;&amp; c == <span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (top == <span class="string">'&#123;'</span> &amp;&amp; c == <span class="string">'&#125;'</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (top == <span class="string">'['</span> &amp;&amp; c == <span class="string">']'</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStackBy2Queue</span> </span>&#123;</span><br><span class="line">    <span class="comment">//A始终用来入栈，B始终用来出栈</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; A = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; B = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        A.offer(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (A.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = A.removeFirst();</span><br><span class="line">            B.addLast(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = A.removeFirst();</span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; tmp = A;</span><br><span class="line">        A = B;</span><br><span class="line">        B = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (A.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = A.removeFirst();</span><br><span class="line">            B.addLast(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终要出栈的元素</span></span><br><span class="line">        <span class="keyword">int</span> ret = A.removeFirst();</span><br><span class="line">               B.addLast(ret);</span><br><span class="line">        <span class="comment">// 交换 AB</span></span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈实现队列"><a href="#栈实现队列" class="headerlink" title="栈实现队列"></a>栈实现队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueBY2Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; A=<span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; B=<span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!B.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=B.pop();</span><br><span class="line">            A.push(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        A.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.isEmpty()&amp;&amp;B.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!A.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=A.pop();</span><br><span class="line">            B.push(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.isEmpty()&amp;&amp;B.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!A.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=A.pop();</span><br><span class="line">            B.push(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> A.isEmpty()&amp;&amp;B.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; A=<span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; B=<span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        A.push(x);</span><br><span class="line">        <span class="keyword">if</span>(B.isEmpty())&#123;</span><br><span class="line">            B.push(x);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min=B.peek();</span><br><span class="line">        <span class="keyword">if</span>(x&lt;min)&#123;</span><br><span class="line">            min=x;</span><br><span class="line">        &#125;</span><br><span class="line">        B.push(min);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        A.pop();</span><br><span class="line">        B.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> B.peek();</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Stack </tag>
            
            <tag> Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见的http错误描述原因</title>
      <link href="/2019/06/14/%E5%B8%B8%E8%A7%81%E7%9A%84http%E9%94%99%E8%AF%AF%E6%8F%8F%E8%BF%B0%E5%8E%9F%E5%9B%A0/"/>
      <url>/2019/06/14/%E5%B8%B8%E8%A7%81%E7%9A%84http%E9%94%99%E8%AF%AF%E6%8F%8F%E8%BF%B0%E5%8E%9F%E5%9B%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1xx（临时响应）"><a href="#1xx（临时响应）" class="headerlink" title="1xx（临时响应）"></a>1xx（临时响应）</h2><blockquote><p>表示临时响应并需要请求者继续执行操作的状态代码</p></blockquote><table><thead><tr><th align="center">状态码</th><th align="center">返回信息</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">100</td><td align="center">（继续）</td><td align="center">请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。</td></tr><tr><td align="center">101</td><td align="center">（切换协议）</td><td align="center">请求者已要求服务器切换协议，服务器已确认并准备切换。</td></tr></tbody></table><h2 id="2xx-（成功）"><a href="#2xx-（成功）" class="headerlink" title="2xx （成功）"></a>2xx （成功）</h2><blockquote><p>表示成功处理了请求的状态代码。</p></blockquote><table><thead><tr><th align="center">状态码</th><th align="center">返回信息</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">200</td><td align="center">（成功）</td><td align="center">服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。</td></tr><tr><td align="center">201</td><td align="center">（已创建）</td><td align="center">请求成功并且服务器创建了新的资源。</td></tr><tr><td align="center">202</td><td align="center">（已接受）</td><td align="center">服务器已接受请求，但尚未处理。</td></tr><tr><td align="center">203</td><td align="center">（非授权信息）</td><td align="center">服务器已成功处理了请求，但返回的信息可能来自另一来源。</td></tr><tr><td align="center">204</td><td align="center">（无内容）</td><td align="center">服务器成功处理了请求，但没有返回任何内容。</td></tr><tr><td align="center">205</td><td align="center">（重置内容）</td><td align="center">服务器成功处理了请求，但没有返回任何内容。</td></tr><tr><td align="center">206</td><td align="center">（部分内容）</td><td align="center">服务器成功处理了部分 GET 请求。</td></tr></tbody></table><h2 id="3xx-（重定向）"><a href="#3xx-（重定向）" class="headerlink" title="3xx （重定向）"></a>3xx （重定向）</h2><blockquote><p>表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</p></blockquote><table><thead><tr><th align="center">状态码</th><th align="center">返回信息</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">300</td><td align="center">（多种选择）</td><td align="center">针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</td></tr><tr><td align="center">301</td><td align="center">（永久移动）</td><td align="center">请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</td></tr><tr><td align="center">302</td><td align="center">（临时移动）</td><td align="center">服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</td></tr><tr><td align="center">303</td><td align="center">（查看其他位置）</td><td align="center">请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</td></tr><tr><td align="center">304</td><td align="center">（未修改）</td><td align="center">自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。</td></tr><tr><td align="center">305</td><td align="center">（使用**）</td><td align="center">请求者只能使用<em>访问请求的网页。如果服务器返回此响应，还表示请求者应使用**</em>。</td></tr><tr><td align="center">307</td><td align="center">（临时重定向）</td><td align="center">服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</td></tr></tbody></table><h2 id="4xx（请求错误）"><a href="#4xx（请求错误）" class="headerlink" title="4xx（请求错误）"></a>4xx（请求错误）</h2><blockquote><p>这些状态代码表示请求可能出错，妨碍了服务器的处理。</p></blockquote><table><thead><tr><th align="center">状态码</th><th align="center">返回信息</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">400</td><td align="center">（错误请求）</td><td align="center">服务器不理解请求的语法。</td></tr><tr><td align="center">401</td><td align="center">（未授权）</td><td align="center">请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</td></tr><tr><td align="center">403</td><td align="center">（禁止）</td><td align="center">服务器拒绝请求。</td></tr><tr><td align="center">404</td><td align="center">（未找到）</td><td align="center">服务器找不到请求的网页。</td></tr><tr><td align="center">405</td><td align="center">（方法禁用）</td><td align="center">禁用请求中指定的方法。</td></tr><tr><td align="center">406</td><td align="center">（不接受）</td><td align="center">无法使用请求的内容特性响应请求的网页。</td></tr><tr><td align="center">407</td><td align="center">（需要*授权）</td><td align="center">此状态代码与 401（未授权）类似，但指定请求者应当授权使用*。</td></tr><tr><td align="center">408</td><td align="center">（请求超时）</td><td align="center">服务器等候请求时发生超时。</td></tr><tr><td align="center">409</td><td align="center">（冲突）</td><td align="center">服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。</td></tr><tr><td align="center">410</td><td align="center">（已删除）</td><td align="center">如果请求的资源已永久删除，服务器就会返回此响应。</td></tr><tr><td align="center">411</td><td align="center">（需要有效长度）</td><td align="center">服务器不接受不含有效内容长度标头字段的请求。</td></tr><tr><td align="center">412</td><td align="center">（未满足前提条件）</td><td align="center">服务器未满足请求者在请求中设置的其中一个前提条件。</td></tr><tr><td align="center">413</td><td align="center">（请求实体过大）</td><td align="center">服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</td></tr><tr><td align="center">414</td><td align="center">（请求的 URI 过长）</td><td align="center">请求的 URI（通常为网址）过长，服务器无法处理。</td></tr><tr><td align="center">415</td><td align="center">（不支持的媒体类型）</td><td align="center">请求的格式不受请求页面的支持。</td></tr><tr><td align="center">416</td><td align="center">（请求范围不符合要求）</td><td align="center">如果页面无法提供请求的范围，则服务器会返回此状态代码。</td></tr><tr><td align="center">417</td><td align="center">（未满足期望值）</td><td align="center">服务器未满足”期望”请求标头字段的要求。</td></tr></tbody></table><h2 id="5xx（服务器错误）"><a href="#5xx（服务器错误）" class="headerlink" title="5xx（服务器错误）"></a>5xx（服务器错误）</h2><blockquote><p>这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</p></blockquote><table><thead><tr><th align="center">状态码</th><th align="center">返回信息</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">500</td><td align="center">（服务器内部错误）</td><td align="center">服务器遇到错误，无法完成请求。</td></tr><tr><td align="center">501</td><td align="center">（尚未实施）</td><td align="center">服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。</td></tr><tr><td align="center">502</td><td align="center">（错误网关）</td><td align="center">服务器作为网关或***，从上游服务器收到无效响应。</td></tr><tr><td align="center">503</td><td align="center">（服务不可用）</td><td align="center">服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。</td></tr><tr><td align="center">504</td><td align="center">（网关超时）</td><td align="center">服务器作为网关或***，但是没有及时从上游服务器收到请求。</td></tr><tr><td align="center">505</td><td align="center">（HTTP 版本不受支持）</td><td align="center">服务器不支持请求中所用的 HTTP 协议版本</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Book_Manager</title>
      <link href="/2019/05/11/Book-Manager/"/>
      <url>/2019/05/11/Book-Manager/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2019/05/11/Book-Manager/BookManager.jpg" alt=" "></p><h2 id="代码实现（基于封装多态）"><a href="#代码实现（基于封装多态）" class="headerlink" title="代码实现（基于封装多态）"></a>代码实现（基于封装多态）</h2><h3 id="Book"><a href="#Book" class="headerlink" title="Book"></a>Book</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Package_BookManager.Book;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isBorrowed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">book</span><span class="params">(String name, String id, String author, <span class="keyword">int</span> price, String type, Boolean isBorrowed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.author = author;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.isBorrowed = isBorrowed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBorrowed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isBorrowed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBorrowed</span><span class="params">(<span class="keyword">boolean</span> borrowed)</span> </span>&#123;</span><br><span class="line">        isBorrowed = borrowed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"book&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", id='"</span> + id + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", author='"</span> + author + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", price="</span> + price +</span><br><span class="line">                <span class="string">", type='"</span> + type + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", isBorrowed="</span> + isBorrowed +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Package_BookManager.Book;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bookList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> book[] books=<span class="keyword">new</span> book[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">bookList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        books[<span class="number">0</span>]=<span class="keyword">new</span> book(<span class="string">"C语言"</span>,<span class="string">"001"</span>,<span class="string">"mou1"</span>,<span class="number">100</span>,<span class="string">"计算机"</span>,<span class="keyword">false</span>);</span><br><span class="line">                books[<span class="number">1</span>]=<span class="keyword">new</span> book(<span class="string">"水浒"</span>,<span class="string">"002"</span>,<span class="string">"施耐庵"</span>,<span class="number">58</span>,<span class="string">"古典名著"</span>,<span class="keyword">true</span>);</span><br><span class="line">        books[<span class="number">2</span>]=<span class="keyword">new</span> book(<span class="string">"西游记"</span>,<span class="string">"003"</span>,<span class="string">"吴承恩"</span>,<span class="number">103</span>,<span class="string">"古典名著"</span>,<span class="keyword">false</span>);</span><br><span class="line">        books[<span class="number">3</span>]=<span class="keyword">new</span> book(<span class="string">"三国"</span>,<span class="string">"004"</span>,<span class="string">"罗贯中"</span>,<span class="number">124</span>,<span class="string">"古典名著"</span>,<span class="keyword">false</span>);</span><br><span class="line">        size=<span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> book <span class="title">getBooks</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> books[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBooks</span><span class="params">(book books,<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.books[index] = books;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Operation"><a href="#Operation" class="headerlink" title="Operation"></a>Operation</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Package_BookManager.Operation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Book.bookList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Ioperation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(bookList bookList)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Package_BookManager.Operation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Book.book;</span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Book.bookList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddOperation</span> <span class="keyword">implements</span> <span class="title">Ioperation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(bookList bookList)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"新增一本书籍"</span>);</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入书名:"</span>);</span><br><span class="line">        String name = scanner.next();</span><br><span class="line">        System.out.println(<span class="string">"请输入序号:"</span>);</span><br><span class="line">        String id = scanner.next();</span><br><span class="line">        System.out.println(<span class="string">"请输入作者: "</span>);</span><br><span class="line">        String author = scanner.next();</span><br><span class="line">        System.out.println(<span class="string">"请输入价格:"</span>);</span><br><span class="line">        <span class="keyword">int</span> price = scanner.nextInt();</span><br><span class="line">        System.out.println(<span class="string">"请输入类别: "</span>);</span><br><span class="line">        String type = scanner.next();</span><br><span class="line">        book book = <span class="keyword">new</span> book(name, id,</span><br><span class="line">                author, price, type, <span class="keyword">false</span>);</span><br><span class="line">        bookList.setBooks(book, bookList.getSize());</span><br><span class="line">        bookList.setSize(bookList.getSize() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Package_BookManager.Operation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Book.book;</span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Book.bookList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BorrowOperation</span> <span class="keyword">implements</span> <span class="title">Ioperation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(bookList bookList)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"借阅书籍"</span>);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入要借阅的书号："</span>);</span><br><span class="line">        String id = sc.next();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bookList.getSize(); i++) &#123;</span><br><span class="line">            book book = bookList.getBooks(i);</span><br><span class="line">            <span class="keyword">if</span> (!book.getId().equals(id)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (book.isBorrowed()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"这本书已经被借走！"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            book.setBorrowed(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Package_BookManager.Operation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Book.book;</span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Book.bookList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelOperation</span> <span class="keyword">implements</span> <span class="title">Ioperation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(bookList bookList)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"删除书籍"</span>);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.print(<span class="string">"请输入要删除的书号："</span>);</span><br><span class="line">        String id = sc.next();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; bookList.getSize(); i++) &#123;</span><br><span class="line">            book book = bookList.getBooks(i);</span><br><span class="line">            <span class="keyword">if</span> (book.getId().equals(id)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; bookList.getSize()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"未找到要删除的书籍"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        book lastbook = bookList.getBooks(bookList.getSize() - <span class="number">1</span>);</span><br><span class="line">        bookList.setBooks(lastbook, i);</span><br><span class="line">        bookList.setSize(bookList.getSize() - <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"删除成功"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Package_BookManager.Operation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Book.bookList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExitOperation</span> <span class="keyword">implements</span> <span class="title">Ioperation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(bookList bookList)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"GoodBye!"</span>);</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Package_BookManager.Operation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Book.book;</span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Book.bookList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindOperation</span> <span class="keyword">implements</span> <span class="title">Ioperation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(bookList bookList)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"查找书籍"</span>);</span><br><span class="line">        System.out.print(<span class="string">"请输入要查找的书名："</span>);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String name = sc.next();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bookList.getSize(); i++) &#123;</span><br><span class="line">            book book = bookList.getBooks(i);</span><br><span class="line">            <span class="keyword">if</span> (book.getName().equals(name)) &#123;</span><br><span class="line">                System.out.println(book);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"未找到该书籍！"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"共计找到"</span> + count + <span class="string">"本"</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Package_BookManager.Operation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Book.bookList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintAllOperation</span> <span class="keyword">implements</span> <span class="title">Ioperation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(bookList bookList)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打印所有书籍信息"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bookList.getSize();i++)&#123;</span><br><span class="line">            System.out.println(bookList.getBooks(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"共计"</span>+bookList.getSize()+<span class="string">"本书"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Package_BookManager.Operation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Book.book;</span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Book.bookList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnOperation</span> <span class="keyword">implements</span> <span class="title">Ioperation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(bookList bookList)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"归还书籍"</span>);</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.print(<span class="string">"请输入要归还书籍的编号："</span>);</span><br><span class="line">        String id=sc.next();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bookList.getSize();i++)&#123;</span><br><span class="line">            book book=bookList.getBooks(i);</span><br><span class="line">            <span class="keyword">if</span>(!book.getId().equals(id))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!book.isBorrowed())&#123;</span><br><span class="line">                System.out.println(<span class="string">"这本书已经被归还"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            book.setBorrowed(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="User"><a href="#User" class="headerlink" title="User"></a>User</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Package_BookManager.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Book.bookList;</span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Operation.Ioperation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> Ioperation[] operations;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">menu</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> choice, bookList bookList)</span> </span>&#123;</span><br><span class="line">        operations[choice].work(bookList);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Package_BookManager.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Operation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Admin</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Admin</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        operations = <span class="keyword">new</span> Ioperation[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ExitOperation(),</span><br><span class="line">                <span class="keyword">new</span> FindOperation(),</span><br><span class="line">                <span class="keyword">new</span> AddOperation(),</span><br><span class="line">                <span class="keyword">new</span> DelOperation(),</span><br><span class="line">                <span class="keyword">new</span> PrintAllOperation(),</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">menu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"============"</span>);</span><br><span class="line">        System.out.println(<span class="string">"hello "</span> + name);</span><br><span class="line">        System.out.println(<span class="string">"1. 查找书籍"</span>);</span><br><span class="line">        System.out.println(<span class="string">"2. 增加书籍"</span>);</span><br><span class="line">        System.out.println(<span class="string">"3. 删除书籍"</span>);</span><br><span class="line">        System.out.println(<span class="string">"4. 打印所有信息"</span>);</span><br><span class="line">        System.out.println(<span class="string">"0. 退出"</span>);</span><br><span class="line">        System.out.println(<span class="string">"============"</span>);</span><br><span class="line">        System.out.println(<span class="string">"请输入您的选择: "</span>);</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> choice = scanner.nextInt();</span><br><span class="line">        <span class="keyword">return</span> choice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Package_BookManager.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Operation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalUser</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">NormalUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line"><span class="comment">// 在这里构造 operation 数组</span></span><br><span class="line">        <span class="comment">// 我们让数组中 operation 对象的顺序和菜单中的序号相匹配</span></span><br><span class="line">        operations = <span class="keyword">new</span> Ioperation[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ExitOperation(),</span><br><span class="line">                <span class="keyword">new</span> FindOperation(),</span><br><span class="line">                <span class="keyword">new</span> BorrowOperation(),</span><br><span class="line">                <span class="keyword">new</span> ReturnOperation()</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">menu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"============"</span>);</span><br><span class="line">        System.out.println(<span class="string">"hello "</span> + name);</span><br><span class="line">        System.out.println(<span class="string">"1. 查找图书"</span>);</span><br><span class="line">        System.out.println(<span class="string">"2. 借阅图书"</span>);</span><br><span class="line">        System.out.println(<span class="string">"3. 归还图书"</span>);</span><br><span class="line">        System.out.println(<span class="string">"0. 退出"</span>);</span><br><span class="line">        System.out.println(<span class="string">"============"</span>);</span><br><span class="line">        System.out.println(<span class="string">"请输入您的选择: "</span>);</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> choice = scanner.nextInt();</span><br><span class="line">        <span class="comment">// close 本质上是在关闭 System.in</span></span><br><span class="line">        <span class="comment">// 由于后面还需要用到 System.in, 此处不能盲目关闭.</span></span><br><span class="line">        <span class="comment">// scanner.close();</span></span><br><span class="line">        <span class="keyword">return</span> choice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Package_BookManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Book.bookList;</span><br><span class="line"><span class="keyword">import</span> Package_BookManager.User.Admin;</span><br><span class="line"><span class="keyword">import</span> Package_BookManager.User.NormalUser;</span><br><span class="line"><span class="keyword">import</span> Package_BookManager.User.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        bookList bookList = <span class="keyword">new</span> bookList();</span><br><span class="line">        User User = login();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> choice = User.menu();</span><br><span class="line">            User.doOperation(choice, bookList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入您的姓名:"</span>);</span><br><span class="line">        String name = scanner.next();</span><br><span class="line">        System.out.println(<span class="string">"请输入您的角色:(1 普通用户 2 管理员)"</span>);</span><br><span class="line">        <span class="keyword">int</span> role = scanner.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (role == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NormalUser(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Admin(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Java面向对象三大特性封装、继承、多态</title>
      <link href="/2019/03/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81/"/>
      <url>/2019/03/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-封装"><a href="#1-封装" class="headerlink" title="1.封装"></a>1.封装</h2><h3 id="1-1-封装的定义"><a href="#1-1-封装的定义" class="headerlink" title="1.1 封装的定义"></a>1.1 封装的定义</h3><blockquote><p>首先是抽象，把事物抽象成一个类，其次才是封装，将事物拥有的属性和动作隐藏起来，只保留特定的方法与外界联系,封装主要是因为Java有访问权限的控制。public&gt;protected（继承访问权限）&gt;package = default（包访问权限） &gt; private。封装可以保护类中的信息，只提供想要被外界访问的信息。</p></blockquote><p>Java中的访问权限控制主要分为四个级别，如下表</p><table><thead><tr><th align="center">修饰符</th><th align="center">当前类</th><th align="center">同包</th><th align="center">子类</th><th align="center">其他包</th></tr></thead><tbody><tr><td align="center">private</td><td align="center">√</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr><tr><td align="center">dufalut</td><td align="center">√</td><td align="center">√</td><td align="center">×</td><td align="center">×</td></tr><tr><td align="center">protect</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">public</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr></tbody></table><h3 id="1-2-为什么需要封装"><a href="#1-2-为什么需要封装" class="headerlink" title="1.2 为什么需要封装"></a>1.2 为什么需要封装</h3><blockquote><p>封装符合面向对象设计原则的第一条：单一性原则，一个类把自己该做的事情封装起来，而不是暴露给其他类去处理，当内部的逻辑发生变化时，外部调用不用因此而修改，他们只调用开放的接口，而不用去关心内部的实现</p></blockquote><h3 id="1-3-实现"><a href="#1-3-实现" class="headerlink" title="1.3 实现"></a>1.3 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">( <span class="keyword">int</span> age )</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//封装age的检验逻辑，而不是暴露给每个调用者去处理</span></span><br><span class="line">        <span class="keyword">if</span>( age &gt; <span class="number">120</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception( <span class="string">"Invalid value of age"</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">( String name )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-继承"><a href="#2-继承" class="headerlink" title="2. 继承"></a>2. 继承</h2><h3 id="2-1-Java的类可以分为三类"><a href="#2-1-Java的类可以分为三类" class="headerlink" title="2.1 Java的类可以分为三类"></a>2.1 Java的类可以分为三类</h3><ul><li>类：使用class定义，没有抽象方法</li><li>抽象类：使用abstract class定义，可以有也可以没有抽象方法</li><li>接口：使用interface定义，只能有抽象方法</li></ul><h3 id="2-2-在这三个类型之间存在如下关系"><a href="#2-2-在这三个类型之间存在如下关系" class="headerlink" title="2.2 在这三个类型之间存在如下关系"></a>2.2 在这三个类型之间存在如下关系</h3><ul><li>类可以extends：类、抽象类（必须实现所有抽象方法），但只能extends一个，可以implements多个接口（必须实现所有接口方法）</li><li>抽象类可以extends：类，抽象类（可全部、部分、或者完全不实现父类抽象方法），可以implements多个接口（可全部、部分、或者完全不实现接口方法）</li><li>接口可以extends多个接口</li></ul><h3 id="2-3-继承以后子类可以得到什么"><a href="#2-3-继承以后子类可以得到什么" class="headerlink" title="2.3 继承以后子类可以得到什么"></a>2.3 继承以后子类可以得到什么</h3><ul><li>子类拥有父类非private的属性和方法</li><li>子类可以添加自己的方法和属性，即对父类进行扩展</li><li>子类可以重新定义父类的方法，即多态里面的覆盖，后面会详述</li></ul><h3 id="2-4-关于构造函数"><a href="#2-4-关于构造函数" class="headerlink" title="2.4 关于构造函数"></a>2.4 关于构造函数</h3><ul><li>构造函数不能被继承，子类可以通过super()显示调用父类的构造函数</li><li>创建子类时，编译器会自动调用父类的 无参构造函数</li><li>如果父类没有定义无参构造函数，子类必须在构造函数的第一行代码使用super()显示调用</li></ul><p>类默认拥有无参构造函数，如果定义了其他有参构造函数，则无参函数失效，所以父类没有定义无参构造函数，不是指父类没有写无参构造函数。看下面的例子，父类为Human，子类为Programmer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//定义了有参构造函数，默认无参构造函数失效</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Human</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Programmer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Human</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Programmer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//如不显示调用，编译器会出现如下错误</span></span><br><span class="line">        <span class="comment">//Implicit super constructor Human() is undefined. Must explicitly invoke another constructor</span></span><br><span class="line">        <span class="keyword">super</span>( <span class="string">"x"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-为什么需要继承"><a href="#2-5-为什么需要继承" class="headerlink" title="2.5 为什么需要继承"></a>2.5 为什么需要继承</h3><blockquote><p>代码重用是一点，最重要的还是所谓想上转型，即父类的引用变量可以指向子类对象，这是Java面向对象最重要特性多态的基础</p></blockquote><h2 id="3-多态"><a href="#3-多态" class="headerlink" title="3. 多态"></a>3. 多态</h2><h3 id="3-1-在了解多态之前，首先需要知道方法的唯一性标识即什么是相同-不同的方法"><a href="#3-1-在了解多态之前，首先需要知道方法的唯一性标识即什么是相同-不同的方法" class="headerlink" title="3.1 在了解多态之前，首先需要知道方法的唯一性标识即什么是相同/不同的方法"></a>3.1 在了解多态之前，首先需要知道方法的唯一性标识即什么是相同/不同的方法</h3><ul><li>一个方法可以由：修饰符如public、static+返回值+方法名+参数+throw的异常5部分构成</li><li>其中只有方法名和参数是唯一性标识，意即只要方法名和参数相同那他们就是相同的方法</li><li>所谓参数相同，是指参数的个数，类型，顺序一致，其中任何一项不同都是不同的方法</li></ul><h3 id="3-2-何谓重载"><a href="#3-2-何谓重载" class="headerlink" title="3.2 何谓重载"></a>3.2 何谓重载</h3><ul><li>重载是指一个类里面（包括父类的方法）存在方法名相同，但是参数不一样的方法，参数不一样可以是不同的参数个数、类型或顺序</li><li>如果仅仅是修饰符、返回值、throw的异常 不同，那这是2个相同的方法，编译都通不过，更不要说重载了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重载的例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Programmer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Human</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">( String langType )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">coding</span><span class="params">( String langType, String project )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这不是重载，而是三个相同的方法，编译报错</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Programmer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Human</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">coding</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-何谓覆盖-重写"><a href="#3-3-何谓覆盖-重写" class="headerlink" title="3.3 何谓覆盖/重写"></a>3.3 何谓覆盖/重写</h3><ul><li>覆盖描述存在继承关系时子类的一种行为</li><li>子类中存在和父类相同的方法即为覆盖，何谓相同方法请牢记前面的描述，方法名和参数相同，包括参数个数、类型、顺序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">( String langType )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Programmer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Human</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//此方法为覆盖/重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">( String langType )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此方法为上面方法的重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">( String langType, String project )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-覆盖-重写的规则"><a href="#3-4-覆盖-重写的规则" class="headerlink" title="3.4 覆盖/重写的规则"></a>3.4 覆盖/重写的规则</h3><ul><li>子类不能覆盖父类private的方法，private对子类不可见，如果子类定义了一个和父类private方法相同的方法，实为新增方法</li><li>重写方法的修饰符一定要大于或等于被重写方法的修饰符(public &gt; protected &gt; default &gt; private)</li><li>重写抛出的异常需与父类相同或是父类异常的子类，或者重写方法干脆不写throws</li><li>重写方法的返回值必须与被重写方法一致，否则编译报错</li><li>静态方法不能被重写为非静态方法，否则编译出错</li></ul><h3 id="3-5-理解了上述知识点，就可以定义多态了"><a href="#3-5-理解了上述知识点，就可以定义多态了" class="headerlink" title="3.5 理解了上述知识点，就可以定义多态了"></a>3.5 理解了上述知识点，就可以定义多态了</h3><ul><li>多态可以说是“一个接口，多种实现”或者说是父类的引用变量可以指向子类的实例，被引用对象的类型决定调用谁的方法，但这个方法必须在父类中定义</li><li>多态可以分为两种类型：编译时多态（方法的重载）和运行时多态（继承时方法的重写），编译时多态很好理解，后述内容针对运行时多态</li><li>运行时多态依赖于继承、重写和向上转型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println( <span class="string">"I am Human"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承关系</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Doctor</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Human</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//方法重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println( <span class="string">"I am Doctor"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Human</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println( <span class="string">"I am Programmer"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//向上转型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Human <span class="title">humanFactory</span><span class="params">( String humanType )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( <span class="string">"doctor"</span>.equals( humanType ) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Doctor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( <span class="string">"programmer"</span>.equals( humanType ) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Programmer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Human();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String args[] )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        Human human = test.humanFactory( <span class="string">"doctor"</span> );</span><br><span class="line">        human.showName();<span class="comment">//Output:I am Doctor</span></span><br><span class="line">        human = test.humanFactory( <span class="string">"programmer"</span> );</span><br><span class="line">        human.showName();<span class="comment">//Output:I am Programmer</span></span><br><span class="line">        <span class="comment">//一个接口的方法，表现出不同的形态，意即为多态也</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-向上转型的缺憾"><a href="#3-6-向上转型的缺憾" class="headerlink" title="3.6 向上转型的缺憾"></a>3.6 向上转型的缺憾</h3><blockquote><p>只能调用父类中定义的属性和方法，对于子类中的方法和属性它就望尘莫及了，必须强转成子类类型</p></blockquote><h3 id="3-7-总结概括"><a href="#3-7-总结概括" class="headerlink" title="3.7 总结概括"></a>3.7 总结概括</h3><ul><li>当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法，但是它仍然要根据继承链中方法调用的优先级来确认方法，该优先级为：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Human fun1"</span>);</span><br><span class="line">        fun2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Human fun2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Programmer's fun1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Programmer's fun2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human human = <span class="keyword">new</span> Programmer();</span><br><span class="line">        human.fun1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Output:</span></span><br><span class="line"><span class="comment">     *  Human fun1</span></span><br><span class="line"><span class="comment">     *  Programmer's fun2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Programmer中的fun1(String name) 和Human中的fun1()，只是方法名相同但参数不一样，所以是重载关系</li><li>Programmer中的fun2()和Human中的fun2()是相同的方法，即Programmer重写了Human的fun2()方法</li><li>把Programmer的对象向上转型赋值个Human后，human.fun1()会调用父类中的fun1()方法，子类的fun1(String name)是不同的方法</li><li>在human的fun1()中又调用了fun2()方法，该方法在Programmer中被重写，实际调用的是被引用变量Programmer中的fun2()方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"func in A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"func in B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"func in B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        a.func();</span><br><span class="line">        System.out.println(<span class="string">"test A in Bar"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(C c)</span> </span>&#123;</span><br><span class="line">        c.func();</span><br><span class="line">        System.out.println(<span class="string">"test C in Bar"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Bar bar = <span class="keyword">new</span> Bar();</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        C c = <span class="keyword">new</span> C();</span><br><span class="line">        bar.test(a);</span><br><span class="line">        bar.test(b);</span><br><span class="line">        bar.test(c);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            func in A</span></span><br><span class="line"><span class="comment">            test A in Bar</span></span><br><span class="line"><span class="comment">            func in B</span></span><br><span class="line"><span class="comment">            test A in Bar</span></span><br><span class="line"><span class="comment">            func in B</span></span><br><span class="line"><span class="comment">            test C in Bar</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

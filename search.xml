<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Pycharm搭建Selenium、Python自动化环境</title>
      <link href="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/"/>
      <url>/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/python.jpg" alt="我用Python"><br><a href="https://pan.baidu.com/s/1tiwcFLKU11WpmJ4flgNjMg" target="_blank" rel="noopener">Pycharm、Python</a>下载<br>提取码：ided</p><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><h3 id="Python安装"><a href="#Python安装" class="headerlink" title="Python安装"></a>Python安装</h3><a id="more"></a><p><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/python%E4%B8%8B%E8%BD%BD%E6%89%80%E5%9C%A8%E7%9B%AE%E5%BD%95.jpg" alt="下载文件所在目录"></p><p>勾选<strong>Add Python to Path</strong>添加环境变量</p><p><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/%E5%AE%89%E8%A3%85.jpg" alt="进行安装"></p><p>点击<strong>install</strong>进行安装</p><p>验证Python和环境变量是否配置成功：</p><p>win+r 输入cmd以管理员方式运行，在dos窗口下输入python出现如下窗口则说明你就成功啦<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/%E6%9F%A5%E7%9C%8BPython.jpg" alt="查看Python"></p><hr><h3 id="安装Pycharm"><a href="#安装Pycharm" class="headerlink" title="安装Pycharm"></a>安装Pycharm</h3><p>点击安装Pycharm<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/Pycharm.jpg" alt="Pycharm"></p><p>安装好后，点击启动后，点击新建项目，配置Project Interpreter下Base interpreter中选择刚刚安装的python文件，此时创建，则pycharm的python环境搭建完成，参考图见下：<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/Pycharm%E9%85%8D%E7%BD%AE.jpg" alt="Pycharm配置"></p><p>以上pycharm中的python环境已搭建完成，我们现在开始配置selenium环境；</p><hr><h3 id="安装Selenium"><a href="#安装Selenium" class="headerlink" title="安装Selenium"></a>安装Selenium</h3><p>点击pycharm的File-Settings-Project:Pycharm-Project Interpreter，点击窗口右侧绿色的“+”按钮，搜索“selenium”，搜索后点击添加，安装OK之后，如图中所示，直接会在窗口中显示<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/Selenium%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85.jpg" alt="Selenium下载安装"></p><p>安装成功之后，就会显示在面板上，如下图：<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/selenium%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.jpg" alt="selenium安装成功"></p><p><strong><em>接下来我们就可以愉快的写我们的自动化测试代码啦！</em></strong></p><p><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/%E5%86%B2%E9%B8%AD.jpg" alt="***冲鸭！***"></p><h2 id="自动化搭建"><a href="#自动化搭建" class="headerlink" title="自动化搭建"></a>自动化搭建</h2><h3 id="确定当前浏览器版本"><a href="#确定当前浏览器版本" class="headerlink" title="确定当前浏览器版本"></a>确定当前浏览器版本</h3><p>确定好Chrome浏览器版本号，浏览器右上角三个点-帮助-关于Google Chrome，就能看到当前版本号，我的是版本是81.0.4044.113（正式版本）（64 位），确定好之后接下来我们要去找到对应的chromedirver驱动；<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/chrome%E7%89%88%E6%9C%AC.jpg" alt="Chrome版本"></p><h2 id="下载对应版本驱动chromedriver"><a href="#下载对应版本驱动chromedriver" class="headerlink" title="下载对应版本驱动chromedriver"></a>下载对应版本驱动chromedriver</h2><p>这里我们依赖淘宝的镜像下载<a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">ChromeDriver</a></p><p>注意下载的版本要一致，我们这里下载的是81.0.4044.69<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/%E4%B8%8B%E8%BD%BD%E7%9A%84chromedriver%E7%89%88%E6%9C%AC.jpg" alt="chromedriver版本"></p><p> 下载chromedriver后，将chromedriver文件放到python目录下<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/chromedriver%E5%AD%98%E6%94%BE%E7%9B%AE%E5%BD%95.jpg" alt="chromedriver存放目录"></p><h2 id="用例编写测试"><a href="#用例编写测试" class="headerlink" title="用例编写测试"></a>用例编写测试</h2><h3 id="启动pycharm，创建一个项目，File-New-Project-Location，更改位置，创建test项目"><a href="#启动pycharm，创建一个项目，File-New-Project-Location，更改位置，创建test项目" class="headerlink" title="启动pycharm，创建一个项目，File-New Project-Location，更改位置，创建test项目"></a>启动pycharm，创建一个项目，File-New Project-Location，更改位置，创建test项目</h3><p><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/testProject.jpg" alt="test"></p><h3 id="在test下创建一个python-package"><a href="#在test下创建一个python-package" class="headerlink" title="在test下创建一个python package"></a>在test下创建一个python package</h3><p>  右击test-New-Python Package，输入包名：testbag;<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/testbag.jpg" alt="testbag"></p><h3 id="包下创建一个Python文件"><a href="#包下创建一个Python文件" class="headerlink" title="包下创建一个Python文件"></a>包下创建一个Python文件</h3><p>  右击testbag-New-Python File，输入名字：testDemo<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/testDemo.jpg" alt="testDemo"></p><h3 id="写代码通过谷歌浏览器访问TheOak"><a href="#写代码通过谷歌浏览器访问TheOak" class="headerlink" title="写代码通过谷歌浏览器访问TheOak"></a>写代码通过谷歌浏览器访问<a href="http://www.theoak.online/" target="_blank" rel="noopener">TheOak</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">"http://www.theoak.online/"</span>)</span><br><span class="line">time.sleep(<span class="number">10</span>)</span><br><span class="line">driver.close()</span><br></pre></td></tr></table></figure><p>右键直接run就可以了，当浏览器能自动打开，就证明一切OK了，就像这样呀<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/TheOak.jpg" alt="TheOak"><br>以上selenium+pycharm 自动化环境搭建完成了</p><p>今天又是美好的一天，加油呀！铁铁<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/%E5%8A%A0%E6%B2%B9%E9%B8%AD%EF%BC%81.jpg" alt="加油鸭！"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pycharm </tag>
            
            <tag> Selenium </tag>
            
            <tag> Python </tag>
            
            <tag> 测试 </tag>
            
            <tag> chromdriver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java_Github_Crawler</title>
      <link href="/2020/03/21/Java-Github-Crawler/"/>
      <url>/2020/03/21/Java-Github-Crawler/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="java-github-crawler"><a href="#java-github-crawler" class="headerlink" title="java_github_crawler"></a>java_github_crawler</h2><blockquote><p>爬取Github上的一些java中的知名项目，做一个简单的类似GitHub趋势功能的程序。在awesome-java项目中可以看到很多的java开源的第三方库和框架，点进去可以看到很具体的页面后，可以看到该项目中的一些具体信息(star,fork,open_issue)，于是收集这些项目的这些属性，衡量出这一大堆项目中，哪些项目是比较活跃和流行的，最终需求，是给awesome-java这个项目中提到的所有的github上的项目按照活跃程度进行排序。形成一个类似于Github趋势的小程序。</p></blockquote><hr><h3 id="获取所有待收集信息的项目列表"><a href="#获取所有待收集信息的项目列表" class="headerlink" title="获取所有待收集信息的项目列表"></a>获取所有待收集信息的项目列表</h3><p>使用爬虫程序，获取到<a href="https://github.com/akullpp/awesome-java/blob/master/README.md" target="_blank" rel="noopener">awesome-java</a>这个页面的内容，进而知道所有项目的链接信息。<br>分析页面的结构，可以看到，入口页面中包含很多url，每个url中又有很多a标签，a标签中href属性里的url就是我们要获到的内容。</p><h4 id="如何获取页面内容：构造一个http请求发送给服务器"><a href="#如何获取页面内容：构造一个http请求发送给服务器" class="headerlink" title="如何获取页面内容：构造一个http请求发送给服务器"></a>如何获取页面内容：构造一个http请求发送给服务器</h4><p>通过<a href="https://square.github.io/okhttp/" target="_blank" rel="noopener">OkHttp</a>这个库，就能根据url获取到对应的页面的内容，内容一般是一个html页面,具体使用方法参考<a href="https://square.github.io/okhttp/" target="_blank" rel="noopener">官方文档</a>。</p><blockquote><p>OkHttp这个库是使用Kotlin(一种编程语言，和java类似，都是把代码编译生成JVM的字节码)</p></blockquote><h4 id="如何分析页面结构"><a href="#如何分析页面结构" class="headerlink" title="如何分析页面结构"></a>如何分析页面结构</h4><p>采用<a href="https://jsoup.org/" target="_blank" rel="noopener">JSoup</a>分析网页结构，JSoup是一个用于处理实际HTML的Java库。它使用HTML5最佳DOM方法和CSS选择器，为获取URL以及提取和处理数据提供了非常方便的API。，具体使用参考官方文档。</p><p>HTML是一个树形结构，JSoup中的Document对象对应着一个树形结构。树中的每个标签，就是一个Element对象，把很多标签放在一起构成的集合，就是Elements。</p><ul><li>先获取li标签得到Element对象针对这个对象再次findElementByTag(“a”)获取到a标签中的内容</li><li>JSoup支持CSS风格的选择器语法。</li></ul><hr><h3 id="遍历项目列表，依次获取到每个项目的主页信息，进一步就可以知道该项目的star-fork-open-issue"><a href="#遍历项目列表，依次获取到每个项目的主页信息，进一步就可以知道该项目的star-fork-open-issue" class="headerlink" title="遍历项目列表，依次获取到每个项目的主页信息，进一步就可以知道该项目的star fork open_issue"></a>遍历项目列表，依次获取到每个项目的主页信息，进一步就可以知道该项目的star fork open_issue</h3><h4 id="通过API来获取某个项目-仓库的相关信息"><a href="#通过API来获取某个项目-仓库的相关信息" class="headerlink" title="通过API来获取某个项目/仓库的相关信息"></a>通过API来获取某个项目/仓库的相关信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https:&#x2F;&#x2F;api.github.com&#x2F;repos&#x2F;[用户名]&#x2F;[仓库名]</span><br></pre></td></tr></table></figure><h4 id="通过JSON数据格式保存相关信息"><a href="#通过JSON数据格式保存相关信息" class="headerlink" title="通过JSON数据格式保存相关信息"></a>通过JSON数据格式保存相关信息</h4><p>Github API获取到的数据格式是JSON格式是一种非常广泛使用的数据组织格式,特点是以键值对的的方式来组织数据。基本规则: {}包裹里面包含若干个键值对.键值对和键值对之间使用,分割。键和值之间使用:分割，进而获取要爬取的关键信息(每个项目的相关指标)，以JSON格式保存。</p><p>Java中有很多第三方库帮我们解析，JSON源自于JavaScript这个语言。通过JSON来表示对象。JSON比XML好用很多。GSON google出品的一个JSON解析库。</p><hr><h3 id="把这些数据保存到数据库中"><a href="#把这些数据保存到数据库中" class="headerlink" title="把这些数据保存到数据库中"></a>把这些数据保存到数据库中</h3><h4 id="创建表结构"><a href="#创建表结构" class="headerlink" title="创建表结构"></a>创建表结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create database java_github_crawler;</span><br><span class="line">use java_github_crawler;</span><br><span class="line">create table project_table(</span><br><span class="line">    name varchar(50),url varchar(1024),</span><br><span class="line">    description varchar(1024),starCount int,</span><br><span class="line">    forkCount int, openedIssueCount int, date varchar(128)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="实现ProjectDao"><a href="#实现ProjectDao" class="headerlink" title="实现ProjectDao"></a>实现ProjectDao</h4><p>先创建Connection,再根据Connection创建PrepareStatement，通过PrepareStatement获取到ResultSet。关闭的时候,也要先关闭ResultSet,然后关闭PrepareStatement,最后关闭Connection。</p><h4 id="抓取时可能出现的问题"><a href="#抓取时可能出现的问题" class="headerlink" title="抓取时可能出现的问题"></a>抓取时可能出现的问题</h4><h5 id="1-出现异常"><a href="#1-出现异常" class="headerlink" title="1.出现异常"></a>1.出现异常</h5><p>当前这个url对应的不是一个github的项目.前面把这些不是项目的url放到一个黑名单里面了(没放干净)。我们真正应该保证的是,抓取过程中任何一个项目出现异常,不要影响到后面的抓取.用try catch把抓取的循环包裹起来。</p><h5 id="2-程序执行速度太慢了-如何进行性能优化"><a href="#2-程序执行速度太慢了-如何进行性能优化" class="headerlink" title="2.程序执行速度太慢了.如何进行性能优化"></a>2.程序执行速度太慢了.如何进行性能优化</h5><p>打印出每个环节的时间，可以看到性能最差的就是循环调用Github API这个操作是访问网络;访问的还是一个外国的服务器。<br>大量的时间都消耗在等待服务器响应上了。一次服务器的响应时间， 这基本是固定. (取决于网络环境)<br>实现批量发送的方式，有很多种方式使用多线程方式来发送数据。例如我想批量发送10个数据就创建10个线程.每个线程负责等待自己的结构</p><hr><h3 id="写一个简单网页服务器，来展示数据库中的数据-通过图表的的形式，看到一个更直观的排名效果"><a href="#写一个简单网页服务器，来展示数据库中的数据-通过图表的的形式，看到一个更直观的排名效果" class="headerlink" title="写一个简单网页服务器，来展示数据库中的数据(通过图表的的形式，看到一个更直观的排名效果)"></a>写一个简单网页服务器，来展示数据库中的数据(通过图表的的形式，看到一个更直观的排名效果)</h3><ul><li>1.扩充ProjectDao类,新增一个方法,能够按照指定日期来获取数据库中的信息</li><li>2.写一个简单的Servlet,提供-个HTTP的接口，让前端可以通过这个接口来获取到数据</li><li>3.写一个网页,在网页上获取到数据,并展示成图表EChart 百度提供的一个开源的图表组件，使用方法具体参考<br><a href="https://www.echartsjs.com/zh/tutorial.html#5%20%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8B%20ECharts" target="_blank" rel="noopener">官方文档</a><br><a href="https://www.echartsjs.com/zh/builder.html" target="_blank" rel="noopener">下载安装</a></li></ul><hr><p><a href="http://47.93.16.83:8080/java_github_crawler/index.html" target="_blank" rel="noopener">项目演示</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Github </tag>
            
            <tag> Crawler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lombok可真香！！！</title>
      <link href="/2020/03/19/Lombok%E5%8F%AF%E7%9C%9F%E9%A6%99%EF%BC%81%EF%BC%81%EF%BC%81/"/>
      <url>/2020/03/19/Lombok%E5%8F%AF%E7%9C%9F%E9%A6%99%EF%BC%81%EF%BC%81%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Lombok到底是什么"><a href="#Lombok到底是什么" class="headerlink" title="Lombok到底是什么"></a>Lombok到底是什么</h3><p>先看一下它的官网<br><img src="/2020/03/19/Lombok%E5%8F%AF%E7%9C%9F%E9%A6%99%EF%BC%81%EF%BC%81%EF%BC%81/Lombok%E5%AE%98%E7%BD%91.jpg" alt="Lombok官网"><br><strong>大致意思是</strong>：Lombok项目是一个Java库，它会自动插入您的编辑器和构建工具中，从而为您的Java增光添彩。永远不要再编写另一个getter或equals方法，带有一个注释的类将具有功能全面的生成器，自动执行日志记录变量等等。</p><p>听起来好像是挺不错吼，亲自尝试一下吧！</p><hr><h3 id="项目中引入Lombok"><a href="#项目中引入Lombok" class="headerlink" title="项目中引入Lombok"></a>项目中引入Lombok</h3><a id="more"></a><p>首先在项目的 pom.xml中引入 Lombok依赖：</p><p>如果不知道如何导入的话，可以在<a href="https://mvnrepository.com/" target="_blank" rel="noopener">MvnRepository</a>进行查找一下，是不是就很nice。<br><img src="/2020/03/19/Lombok%E5%8F%AF%E7%9C%9F%E9%A6%99%EF%BC%81%EF%BC%81%EF%BC%81/MvnRepository.jpg" alt="MvnRepository"><br>接下来你就会看到如下界面<br><img src="/2020/03/19/Lombok%E5%8F%AF%E7%9C%9F%E9%A6%99%EF%BC%81%EF%BC%81%EF%BC%81/Choose.jpg" alt="ChooseLombok"><br><strong>选择安装版本</strong><br>一般我们选择使用人数多且不是最新版本的，于是我们选择1.18.8<br><img src="/2020/03/19/Lombok%E5%8F%AF%E7%9C%9F%E9%A6%99%EF%BC%81%EF%BC%81%EF%BC%81/version.jpg" alt="version"><br>于是乎我们复制这段代码到pom.xml中引入 Lombok依赖：<br><img src="/2020/03/19/Lombok%E5%8F%AF%E7%9C%9F%E9%A6%99%EF%BC%81%EF%BC%81%EF%BC%81/%E5%AF%BC%E5%85%A5%E4%BE%9D%E8%B5%96.jpg" alt="导入依赖"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.projectlombok&#x2F;lombok --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.18.8&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>项目中导入<img src="/2020/03/19/Lombok%E5%8F%AF%E7%9C%9F%E9%A6%99%EF%BC%81%EF%BC%81%EF%BC%81/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%AF%BC%E5%85%A5.jpg" alt=" "><br>接下来就是愉快的代码环节了。</p><hr><h3 id="get-set-toString不用写了"><a href="#get-set-toString不用写了" class="headerlink" title="get/set/toString不用写了"></a>get/set/toString不用写了</h3><p>定义一个课程 Course，需要自己手动写上每个字段的 get()和 set()方法以及toString()方法，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Dao;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：Eric</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020/3/19 21:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;    <span class="comment">// 课程ID</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 课程名称</span></span><br><span class="line">    <span class="keyword">private</span> Integer score;  <span class="comment">// 课程成绩</span></span><br><span class="line">    <span class="comment">// 自己手写下面的 get/set/toString 方法！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(Integer score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Course&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", score="</span> + score +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是借助于Lombok，一切都变得优雅起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：Eric</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020/3/19 21:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> Long id;    <span class="comment">// 课程ID</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 课程名称</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> Integer score;  <span class="comment">// 课程成绩</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个注解：@Getter、@Setter和@ToString即可方便搞定。</p><hr><h3 id="new对象变得优雅了"><a href="#new对象变得优雅了" class="headerlink" title="new对象变得优雅了"></a>new对象变得优雅了</h3><p>在没有用Lombok之前，我们假如想new一个对象，我们往往会这么做（以上面的 Course类为例）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Course course = <span class="keyword">new</span> Course(); <span class="comment">//首先new一个对象</span></span><br><span class="line">      <span class="comment">//逐步去填充各个字段</span></span><br><span class="line">  course.setId(<span class="number">124l</span>);</span><br><span class="line">  course.setName(<span class="string">"javaWeb"</span>);</span><br><span class="line">  course.setScore(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>引进Lombok之后，我们只需要在 Course类上用上 @Builder注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> Long id;    <span class="comment">// 课程ID</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 课程名称</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> Integer score;  <span class="comment">// 课程成绩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则 Course类对象的创建即可使用 链式表达 的方式一行代码完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ourse course = Course.builder().id(<span class="number">123l</span>).name(<span class="string">"javaWeb"</span>).score(<span class="number">100</span>).build();</span><br></pre></td></tr></table></figure><p>Builder注解就是一个典型的“建造者模式”的实现案例</p><hr><h3 id="构造函数不用写了"><a href="#构造函数不用写了" class="headerlink" title="构造函数不用写了"></a>构造函数不用写了</h3><p>1、全参构造器不用写了</p><p>当你在你的类上使用了Lombok的注解 AllArgsConstructor时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：Eric</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020/3/19 21:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;    <span class="comment">// 课程ID</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 课程名称</span></span><br><span class="line">    <span class="keyword">private</span> Integer score;  <span class="comment">// 课程成绩</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候你的类在编译后会自动生成一个无参构造函数，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：Eric</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020/3/19 21:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;    <span class="comment">// 课程ID</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 课程名称</span></span><br><span class="line">    <span class="keyword">private</span> Integer score;  <span class="comment">// 课程成绩</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Course</span><span class="params">(Long id, String name, Integer score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、无参数构造器也不用写了</p><p>当你在你的类上使用了Lombok的注解 NoArgsConstructor时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：Eric</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020/3/19 21:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;    <span class="comment">// 课程ID</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 课程名称</span></span><br><span class="line">    <span class="keyword">private</span> Integer score;  <span class="comment">// 课程成绩</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候你的类在编译后会自动生成一个无参构造函数，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：Eric</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020/3/19 21:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;    <span class="comment">// 课程ID</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 课程名称</span></span><br><span class="line">    <span class="keyword">private</span> Integer score;  <span class="comment">// 课程成绩</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lombok自动会帮你生成一个无参构造器！！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Course</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、部分参数构造器也不用写了</p><p>当你在你的类上使用了Lombok的注解 RequiredArgsConstructor时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：Eric</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020/3/19 21:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;    <span class="comment">// 课程ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;    <span class="comment">// 课程名称</span></span><br><span class="line">    <span class="keyword">private</span> Integer score;  <span class="comment">// 课程成绩</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候你的类在编译后会自动生成一个具备部分参数的构造函数，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：Eric</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020/3/19 21:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;    <span class="comment">// 课程ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;    <span class="comment">// 课程名称</span></span><br><span class="line">    <span class="keyword">private</span> Integer score;  <span class="comment">// 课程成绩</span></span><br><span class="line">    <span class="comment">// 因为name字段定义成final，所以Lombok自动会帮你生成一个部分参数的构造器！！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Course</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="null判空不用写了"><a href="#null判空不用写了" class="headerlink" title="null判空不用写了"></a>null判空不用写了</h3><p>Lombok的 @NonNull注解可以自动帮我们避免空指针判断。该注解作用在方法参数上，用于自动生成空值参数检查，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">JudgeNull</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (name == <span class="keyword">null</span>)&#123;</span><br><span class="line">          System.out.println(<span class="string">"参数为空"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(name);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>大批量的判空会不会让你感到烦躁呢？但是有了Lombok之后，事情就变得简单了，一个注解搞定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">JudgeNull</span><span class="params">(@NonNull String name)</span></span>&#123;</span><br><span class="line">       System.out.println(name);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="再也不用收尾了"><a href="#再也不用收尾了" class="headerlink" title="再也不用收尾了"></a>再也不用收尾了</h3><p>比如我们打开一个 txt文本文件亦或是调用Scanner输入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileReader fileReader = <span class="keyword">null</span>;</span><br><span class="line">            fileReader = <span class="keyword">new</span> FileReader(<span class="string">"Lombok.txt"</span>);</span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(fileReader);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(br.readLine());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>注意，这个文件句柄在使用完成之后是一定要手动 close的，否则就有可能资源泄漏。有了Lombok之后，这些统统不用干了，一个 @Cleanup注解即可搞定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cleanup</span> BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">       FileReader fileReader = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           fileReader = <span class="keyword">new</span> FileReader(<span class="string">"Lombok.txt"</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       br = <span class="keyword">new</span> BufferedReader(fileReader);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           System.out.println(br.readLine());</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="异常不用捕捉了"><a href="#异常不用捕捉了" class="headerlink" title="异常不用捕捉了"></a>异常不用捕捉了</h3><p>以上面那个作为例子</p><p>这地方的 FileNotFoundException异常，要么显式地在函数级抛出，要么就像上面一样 try/catch内部消灭。</p><p>如果在编码时，不想处理这种繁杂的异常处理，你可以使用Lombok的 @SneakyThrows注解进行简化，比如上面的代码就可以简化为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OpnTxt</span><span class="params">( String fileName)</span></span>&#123;</span><br><span class="line">    <span class="meta">@Cleanup</span> BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">    FileReader fileReader = <span class="keyword">null</span>;</span><br><span class="line">    fileReader = <span class="keyword">new</span> FileReader(<span class="string">"Lombok.txt"</span>);</span><br><span class="line">    br = <span class="keyword">new</span> BufferedReader(fileReader);</span><br><span class="line">    System.out.println(br.readLine());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样你编码时就无需处理异常了</p><hr><h3 id="还有一些"><a href="#还有一些" class="headerlink" title="还有一些"></a>还有一些</h3><p>上面列举了几个平时项目开发中使用非常频繁的Lombok注解，除此之外，还有诸如像：</p><ul><li>@EqualsAndHashCode：为类自动生成hashCode和equals实现</li><li>@Log：为类自动生成log日志记录</li><li>@Synchronized：为类方法或实例方法自动生成synchronized保护</li></ul><hr><p>从此，代码5分钟，划水2小时不是梦。。。<br><img src="/2020/03/19/Lombok%E5%8F%AF%E7%9C%9F%E9%A6%99%EF%BC%81%EF%BC%81%EF%BC%81/%E5%88%92%E6%B0%B4%E5%96%BD.jpg" alt="只想本分划水"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lombok </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea常用的一些插件</title>
      <link href="/2020/03/15/idea%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/"/>
      <url>/2020/03/15/idea%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2020/03/15/idea%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/idea%E6%8F%92%E4%BB%B6.jpg" alt="idea插件"></p><p>今天给分享一下中常用的几款能提升幸福感IDEA插件</p><hr><h3 id="1-Background-Image-Plus"><a href="#1-Background-Image-Plus" class="headerlink" title="1.Background Image Plus"></a>1.Background Image Plus</h3><a id="more"></a><p>默认IDEA的背景一般都比较单调，要么白乎乎，要么褐乎乎，而Background Image Plus这个插件可以为IDEA设置自定义图片作为背景，而且还可以设置透明度，从此写代码乐趣十足</p><p><strong>背景图设置效果如下：</strong></p><p><img src="/2020/03/15/idea%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/Background.png" alt="Background Image Plus"></p><hr><h3 id="2-CodeGlance"><a href="#2-CodeGlance" class="headerlink" title="2.CodeGlance"></a>2.CodeGlance</h3><p>CodeGlance是一款非常好用的代码地图插件，可以在代码编辑区的右侧生成一个竖向可拖动的代码缩略区，可以快速定位代码的同时，并且提供放大镜功能</p><p><strong>右侧代码缩略图效果:</strong></p><p><img src="/2020/03/15/idea%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/CodeGlance.jpg" alt="codeGlance"></p><hr><h3 id="3-Translation"><a href="#3-Translation" class="headerlink" title="3.Translation"></a>3.Translation</h3><p>代码中经常遇到不认识的英文单词或者句子，很懵怎么办？</p><p>Translation是一款非常好用的翻译插件，可以随时随地翻译单词、甚至一段话，从此不再需要额外打开浏览器搜索翻译网站了！</p><p><img src="/2020/03/15/idea%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/TranslationIn.jpg" alt="TranslationIn"></p><p><strong>翻译逐个单词：</strong></p><p><img src="/2020/03/15/idea%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/%E7%BF%BB%E8%AF%91%E5%8D%95%E8%AF%8D.jpg" alt="翻译单词"></p><p><strong>翻译一段话：</strong></p><p><img src="/2020/03/15/idea%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/%E7%BF%BB%E8%AF%91%E4%B8%80%E6%AE%B5%E8%AF%9D.jpg" alt="翻译一段话"></p><hr><h3 id="4-Rainbow-Brackets"><a href="#4-Rainbow-Brackets" class="headerlink" title="4.Rainbow Brackets"></a>4.Rainbow Brackets</h3><p>在代码非常复杂时，各种俄罗斯套娃式的括号简直让人心碎，Rainbow Brackets则是一款可以对成对括号进行着色的插件，顾名思义“彩虹色的括号”，从此复杂代码一眼即可看穿！</p><p>装完插件，括号都被染上了彩虹的颜色</p><p><img src="/2020/03/15/idea%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/RainbowBrackets.jpg" alt="Rainbow Brackets"></p><hr><h3 id="5-Statistic"><a href="#5-Statistic" class="headerlink" title="5.Statistic"></a>5.Statistic</h3><p>天天闷头写代码！</p><ul><li>你知道你项目到底有多少行代码吗？</li><li>你知道项目代码里有多少是实际代码？</li><li>有多少是空行？</li><li>有多少是注释吗？</li><li>. . .</li></ul><p>Statistic则是一款可以做项目全局代码统计信息的小插件</p><p><img src="/2020/03/15/idea%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/Statistic.jpg" alt="Statistic"></p><hr><h3 id="6-Lombok"><a href="#6-Lombok" class="headerlink" title="6.Lombok"></a>6.Lombok</h3><h4 id="Lombok到底是什么"><a href="#Lombok到底是什么" class="headerlink" title="Lombok到底是什么"></a>Lombok到底是什么</h4><p>先看一下它的官网<br><img src="/2020/03/15/idea%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/lombok%E5%AE%98%E7%BD%91.jpg" alt="lombok官网"><br><strong>大致意思是：</strong> Lombok是一个很牛批的插件（本质是个Java库），项目里一旦引入了Lombok之后，你项目中所有诸如：对象的构造函数、 equals()方法，属性的 get()/set()方法等等，这些没有技术含量的代码统统都不用写了，Lombok帮你搞定一切，全部帮你自动生成。<br>总之很香就是啦，后面会写一篇有关于lombok的博客！</p>]]></content>
      
      
      <categories>
          
          <category> idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo本地图片不显示</title>
      <link href="/2020/03/13/hexo%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA/"/>
      <url>/2020/03/13/hexo%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1、修改文件-config-yml-里的post-asset-folder-这个选项设置为true"><a href="#1、修改文件-config-yml-里的post-asset-folder-这个选项设置为true" class="headerlink" title="1、修改文件_config.yml 里的post_asset_folder:这个选项设置为true"></a>1、修改文件_config.yml 里的post_asset_folder:这个选项设置为true</h3><ul><li>修改之后，再使用hexo n “hexo 本地图片不显示”时，目录的样子是</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hexo本地图片不显示</span><br><span class="line">    ├── 01.jpg</span><br><span class="line">    ├── 02.jpg</span><br><span class="line">    └── 03.jpg</span><br><span class="line">    ...</span><br><span class="line">    hexo本地图片不显示.md</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2、安装hexo-asset-image-可以上传本地图片的插件"><a href="#2、安装hexo-asset-image-可以上传本地图片的插件" class="headerlink" title="2、安装hexo-asset-image,可以上传本地图片的插件"></a>2、安装<a href="https://github.com/EricGerry/hexo-asset-image-0.0.5.git" target="_blank" rel="noopener">hexo-asset-image</a>,可以上传本地图片的插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https:&#x2F;&#x2F;github.com&#x2F;EricGerry&#x2F;hexo-asset-image-0.0.5.git --save</span><br></pre></td></tr></table></figure><p><img src="/2020/03/13/hexo%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA/1.png" alt=" "><br>注意 不要使用npm install hexo-asset-image –save这个命令安装,版本号不对<br><img src="/2020/03/13/hexo%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA/2.jpg" alt=" "></p><ul><li>0.0.5版本<br><img src="/2020/03/13/hexo%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA/3.png" alt=" "></li><li>1.0.0版本<br><img src="/2020/03/13/hexo%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA/4.png" alt=" "></li></ul><h3 id="3、在md使用如下形式引用图片"><a href="#3、在md使用如下形式引用图片" class="headerlink" title="3、在md使用如下形式引用图片"></a>3、在md使用如下形式引用图片</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">01</span>](<span class="link">hexo本地图片不显示/01.jpg</span>)</span><br></pre></td></tr></table></figure><p><strong>注意</strong> 这里要使用”/“</p><h3 id="4、使用以下命令发布博客"><a href="#4、使用以下命令发布博客" class="headerlink" title="4、使用以下命令发布博客"></a>4、使用以下命令发布博客</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p><strong>注意</strong> 重命名md文件之后记得重命名文件夹，当md文件的名称与文件夹名称不同时，映射关系以md文件名称为主。会导致src图片路径找不到</p><p><strong>总结</strong>：</p><ul><li>检查_config.yml 文件的post_asset_folder:选项是否为true</li><li>检查创建文件之后的目录结构</li><li>检查hexo-asset-image插件的版本</li><li>检查路径引用图片的路径使用/</li><li>检查md文件的文件名称和图片存放文件夹名称是否相同</li></ul>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程基础面试题大集合</title>
      <link href="/2020/02/12/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/02/12/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2020/02/12/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/java.jpg" alt=" "></p><h2 id="1、多线程有什么用"><a href="#1、多线程有什么用" class="headerlink" title="1、多线程有什么用"></a>1、多线程有什么用</h2><p>&emsp;一个可能在很多人看来很扯淡的一个问题：我会用多线程就好了，还管它有什么用？在我看来，这个回答更扯淡。所谓”知其然知其所以然”，”会用”只是”知其然”，”为什么用”才是”知其所以然”，只有达到”知其然知其所以然”的程度才可以说是把一个知识点运用自如。OK，下面说说我对这个问题的看法：</p><ul><li>（1）发挥多核CPU的优势</li></ul><p>&emsp;随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程”同时”运行罢了。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。</p><ul><li>（2）防止阻塞</li></ul><p>&emsp;从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。</p><ul><li>（3）便于建模</li></ul><p>&emsp;这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。</p><h2 id="2、创建线程的方式"><a href="#2、创建线程的方式" class="headerlink" title="2、创建线程的方式"></a>2、创建线程的方式</h2><p>比较常见的一个问题了，一般就是两种：</p><ul><li><p>（1）继承Thread类</p></li><li><p>（2）实现Runnable接口</p></li></ul><p>至于哪个好，不用说肯定是后者好，因为实现接口的方式比继承类的方式更灵活，也能减少程序之间的耦合度，面向接口编程也是设计模式6大原则的核心。</p><h2 id="3、start-方法和run-方法的区别"><a href="#3、start-方法和run-方法的区别" class="headerlink" title="3、start()方法和run()方法的区别"></a>3、start()方法和run()方法的区别</h2><p>&emsp;只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。</p><h2 id="4、Runnable接口和Callable接口的区别"><a href="#4、Runnable接口和Callable接口的区别" class="headerlink" title="4、Runnable接口和Callable接口的区别"></a>4、Runnable接口和Callable接口的区别</h2><p>&emsp;Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</p><p>&emsp;这其实是很有用的一个特性，因为<strong>多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性</strong>，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。</p><h2 id="5、CyclicBarrier和CountDownLatch的区别"><a href="#5、CyclicBarrier和CountDownLatch的区别" class="headerlink" title="5、CyclicBarrier和CountDownLatch的区别"></a>5、CyclicBarrier和CountDownLatch的区别</h2><p>&emsp;两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：</p><ul><li><p>（1）CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行</p></li><li><p>（2）CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务</p></li><li><p>（3）CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</p></li></ul><h2 id="6、volatile关键字的作用"><a href="#6、volatile关键字的作用" class="headerlink" title="6、volatile关键字的作用"></a>6、volatile关键字的作用</h2><p>volatile关键字的作用主要有两个：</p><ul><li><p>（1）多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据</p></li><li><p>（2）代码底层执行不像我们看到的高级语言—-Java程序这么简单，它的执行是Java代码–&gt;字节码–&gt;根据字节码执行对应的C/C++代码–&gt;C/C++代码被编译成汇编语言–&gt;和硬件电路交互，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率</p></li></ul><p>&emsp;从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。</p><h2 id="7、什么是线程安全"><a href="#7、什么是线程安全" class="headerlink" title="7、什么是线程安全"></a>7、什么是线程安全</h2><p><strong>如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。</strong></p><p>&emsp;这个问题有值得一提的地方，就是线程安全也是有几个级别的：</p><ul><li>（1）不可变</li></ul><p>&emsp;像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用</p><ul><li>（2）绝对线程安全</li></ul><p>&emsp;不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet</p><ul><li>（3）相对线程安全</li></ul><p>&emsp;相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。</p><ul><li>（4）线程非安全</li></ul><p>&emsp;这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类</p><h2 id="8、Java中如何获取到线程dump文件"><a href="#8、Java中如何获取到线程dump文件" class="headerlink" title="8、Java中如何获取到线程dump文件"></a>8、Java中如何获取到线程dump文件</h2><p>&emsp;死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步：</p><ul><li><p>（1）获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java</p></li><li><p>（2）打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid</p></li></ul><p>&emsp;另外值得一提的是，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈</p><h2 id="9、一个线程如果出现了运行时异常会怎么样"><a href="#9、一个线程如果出现了运行时异常会怎么样" class="headerlink" title="9、一个线程如果出现了运行时异常会怎么样"></a>9、一个线程如果出现了运行时异常会怎么样</h2><p>&emsp;如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放</p><h2 id="10、如何在两个线程之间共享数据"><a href="#10、如何在两个线程之间共享数据" class="headerlink" title="10、如何在两个线程之间共享数据"></a>10、如何在两个线程之间共享数据</h2><p>&emsp;通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的</p><h2 id="11、sleep方法和wait方法有什么区别"><a href="#11、sleep方法和wait方法有什么区别" class="headerlink" title="11、sleep方法和wait方法有什么区别"></a>11、sleep方法和wait方法有什么区别</h2><p>&emsp;这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器</p><h2 id="12、生产者消费者模型的作用是什么"><a href="#12、生产者消费者模型的作用是什么" class="headerlink" title="12、生产者消费者模型的作用是什么"></a>12、生产者消费者模型的作用是什么</h2><ul><li><p>（1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用</p></li><li><p>（2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约</p></li></ul><h2 id="13、ThreadLocal有什么用"><a href="#13、ThreadLocal有什么用" class="headerlink" title="13、ThreadLocal有什么用"></a>13、ThreadLocal有什么用</h2><p>&emsp;简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了</p><h2 id="14、为什么wait-方法和notify-notifyAll-方法要在同步块中被调用"><a href="#14、为什么wait-方法和notify-notifyAll-方法要在同步块中被调用" class="headerlink" title="14、为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用"></a>14、为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用</h2><p>&emsp;这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁</p><h2 id="15、wait-方法和notify-notifyAll-方法在放弃对象监视器时有什么区别"><a href="#15、wait-方法和notify-notifyAll-方法在放弃对象监视器时有什么区别" class="headerlink" title="15、wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别"></a>15、wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别</h2><p>&emsp;wait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于：<strong>wait()方法立即释放对象监视器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器。</strong></p><h2 id="16、为什么要使用线程池"><a href="#16、为什么要使用线程池" class="headerlink" title="16、为什么要使用线程池"></a>16、为什么要使用线程池</h2><p>&emsp;避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。</p><h2 id="17、怎么检测一个线程是否持有对象监视器"><a href="#17、怎么检测一个线程是否持有对象监视器" class="headerlink" title="17、怎么检测一个线程是否持有对象监视器"></a>17、怎么检测一个线程是否持有对象监视器</h2><p>&emsp;Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着<strong>“某条线程”指的是当前线程</strong>。</p><h2 id="18、synchronized和ReentrantLock的区别"><a href="#18、synchronized和ReentrantLock的区别" class="headerlink" title="18、synchronized和ReentrantLock的区别"></a>18、synchronized和ReentrantLock的区别</h2><p>&emsp;synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：</p><ul><li><p>（1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</p></li><li><p>（2）ReentrantLock可以获取各种锁的信息</p></li><li><p>（3）ReentrantLock可以灵活地实现多路通知</p></li></ul><p>&emsp;另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。</p><h2 id="19、ConcurrentHashMap的并发度是什么"><a href="#19、ConcurrentHashMap的并发度是什么" class="headerlink" title="19、ConcurrentHashMap的并发度是什么"></a>19、ConcurrentHashMap的并发度是什么</h2><p>&emsp;ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据</p><h2 id="20、ReadWriteLock是什么"><a href="#20、ReadWriteLock是什么" class="headerlink" title="20、ReadWriteLock是什么"></a>20、ReadWriteLock是什么</h2><p>&emsp;首先明确一下，不是说ReentrantLock不好，只是ReentrantLock某些时候有局限。如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。</p><p>&emsp;因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p><h2 id="21、FutureTask是什么"><a href="#21、FutureTask是什么" class="headerlink" title="21、FutureTask是什么"></a>21、FutureTask是什么</h2><p>&emsp;这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。</p><h2 id="22、Linux环境下如何查找哪个线程使用CPU最长"><a href="#22、Linux环境下如何查找哪个线程使用CPU最长" class="headerlink" title="22、Linux环境下如何查找哪个线程使用CPU最长"></a>22、Linux环境下如何查找哪个线程使用CPU最长</h2><p>&emsp;这是一个比较偏实践的问题，这种问题我觉得挺有意义的。可以这么做：</p><ul><li><p>（1）获取项目的pid，jps或者ps -ef | grep java，这个前面有讲过</p></li><li><p>（2）top -H -p pid，顺序不能改变</p></li></ul><p>&emsp;这样就可以打印出当前的项目，每条线程占用CPU时间的百分比。注意这里打出的是LWP，也就是操作系统原生线程的线程号，我笔记本山没有部署Linux环境下的Java工程，因此没有办法截图演示，网友朋友们如果公司是使用Linux环境部署项目的话，可以尝试一下。</p><p>&emsp;使用”top -H -p pid”+”jps pid”可以很容易地找到某条占用CPU高的线程的线程堆栈，从而定位占用CPU高的原因，一般是因为不当的代码操作导致了死循环。</p><p>&emsp;最后提一点，”top -H -p pid”打出来的LWP是十进制的，”jps pid”打出来的本地线程号是十六进制的，转换一下，就能定位到占用CPU高的线程的当前线程堆栈了。</p><h2 id="23、Java编程写一个会导致死锁的程序"><a href="#23、Java编程写一个会导致死锁的程序" class="headerlink" title="23、Java编程写一个会导致死锁的程序"></a>23、Java编程写一个会导致死锁的程序</h2><p>&emsp;很多人都知道死锁是怎么一回事儿：线程A和线程B相互等待对方持有的锁导致程序无限死循环下去。当然也仅限于此了，问一下怎么写一个死锁的程序就不知道了，这种情况说白了就是不懂什么是死锁，懂一个理论就完事儿了，实践中碰到死锁的问题基本上是看不出来的。</p><p>真正理解什么是死锁，这个问题其实不难，几个步骤：</p><ul><li><p>（1）两个线程里面分别持有两个Object对象：lock1和lock2。这两个lock作为同步代码块的锁；</p></li><li><p>（2）线程1的run()方法中同步代码块先获取lock1的对象锁，Thread.sleep(xxx)，时间不需要太多，50毫秒差不多了，然后接着获取lock2的对象锁。这么做主要是为了防止线程1启动一下子就连续获得了lock1和lock2两个对象的对象锁</p></li><li><p>（3）线程2的run)(方法中同步代码块先获取lock2的对象锁，接着获取lock1的对象锁，当然这时lock1的对象锁已经被线程1锁持有，线程2肯定是要等待线程1释放lock1的对象锁的</p></li></ul><p>&emsp;这样，线程1”睡觉”睡完，线程2已经获取了lock2的对象锁了，线程1此时尝试获取lock2的对象锁，便被阻塞，此时一个死锁就形成了。代码就不写了，占的篇幅有点多，Java多线程7：死锁这篇文章里面有，就是上面步骤的代码实现。</p><h2 id="24、怎么唤醒一个阻塞的线程"><a href="#24、怎么唤醒一个阻塞的线程" class="headerlink" title="24、怎么唤醒一个阻塞的线程"></a>24、怎么唤醒一个阻塞的线程</h2><p>&emsp;如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</p><h2 id="25、不可变对象对多线程有什么帮助"><a href="#25、不可变对象对多线程有什么帮助" class="headerlink" title="25、不可变对象对多线程有什么帮助"></a>25、不可变对象对多线程有什么帮助</h2><p>&emsp;前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。</p><h2 id="26、什么是多线程的上下文切换"><a href="#26、什么是多线程的上下文切换" class="headerlink" title="26、什么是多线程的上下文切换"></a>26、什么是多线程的上下文切换</h2><p>&emsp;多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。</p><h2 id="27、如果你提交任务时，线程池队列已满，这时会发生什么"><a href="#27、如果你提交任务时，线程池队列已满，这时会发生什么" class="headerlink" title="27、如果你提交任务时，线程池队列已满，这时会发生什么"></a>27、如果你提交任务时，线程池队列已满，这时会发生什么</h2><p>这里区分一下：</p><ul><li>1.如果使用的是无界队列LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务</li><li>2.如果使用的是有界队列比如ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，会根据maximumPoolSize的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue继续满，那么则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy</li></ul><h2 id="28、Java中用到的线程调度算法是什么"><a href="#28、Java中用到的线程调度算法是什么" class="headerlink" title="28、Java中用到的线程调度算法是什么"></a>28、Java中用到的线程调度算法是什么</h2><p>&emsp;抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</p><h2 id="29、Thread-sleep-0-的作用是什么"><a href="#29、Thread-sleep-0-的作用是什么" class="headerlink" title="29、Thread.sleep(0)的作用是什么"></a>29、Thread.sleep(0)的作用是什么</h2><p>&emsp;由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。</p><h2 id="30、什么是自旋"><a href="#30、什么是自旋" class="headerlink" title="30、什么是自旋"></a>30、什么是自旋</h2><p>&emsp;很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p><h2 id="31、什么是Java内存模型"><a href="#31、什么是Java内存模型" class="headerlink" title="31、什么是Java内存模型"></a>31、什么是Java内存模型</h2><p>Java内存模型定义了一种多线程访问Java内存的规范。Java内存模型要完整讲不是这里几句话能说清楚的，我简单总结一下Java内存模型的几部分内容：</p><ul><li><p>（1）Java内存模型将内存分为了主内存和工作内存。类的状态，也就是类之间共享的变量，是存储在主内存中的，每次Java线程用到这些主内存中的变量的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去</p></li><li><p>（2）定义了几个原子操作，用于操作主内存和工作内存中的变量</p></li><li><p>（3）定义了volatile变量的使用规则</p></li><li><p>（4）happens-before，即先行发生原则，定义了操作A必然先行发生于操作B的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码、一个释放锁unlock的动作一定先行发生于后面对于同一个锁进行锁定lock的动作等等，只要符合这些规则，则不需要额外做同步措施，如果某段代码不符合所有的happens-before规则，则这段代码一定是线程非安全的</p></li></ul><h2 id="32、什么是CAS"><a href="#32、什么是CAS" class="headerlink" title="32、什么是CAS"></a>32、什么是CAS</h2><p>&emsp;CAS，全称为Compare and Swap，即比较-替换。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。</p><h2 id="33、什么是乐观锁和悲观锁"><a href="#33、什么是乐观锁和悲观锁" class="headerlink" title="33、什么是乐观锁和悲观锁"></a>33、什么是乐观锁和悲观锁</h2><ul><li><p>（1）乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</p></li><li><p>（2）悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。</p></li></ul><h2 id="34、什么是AQS"><a href="#34、什么是AQS" class="headerlink" title="34、什么是AQS"></a>34、什么是AQS</h2><blockquote><p>简单说一下AQS，AQS全称为AbstractQueuedSychronizer，翻译过来应该是抽象队列同步器。</p></blockquote><p>&emsp;如果说java.util.concurrent的基础是CAS的话，那么AQS就是整个Java并发包的核心了，ReentrantLock、CountDownLatch、Semaphore等等都用到了它。AQS实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队列，前面一个线程使用ReentrantLock好了，则双向队列实际上的第一个Entry开始运行。</p><p>&emsp;AQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，开发者可以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。</p><h2 id="35、单例模式的线程安全性"><a href="#35、单例模式的线程安全性" class="headerlink" title="35、单例模式的线程安全性"></a>35、单例模式的线程安全性</h2><p>&emsp;老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下：</p><ul><li><p>（1）饿汉式单例模式的写法：线程安全</p></li><li><p>（2）懒汉式单例模式的写法：非线程安全</p></li><li><p>（3）双检锁单例模式的写法：线程安全</p></li></ul><h2 id="36、Semaphore有什么作用"><a href="#36、Semaphore有什么作用" class="headerlink" title="36、Semaphore有什么作用"></a>36、Semaphore有什么作用</h2><p>&emsp;Semaphore就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。</p><h2 id="37、Hashtable的size-方法中明明只有一条语句”return-count”，为什么还要做同步"><a href="#37、Hashtable的size-方法中明明只有一条语句”return-count”，为什么还要做同步" class="headerlink" title="37、Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步"></a>37、Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步</h2><p>&emsp;这是我之前的一个困惑，不知道大家有没有想过这个问题。某个方法中如果有多条语句，并且都在操作同一个类变量，那么在多线程环境下不加锁，势必会引发线程安全问题，这很好理解，但是size()方法明明只有一条语句，为什么还要加锁？</p><p>关于这个问题，在慢慢地工作、学习中，有了理解，主要原因有两点：</p><ul><li><p>（1）同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性</p></li><li><p>（2）CPU执行代码，执行的不是Java代码，这点很关键，一定得记住。Java代码最终是被翻译成机器码执行的，机器码才是真正可以和硬件电路交互的代码。即使你看到Java代码只有一行，甚至你看到Java代码编译之后生成的字节码也只有一行，也不意味着对于底层来说这句语句的操作只有一个。一句”return count”假设被翻译成了三句汇编语句执行，一句汇编语句和其机器码做对应，完全可能执行完第一句，线程就切换了。</p></li></ul><h2 id="38、线程类的构造方法、静态块是被哪个线程调用的"><a href="#38、线程类的构造方法、静态块是被哪个线程调用的" class="headerlink" title="38、线程类的构造方法、静态块是被哪个线程调用的"></a>38、线程类的构造方法、静态块是被哪个线程调用的</h2><p>&emsp;这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。</p><p>&emsp;如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：</p><ul><li><p>（1）Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的</p></li><li><p>（2）Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的</p></li></ul><h2 id="39、同步方法和同步块，哪个是更好的选择"><a href="#39、同步方法和同步块，哪个是更好的选择" class="headerlink" title="39、同步方法和同步块，哪个是更好的选择"></a>39、同步方法和同步块，哪个是更好的选择</h2><p>&emsp;同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越小越好。</p><p>&emsp;借着这一条，我额外提一点，虽说同步的范围越少越好，但是在Java虚拟机中还是存在着一种叫做锁粗化的优化方法，这种方法就是把同步范围变大。这是有用的，比方说StringBuffer，它是一个线程安全的类，自然最常用的append()方法是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁-&gt;解锁，这对性能不利，因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作，将多次的append的操作扩展到append方法的头尾，变成一个大的同步块，这样就减少了加锁–&gt;解锁的次数，有效地提升了代码执行的效率。</p><h2 id="40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池"><a href="#40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池" class="headerlink" title="40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池"></a>40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池</h2><ul><li><p>（1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换</p></li><li><p>（2）并发不高、任务执行时间长的业务要区分开看：<br>a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务<br>b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换</p></li><li><p>（3）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的几种排序你学会了吗？</title>
      <link href="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/"/>
      <url>/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><h3 id="1-1-排序"><a href="#1-1-排序" class="headerlink" title="1.1 排序"></a>1.1 排序</h3><p>&emsp;排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。<br>平时的上下文中，如果提到排序，通常指的是排升序（非降序）。<br>通常意义上的排序，都是指的原地排序(in place sort)。</p><h3 id="1-2-稳定性（重要）"><a href="#1-2-稳定性（重要）" class="headerlink" title="1.2 稳定性（重要）"></a>1.2 稳定性（重要）</h3><p>&emsp;两个相等的数据，如果经过排序后，排序算法能保证其相对位置不发生变化，则我们称该算法是具备稳定性的排序算法。</p><p><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/Sort.png" alt=" "></p><h3 id="1-3-应用"><a href="#1-3-应用" class="headerlink" title="1.3 应用"></a>1.3 应用</h3><ol><li>各大商城的价格从低到高等<br><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E6%B7%98%E5%AE%9D%E6%8E%92%E5%BA%8F.png" alt=" "></li><li>中国大学排名<br><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6.png" alt=" "></li></ol><h2 id="2-七大基于比较的排序"><a href="#2-七大基于比较的排序" class="headerlink" title="2.七大基于比较的排序"></a>2.七大基于比较的排序</h2><p><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E4%B8%83%E5%A4%A7%E6%8E%92%E5%BA%8F.png" alt=" "></p><p><a href="https://www.bilibili.com/video/av17449274" target="_blank" rel="noopener">排序舞蹈</a></p><h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h2><h3 id="3-1-直接插入排序-原理"><a href="#3-1-直接插入排序-原理" class="headerlink" title="3.1 直接插入排序-原理"></a>3.1 直接插入排序-原理</h3><p>整个区间被分为</p><ul><li><ol><li>有序区间</li></ol></li><li><ol start="2"><li>无序区间</li></ol></li></ul><p>每次选择无序区间的第一个元素，在有序区间内选择合适的位置插入<br><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.png" alt=" "></p><h3 id="3-2-实现"><a href="#3-2-实现" class="headerlink" title="3.2 实现"></a>3.2 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 有序区间: [0, i)</span></span><br><span class="line">        <span class="comment">// 无序区间: [i, array.length)</span></span><br><span class="line">        <span class="keyword">int</span> v = array[i]; <span class="comment">// 无序区间的第一个数</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 不写 array[j] == v 是保证排序的稳定性</span></span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; v; j--) &#123;</span><br><span class="line">            array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">       &#125;</span><br><span class="line">        array[j + <span class="number">1</span>] = v;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-性能分析"><a href="#3-3-性能分析" class="headerlink" title="3.3 性能分析"></a>3.3 性能分析</h3><p>时间复杂度</p><table><thead><tr><th align="center">最好</th><th align="center">平均</th><th align="center">最坏</th></tr></thead><tbody><tr><td align="center">O(n)</td><td align="center">O(n^2)</td><td align="center">O(n^2)</td></tr><tr><td align="center">数据有序</td><td align="center"></td><td align="center">数据逆序</td></tr></tbody></table><table><thead><tr><th align="center">空间复杂度</th><th align="center">O(1)</th></tr></thead></table><h3 id="3-4-折半插入排序"><a href="#3-4-折半插入排序" class="headerlink" title="3.4 折半插入排序"></a>3.4 折半插入排序</h3><p>在有序区间选择数据应该插入的位置时，因为区间的有序性，可以利用折半查找的思想。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bsInsertSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = array[i];</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = i;</span><br><span class="line">        <span class="comment">// [left, right)</span></span><br><span class="line">        <span class="comment">// 需要考虑稳定性</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (v &gt;= array[m]) &#123;</span><br><span class="line">                left = m + <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = m;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="comment">// 搬移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; left; j--) &#123;</span><br><span class="line">            array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">       &#125;</span><br><span class="line">         array[left] = v;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h2><h3 id="4-1-原理"><a href="#4-1-原理" class="headerlink" title="4.1 原理"></a>4.1 原理</h3><p>&emsp;希尔排序法又称缩小增量法。希尔排序法的基本思想是：先选定一个整数，把待排序文件中所有记录分成个组，所有<br>距离为的记录分在同一组内，并对每一组内的记录进行排序。然后，取，重复上述分组和排序的工作。当到达=1时，<br>所有记录在统一组内排好序。</p><ul><li><ol><li>希尔排序是对直接插入排序的优化。</li></ol></li><li><ol start="2"><li>当gap &gt; 1时都是预排序，目的是让数组更接近于有序。当gap == 1时，数组已经接近有序的了，这样就会很快。这样整体而言，可以达到优化的效果。我们实现后可以进行性能测试的对比。<br><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.png" alt=" "><br><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.png" alt=" "></li></ol></li></ul><h3 id="4-2-实现"><a href="#4-2-实现" class="headerlink" title="4.2 实现"></a>4.2 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap = array.length;</span><br><span class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        insertSortGap(array, gap);</span><br><span class="line">        gap = (gap / <span class="number">3</span>) + <span class="number">1</span>; <span class="comment">// OR gap = gap / 2;</span></span><br><span class="line">   &#125;</span><br><span class="line">    insertSortGap(array, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSortGap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> gap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = array[i];</span><br><span class="line">        <span class="keyword">int</span> j = i - gap;</span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; v; j -= gap) &#123;</span><br><span class="line">            array[j + gap] = array[j];</span><br><span class="line">       &#125;</span><br><span class="line">        array[j + gap] = v;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-性能分析"><a href="#4-3-性能分析" class="headerlink" title="4.3 性能分析"></a>4.3 性能分析</h3><p>时间复杂度</p><table><thead><tr><th align="center">最好</th><th align="center">平均</th><th align="center">最坏</th></tr></thead><tbody><tr><td align="center">O(n)</td><td align="center">O(n^1.3)</td><td align="center">O(n^2)</td></tr><tr><td align="center">数据有序</td><td align="center"></td><td align="center">比较难构造</td></tr></tbody></table><table><thead><tr><th align="center">空间复杂度</th><th align="center">O(1)</th></tr></thead></table><p>稳定性：不稳定</p><h2 id="5-选择排序"><a href="#5-选择排序" class="headerlink" title="5. 选择排序"></a>5. 选择排序</h2><h3 id="5-1-直接选择排序-原理"><a href="#5-1-直接选择排序-原理" class="headerlink" title="5.1 直接选择排序-原理"></a>5.1 直接选择排序-原理</h3><p>每一次从无序区间选出最大（或最小）的一个元素，存放在无序区间的最后（或最前），直到全部待排序的数据元素排完 。<br><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.png" alt=" "></p><h3 id="5-2-实现"><a href="#5-2-实现" class="headerlink" title="5.2 实现"></a>5.2 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 无序区间: [0, array.length - i)</span></span><br><span class="line">        <span class="comment">// 有序区间: [array.length - i, array.length)</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; array.length - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[max]) &#123;</span><br><span class="line">                max = j;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">int</span> t = array[max];</span><br><span class="line">        array[max] = array[array.length - i - <span class="number">1</span>];</span><br><span class="line">        array[array.length - i - <span class="number">1</span>] = t;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-性能分析"><a href="#5-3-性能分析" class="headerlink" title="5.3 性能分析"></a>5.3 性能分析</h3><table><thead><tr><th align="center">时间复杂度</th><th align="center">空间复杂度</th></tr></thead><tbody><tr><td align="center">O(n^2)</td><td align="center">O(1)</td></tr><tr><td align="center">数据不敏感</td><td align="center">数据不敏感</td></tr></tbody></table><p>稳定性：不稳定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123; <span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>a, <span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>b &#125;;</span><br><span class="line"><span class="comment">// 交换中该情况无法识别，保证 5a 还在 5b 前边</span></span><br></pre></td></tr></table></figure><h3 id="5-4-双向选择排序"><a href="#5-4-双向选择排序" class="headerlink" title="5.4 双向选择排序"></a>5.4 双向选择排序</h3><p>每一次从无序区间选出最小 + 最大的元素，存放在无序区间的最前和最后，直到全部待排序的数据元素排完。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSortOP</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// [low, high] 表示整个无序区间</span></span><br><span class="line">    <span class="comment">// 无序区间内只有一个数也可以停止排序了</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = low;</span><br><span class="line">        <span class="keyword">int</span> max = low;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = low + <span class="number">1</span>; i &lt;= max; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt; array[min]) &#123;</span><br><span class="line">                min = i;</span><br><span class="line">           &#125;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &gt; array[max]) &#123;</span><br><span class="line">                max = i;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        swap(array, min, low);</span><br><span class="line">        <span class="comment">// 见下面例子讲解</span></span><br><span class="line">        <span class="keyword">if</span> (max == low) &#123;</span><br><span class="line">            max = min;</span><br><span class="line">       &#125;</span><br><span class="line">        swap(array, max, high);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = t; &#125;</span><br><span class="line">array = &#123; <span class="number">9</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span> &#125;; <span class="comment">// 交换之前</span></span><br><span class="line"><span class="comment">// low = 0; high = 6</span></span><br><span class="line"><span class="comment">// max = 0; min = 2</span></span><br><span class="line">array = &#123; <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span> &#125;; <span class="comment">// 将最小的交换到无序区间的最开始后</span></span><br><span class="line"><span class="comment">// max = 0，但实际上最大的数已经不在 0 位置，而是被交换到 min 即 2 位置了</span></span><br><span class="line"><span class="comment">// 所以需要让 max = min 即 max = 2</span></span><br><span class="line">array = &#123; <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span> &#125;; <span class="comment">// 将最大的交换到无序区间的最结尾后</span></span><br></pre></td></tr></table></figure><h2 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6. 堆排序"></a>6. 堆排序</h2><h3 id="6-1-原理"><a href="#6-1-原理" class="headerlink" title="6.1 原理"></a>6.1 原理</h3><p>基本原理也是选择排序，只是不在使用遍历的方式查找无序区间的最大的数，而是通过堆来选择无序区间的最大的<br>数。<br>注意： 排升序要建大堆；排降序要建小堆。</p><p><a href="https://www.cs.usfca.edu/~galles/visualization/HeapSort.html" target="_blank" rel="noopener">堆排序</a></p><p><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E5%A0%86%E6%8E%92%E5%BA%8F.png" alt=" "></p><h3 id="6-2-实现"><a href="#6-2-实现" class="headerlink" title="6.2 实现"></a>6.2 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    createHeap(array);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 交换前</span></span><br><span class="line">        <span class="comment">// 无序区间: [0, array.length - i)</span></span><br><span class="line">        <span class="comment">// 有序区间: [array.length - i, array.length)</span></span><br><span class="line">        swap(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 交换后</span></span><br><span class="line">        <span class="comment">// 无序区间: [0, array.length - i - 1)</span></span><br><span class="line">        <span class="comment">// 有序区间: [array.length - i - 1, array.length)</span></span><br><span class="line">        <span class="comment">// 无序区间长度: array.length - i - 1</span></span><br><span class="line">        shiftDown(array, array.length - i - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = t; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createHeap</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (array.length - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        shiftDown(array, array.length, i);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> size, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; size) &#123;</span><br><span class="line">        <span class="keyword">int</span> max = left;</span><br><span class="line">   <span class="keyword">int</span> right = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[right] &gt; array[left]) &#123;</span><br><span class="line">                max = right;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">if</span> (array[index] &gt;= array[max]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">int</span> t = array[index];</span><br><span class="line">        array[index] = array[max];</span><br><span class="line">        array[max] = t;</span><br><span class="line">        index = max;</span><br><span class="line">        left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-性能分析"><a href="#6-3-性能分析" class="headerlink" title="6.3 性能分析"></a>6.3 性能分析</h3><table><thead><tr><th align="center">时间复杂度</th><th align="center">空间复杂度</th></tr></thead><tbody><tr><td align="center">O(n * log(n))</td><td align="center">O(1)</td></tr><tr><td align="center">数据不敏感</td><td align="center">数据不敏感</td></tr></tbody></table><p>稳定性：不稳定</p><h2 id="7-冒泡排序"><a href="#7-冒泡排序" class="headerlink" title="7. 冒泡排序"></a>7. 冒泡排序</h2><h3 id="7-1-原理"><a href="#7-1-原理" class="headerlink" title="7.1 原理"></a>7.1 原理</h3><p>在无序区间，通过相邻数的比较，将最大的数冒泡到无序区间的最后，持续这个过程，直到数组整体有序<br><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.png" alt=" "></p><h3 id="7-2-实现"><a href="#7-2-实现" class="headerlink" title="7.2 实现"></a>7.2 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"> <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line"> <span class="comment">// 相等不交换，保证稳定性</span></span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(array, j, j + <span class="number">1</span>);</span><br><span class="line">                isSorted = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-性能分析"><a href="#7-3-性能分析" class="headerlink" title="7.3 性能分析"></a>7.3 性能分析</h3><p>时间复杂度<br>最好|平均|最坏<br>:-:|:-:|:-:<br>O(n)|O(n^2)|O(n^2)<br>数据有序| |数据逆序</p><table><thead><tr><th align="center">空间复杂度</th><th align="center">O(1)</th></tr></thead></table><p>稳定性：稳定</p><h2 id="8-快速排序"><a href="#8-快速排序" class="headerlink" title="8. 快速排序"></a>8. 快速排序</h2><h3 id="8-1-原理"><a href="#8-1-原理" class="headerlink" title="8.1 原理"></a>8.1 原理</h3><ul><li><ol><li>从待排序区间选择一个数，作为基准值(pivot)；</li></ol></li><li><ol start="2"><li>Partition: 遍历整个待排序区间，将比基准值小的（可以包含相等的）放到基准值的左边，将比基准值大的（可以包含相等的）放到基准值的右边；</li></ol></li><li><ol start="3"><li>采用分治思想，对左右两个小区间按照同样的方式处理，直到小区间的长度 == 1，代表已经有序，或者小区间的长度 == 0，代表没有数据。<br><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png" alt=" "></li></ol></li></ul><p><strong>实现:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line"> quickSortInternal(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [left, right] 为待排序区间</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortInternal</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 最简单的选择基准值的方式，选择 array[left] 作为基准值</span></span><br><span class="line"> <span class="comment">// pivotIndex 代表基准值最终停留的下标</span></span><br><span class="line"> <span class="keyword">int</span> pivotIndex = partition(array, left, right);</span><br><span class="line"> <span class="comment">// [left, pivotIndex - 1] 都是小于等于基准值的</span></span><br><span class="line"> <span class="comment">// [pivotIndex + 1, right] 都是大于等于基准值的</span></span><br><span class="line"> quickSortInternal(array, left, pivotIndex - <span class="number">1</span>);</span><br><span class="line"> quickSortInternal(array, pivotIndex + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-原理-partition"><a href="#8-2-原理-partition" class="headerlink" title="8.2 原理-partition"></a>8.2 原理-partition</h3><h4 id="Hoare-法"><a href="#Hoare-法" class="headerlink" title="Hoare 法"></a>Hoare 法</h4><p><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/Hoare.png" alt=" "><br><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/Hoare2.png" alt=" "></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> i = left;</span><br><span class="line"> <span class="keyword">int</span> j = right;</span><br><span class="line"> <span class="keyword">int</span> pivot = array[left];</span><br><span class="line"> <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"> <span class="keyword">while</span> (i &lt; j &amp;&amp; array[j] &gt;= pivot) &#123;</span><br><span class="line"> j--;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">while</span> (i &lt; j &amp;&amp; array[i] &lt;= pivot) &#123;</span><br><span class="line"> i++;</span><br><span class="line"> &#125;</span><br><span class="line"> swap(array, i, j);</span><br><span class="line"> &#125;</span><br><span class="line"> swap(array, i, left);</span><br><span class="line"> <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-性能分析"><a href="#8-3-性能分析" class="headerlink" title="8.3 性能分析"></a>8.3 性能分析</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><table><thead><tr><th align="center">最好</th><th align="center">平均</th><th align="center">最坏</th></tr></thead><tbody><tr><td align="center">O(n*log(n))</td><td align="center">O(n*log(n))</td><td align="center">O(n^2)</td></tr></tbody></table><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><table><thead><tr><th align="center">最好</th><th align="center">平均</th><th align="center">最坏</th></tr></thead><tbody><tr><td align="center">O(log(n))</td><td align="center">O(log(n))</td><td align="center">O(n)</td></tr></tbody></table><p>稳定性：不稳定</p><h3 id="8-4-原理-基准值的选择"><a href="#8-4-原理-基准值的选择" class="headerlink" title="8.4 原理-基准值的选择"></a>8.4 原理-基准值的选择</h3><ul><li><ol><li>选择边上（左或者右）</li></ol></li><li><ol start="2"><li>随机选择</li></ol></li><li><ol start="3"><li>几数取中（例如三数取中）：array[left], array[mid], array[right] 大小是中间的为基准值</li></ol></li></ul><h3 id="8-5-原理-非递归分治"><a href="#8-5-原理-非递归分治" class="headerlink" title="8.5 原理-非递归分治"></a>8.5 原理-非递归分治</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line"> Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"> stack.push(array.length - <span class="number">1</span>);</span><br><span class="line"> stack.push(<span class="number">0</span>);</span><br><span class="line"> <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line"> <span class="keyword">int</span> left = stack.pop();</span><br><span class="line"> <span class="keyword">int</span> right = stack.pop();</span><br><span class="line"> <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line"> <span class="keyword">continue</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">int</span> pivotIndex = partition(array, left, right);</span><br><span class="line"> stack.push(right);</span><br><span class="line"> stack.push(pivotIndex + <span class="number">1</span>);</span><br><span class="line"> stack.push(pivotIndex - <span class="number">1</span>);</span><br><span class="line"> stack.push(left);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-归并排序"><a href="#9-归并排序" class="headerlink" title="9. 归并排序"></a>9. 归并排序</h2><h3 id="9-1-原理"><a href="#9-1-原理" class="headerlink" title="9.1 原理"></a>9.1 原理</h3><p>&emsp;归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and<br>Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><p><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.png" alt=" "><br><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F2.png" alt=" "></p><h3 id="9-2-原理-合并两个有序数组"><a href="#9-2-原理-合并两个有序数组" class="headerlink" title="9.2 原理-合并两个有序数组"></a>9.2 原理-合并两个有序数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> i = low;</span><br><span class="line"> <span class="keyword">int</span> j = mid;</span><br><span class="line"> <span class="keyword">int</span> length = high - low;</span><br><span class="line"> <span class="keyword">int</span>[] extra = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"> <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"> <span class="comment">// 选择小的放入 extra</span></span><br><span class="line"> <span class="keyword">while</span> (i &lt; mid &amp;&amp; j &lt; high) &#123;</span><br><span class="line"> <span class="comment">// 加入等于，保证稳定性</span></span><br><span class="line"> <span class="keyword">if</span> (array[i] &lt;= array[j]) &#123;</span><br><span class="line"> extra[k++] = array[i++];</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> extra[k++] = array[j++];</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 将属于元素放入 extra</span></span><br><span class="line"> <span class="keyword">while</span> (i &lt; mid) &#123;</span><br><span class="line"> extra[k++] = array[i++];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> j &lt; right) &#123;</span><br><span class="line"> extra[k++] = array[j++];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 从 extra 搬移回 array</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; length; t++) &#123;</span><br><span class="line"> <span class="comment">// 需要搬移回原位置，从 low 开始</span></span><br><span class="line"> array[low + t] = extra[t];</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-实现"><a href="#9-3-实现" class="headerlink" title="9.3 实现"></a>9.3 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line"> mergeSortInternal(array, <span class="number">0</span>, array.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 待排序区间为 [low, high)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSortInternal</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (low - <span class="number">1</span> &gt;= high) &#123;</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"> mergeSortInternal(array, low, mid);</span><br><span class="line"> mergeSortInternal(array, mid, high);</span><br><span class="line"> merge(array, low, mid, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-4-性能分析"><a href="#9-4-性能分析" class="headerlink" title="9.4 性能分析"></a>9.4 性能分析</h3><table><thead><tr><th align="center">时间复杂度</th><th align="center">空间复杂度</th></tr></thead><tbody><tr><td align="center">O(n*log(n))</td><td align="center">O(n)</td></tr><tr><td align="center">数据不敏感</td><td align="center">数据不敏感</td></tr></tbody></table><p>稳定性：稳定</p><h3 id="9-5-优化总结"><a href="#9-5-优化总结" class="headerlink" title="9.5 优化总结"></a>9.5 优化总结</h3><p>在排序过程中重复利用两个数组，减少元素的复制过程</p><h3 id="9-6-非递归版本"><a href="#9-6-非递归版本" class="headerlink" title="9.6 非递归版本"></a>9.6 非递归版本</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i = i * <span class="number">2</span>) &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length; j = j + <span class="number">2</span> * i) &#123;</span><br><span class="line"> <span class="keyword">int</span> low = j;</span><br><span class="line"> <span class="keyword">int</span> mid = j + i;</span><br><span class="line"> <span class="keyword">if</span> (mid &gt;= array.length) &#123;</span><br><span class="line"> <span class="keyword">continue</span>;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">int</span> high = mid + i;</span><br><span class="line"> <span class="keyword">if</span> (high &gt; array.length) &#123;</span><br><span class="line"> high = array.length;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> merge(array, low, mid, high);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-7-海量数据的排序问题"><a href="#9-7-海量数据的排序问题" class="headerlink" title="9.7 海量数据的排序问题"></a>9.7 海量数据的排序问题</h3><p>外部排序：排序过程需要在磁盘等外部存储进行的排序<br>前提：内存只有 1G，需要排序的数据有 100G<br>因为内存中因为无法把所有数据全部放下，所以需要外部排序，而归并排序是最常用的外部排序</p><ul><li><ol><li>先把文件切分成 200 份，每个 512 M</li></ol></li><li><ol start="2"><li>分别对 512 M 排序，因为内存已经可以放的下，所以任意排序方式都可以</li></ol></li><li><ol start="3"><li>进行 200 路归并，同时对 200 份有序文件做归并过程，最终结果就有序了</li></ol></li></ul><h2 id="10-排序总结"><a href="#10-排序总结" class="headerlink" title="10.  排序总结"></a>10.  排序总结</h2><p><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93.png" alt=" "></p><p>排序方法|最好|平均|最坏|空间复杂度|稳定性<br>:-:|:-:|:-:|:-:|:-:|:-:|:-:<br>冒泡排序|O(n)|O(n^2)|O(n^2)|O(1)|稳定<br>插入排序|O(n)|O(n^2)|O(n^2)|O(1)|稳定<br>选择排序|O(n^2)|O(n^2)|O(n^2)|O(1)|不稳定<br>希尔排序|O(n)|O(n^1.3)|O(n^2)|O(1)|不稳定<br>堆排序|O(n<em>log(n))|O(n</em>log(n))|O(n<em>log(n))|O(1)|不稳定<br>快速排序|O(n</em>log(n))|O(n<em>log(n))|O(n^2)|O(log(n))~O(n)|不稳定<br>归并排序|O(n</em>log(n))|O(n<em>log(n))|O(n</em>log(n))|O(n)|稳定</p><h2 id="11-其他非基于比较的排序"><a href="#11-其他非基于比较的排序" class="headerlink" title="11. 其他非基于比较的排序"></a>11. 其他非基于比较的排序</h2><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a><a href="https://zhuanlan.zhihu.com/p/26595385?group_id=842495057868226560" target="_blank" rel="noopener">计数排序</a></h3><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a><a href="https://www.runoob.com/w3cnote/radix-sort.html" target="_blank" rel="noopener">基数排序</a></h3><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a><a href="https://www.cnblogs.com/bqwzx/p/11029264.html" target="_blank" rel="noopener">桶排序</a></h3>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap和TreeMap对比</title>
      <link href="/2019/12/04/HashMap%E5%92%8CTreeMap%E5%AF%B9%E6%AF%94/"/>
      <url>/2019/12/04/HashMap%E5%92%8CTreeMap%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap主要用来存放键值对，它基于哈希表的Map接口实现，是常用的Java集合之一，数据是无序的</p><p><img src="/2019/12/04/HashMap%E5%92%8CTreeMap%E5%AF%B9%E6%AF%94/HashMap%E5%AD%98%E6%94%BE.png" alt="HashMap存放"></p><p>jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p><p><img src="/2019/12/04/HashMap%E5%92%8CTreeMap%E5%AF%B9%E6%AF%94/jdk1.8%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81.png" alt="jdk1.8解决哈希冲突"></p><p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的.</p><p>HashMap的时间复杂度O(1),但是如果冲突较多，链表的时间复杂度是O(n)，所以在JDK1.8 以后，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间，红黑树的时间复杂度是O(log n)。 所以查询一个HashMap数据的时间为 O(1) + O(n)或O(1) + O(log n）平均为O(1)<br>总结：HashMap根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度，插入、删除和定位元素，HashMap是最好的选择。</p><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap是基于红黑树实现的一个保证有序性的Map 基于红黑树，所以TreeMap的时间复杂度是O(log n)，如果需要有排序的数据，直接存放进TreeMap中就行，TreeMap自己会给排序，不需要再写排序代码。</p><p>总结：TreeMap取出来的是排序后的键值对。插入、删除需要维护平衡会牺牲一些效率。但如果要按自然顺序或自定义顺序遍历，那么TreeMap会更好。</p><p>HashMap通过hashcode对其内容进行快速查找，而 TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap。HashMap通常比TreeMap效率要高一些，一个是哈希表，一个是二叉树，建议多使用HashMap，在需要排序的Map时候才用TreeMap。HashMap的查询速度比TreeMap要快</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> HashMap </tag>
            
            <tag> TreeMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合类：Set、List、Map使用场景</title>
      <link href="/2019/11/08/Java%E9%9B%86%E5%90%88%E7%B1%BB%EF%BC%9ASet%E3%80%81List%E3%80%81Map%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2019/11/08/Java%E9%9B%86%E5%90%88%E7%B1%BB%EF%BC%9ASet%E3%80%81List%E3%80%81Map%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-Java集合类基本概念"><a href="#1-Java集合类基本概念" class="headerlink" title="1. Java集合类基本概念"></a>1. Java集合类基本概念</h2><p>&emsp;在编程中，常常需要集中存放多个数据。从传统意义上讲，数组是我们的一个很好的选择，前提是我们事先已经明确知道我们将要保存的对象的数量。一旦在数组初始化时指定了这个数组长度，这个数组长度就是不可变的，如果我们需要保存一个可以动态增长的数据(在编译时无法确定具体的数量)，java的集合类就是一个很好的设计方案了。</p><p>&emsp;集合类主要负责保存、盛装其他数据，因此集合类也被称为容器类。所以的集合类都位于java.util包下，后来为了处理多线程环境下的并发安全问题，java5还在java.util.concurrent包下提供了一些多线程支持的集合类。</p><p>&emsp;在学习Java中的集合类的API、编程原理的时候，我们一定要明白，”集合”是一个很古老的数学概念，它远远早于Java的出现。从数学概念的角度来理解集合能帮助我们更好的理解编程中什么时候该使用什么类型的集合类。</p><p><img src="/2019/11/08/Java%E9%9B%86%E5%90%88%E7%B1%BB%EF%BC%9ASet%E3%80%81List%E3%80%81Map%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.jpg" alt="java集合框架"></p><p>Java容器类类库的用途是”保存对象”，并将其划分为两个不同的概念：</p><h3 id="1-Collection"><a href="#1-Collection" class="headerlink" title="1) Collection"></a>1) Collection</h3><p>一组”对立”的元素，通常这些元素都服从某种规则</p><ul><li><p>1.1) List必须保持元素特定的顺序</p></li><li><p>1.2) Set不能有重复元素</p></li><li><p>1.3) Queue保持一个队列(先进先出)的顺序</p></li></ul><h3 id="2-Map"><a href="#2-Map" class="headerlink" title="2) Map"></a>2) Map</h3><p>一组成对的”键值对”对象</p><p>Collection和Map的区别在于容器中每个位置保存的元素个数:</p><ul><li>1) Collection 每个位置只能保存一个元素(对象)</li><li>2) Map保存的是”键值对”，就像一个小型数据库。我们可以通过”键”找到该键对应的”值”</li></ul><h2 id="2-Java集合类架构层次关系"><a href="#2-Java集合类架构层次关系" class="headerlink" title="2. Java集合类架构层次关系"></a>2. Java集合类架构层次关系</h2><h3 id="1）Interface-Iterable"><a href="#1）Interface-Iterable" class="headerlink" title="1）Interface Iterable"></a>1）Interface Iterable</h3><blockquote><p>迭代器接口，这是Collection类的父接口。实现这个Iterable接口的对象允许使用foreach进行遍历，也就是说，所有的Collection集合对象都具有”foreach可遍历性”。这个Iterable接口只有一个方法: iterator()。它返回一个代表当前集合对象的泛型&lt; T &gt;迭代器，用于之后的遍历操作</p></blockquote><h4 id="1-1-Collection"><a href="#1-1-Collection" class="headerlink" title="1.1 Collection"></a>1.1 Collection</h4><blockquote><p>Collection是最基本的集合接口，一个Collection代表一组Object的集合，这些Object被称作Collection的元素。Collection是一个接口，用以提供规范定义，不能被实例化使用</p></blockquote><h5 id="1-Set"><a href="#1-Set" class="headerlink" title="1) Set"></a>1) Set</h5><blockquote><p>Set集合类似于一个罐子，”丢进”Set集合里的多个对象之间没有明显的顺序。Set继承自Collection接口，不能包含有重复元素(记住，这是整个Set类层次的共有属性)。</p></blockquote><p>Set判断两个对象相同不是使用”==”运算符，而是根据equals方法。也就是说，我们在加入一个新元素的时候，如果这个新元素对象和Set中已有对象进行注意equals比较都返回false，　　<br>则Set就会接受这个新元素对象，否则拒绝。</p><p>因为Set的这个制约，在使用Set集合的时候，应该注意两点：</p><ul><li><p>1) 为Set集合里的元素的实现类实现一个有效的equals(Object)方法</p></li><li><p>2) 对Set的构造函数，传入的Collection参数不能包<br>　　含重复的元素</p></li></ul><h6 id="1-1-HashSet"><a href="#1-1-HashSet" class="headerlink" title="1.1) HashSet"></a>1.1) HashSet</h6><blockquote><p>HashSet是Set接口的典型实现，HashSet使用HASH算法来存储集合中的元素，因此具有良好的存取和查找性能。当向HashSet集合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据该HashCode值决定该对象在HashSet中的存储位置。</p></blockquote><p>值得主要的是，HashSet集合判断两个元素相等的标准是两个对象通过equals()方法比较相等，并且两个对象的hashCode()方法的返回值相等</p><ul><li>1.1.1) LinkedHashSet</li></ul><blockquote><p>LinkedHashSet集合也是根据元素的hashCode值来决定元素的存储位置，但和HashSet不同的是，它同时使用链表维护元素的次序，这样使得元素看起来是以插入的顺序保存的。当遍历LinkedHashSet集合里的元素时,LinkedHashSet将会按元素的添加顺序来访问集合里的元素。</p></blockquote><p>LinkedHashSet需要维护元素的插入顺序，因此性能略低于HashSet的性能，但在迭代访问Set里的全部元素时(遍历)将有很好的性能(链表很适合进行遍历)</p><h6 id="1-2-SortedSet"><a href="#1-2-SortedSet" class="headerlink" title="1.2) SortedSet"></a>1.2) SortedSet</h6><blockquote><p>此接口主要用于排序操作，即实现此接口的子类都属于排序的子类</p></blockquote><ul><li>1.2.1) TreeSet</li></ul><blockquote><p>TreeSet是SortedSet接口的实现类，TreeSet可以确保集合元素处于排序状态</p></blockquote><h6 id="1-3-EnumSet"><a href="#1-3-EnumSet" class="headerlink" title="1.3) EnumSet"></a>1.3) EnumSet</h6><blockquote><p>EnumSet是一个专门为枚举类设计的集合类，EnumSet中所有元素都必须是指定枚举类型的枚举值，该枚举类型在创建EnumSet时显式、或隐式地指定。EnumSet的集合元素也是有序的，<br>它们以枚举值在Enum类内的定义顺序来决定集合元素的顺序</p></blockquote><h5 id="2-List"><a href="#2-List" class="headerlink" title="2) List"></a>2) List</h5><blockquote><p>List集合代表一个元素有序、可重复的集合，集合中每个元素都有其对应的顺序索引。List集合允许加入重复元素，因为它可以通过索引来访问指定位置的集合元素。List集合默认按元素的添加顺序设置元素的索引</p></blockquote><h6 id="2-1-ArrayList"><a href="#2-1-ArrayList" class="headerlink" title="2.1) ArrayList"></a>2.1) ArrayList</h6><blockquote><p>ArrayList是基于数组实现的List类，它封装了一个动态的增长的、允许再分配的Object[]数组。</p></blockquote><h6 id="2-2-Vector"><a href="#2-2-Vector" class="headerlink" title="2.2) Vector"></a>2.2) Vector</h6><blockquote><p>Vector和ArrayList在用法上几乎完全相同，但由于Vector是一个古老的集合，所以Vector提供了一些方法名很长的方法，但随着JDK1.2以后，java提供了系统的集合框架，就将<br>Vector改为实现List接口，统一归入集合框架体系中</p></blockquote><ul><li>2.2.1) Stack</li></ul><blockquote><p>Stack是Vector提供的一个子类，用于模拟”栈”这种数据结构(LIFO后进先出)</p></blockquote><h6 id="2-3-LinkedList"><a href="#2-3-LinkedList" class="headerlink" title="2.3) LinkedList"></a>2.3) LinkedList</h6><blockquote><p>implements List&lt; E &gt;, Deque&lt; E &gt;。实现List接口，能对它进行队列操作，即可以根据索引来随机访问集合中的元素。同时它还实现Deque接口，即能将LinkedList当作双端队列<br>使用。自然也可以被当作”栈来使用”</p></blockquote><h5 id="3-Queue"><a href="#3-Queue" class="headerlink" title="3) Queue"></a>3) Queue</h5><blockquote><p>Queue用于模拟”队列”这种数据结构(先进先出 FIFO)。队列的头部保存着队列中存放时间最长的元素，队列的尾部保存着队列中存放时间最短的元素。新元素插入(offer)到队列的尾部，访问元素(poll)操作会返回队列头部的元素，队列不允许随机访问队列中的元素。结合生活中常见的排队就会很好理解这个概念</p></blockquote><h6 id="3-1-PriorityQueue"><a href="#3-1-PriorityQueue" class="headerlink" title="3.1) PriorityQueue"></a>3.1) PriorityQueue</h6><blockquote><p>PriorityQueue并不是一个比较标准的队列实现，PriorityQueue保存队列元素的顺序并不是按照加入队列的顺序，而是按照队列元素的大小进行重新排序，这点从它的类名也可以看出来。</p></blockquote><h6 id="3-2-Deque"><a href="#3-2-Deque" class="headerlink" title="3.2) Deque"></a>3.2) Deque</h6><blockquote><p>Deque接口代表一个”双端队列”，双端队列可以同时从两端来添加、删除元素，因此Deque的实现类既可以当成队列使用、也可以当成栈使用</p></blockquote><ul><li>3.2.1) ArrayDeque</li></ul><blockquote><p>是一个基于数组的双端队列，和ArrayList类似，它们的底层都采用一个动态的、可重分配的Object[]数组来存储集合元素，当集合元素超出该数组的容量时，系统会在底层重新分配一个Object[]数组来存储集合元素</p></blockquote><ul><li>3.2.2) LinkedList</li></ul><blockquote><p>LinkedList基于链表的数据结构,地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址，对于新增和删除操作add和remove，LinedList比较占优势。</p></blockquote><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><blockquote><p>Map用于保存具有”映射关系”的数据，因此Map集合里保存着两组值，一组值用于保存Map里的key，另外一组值用于保存Map里的value。key和value都可以是任何引用类型的数据。Map的key不允许重复，即同一个Map对象的任何两个key通过equals方法比较结果总是返回false。关于Map，我们要从代码复用的角度去理解，java是先实现了Map，然后通过包装了一个所有value都为null的Map就实现了Set集合</p></blockquote><p>Map的这些实现类和子接口中key集的存储形式和Set集合完全相同(即key不能重复)</p><p>Map的这些实现类和子接口中value集的存储形式和List非常类似(即value可以重复、根据索引来查找)</p><h5 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1) HashMap"></a>1) HashMap</h5><blockquote><p>和HashSet集合不能保证元素的顺序一样，HashMap也不能保证key-value对的顺序。并且类似于HashSet判断两个key是否相等的标准也是: 两个key通过equals()方法比较返回true、<br>同时两个key的hashCode值也必须相等</p></blockquote><h6 id="1-1-LinkedHashMap"><a href="#1-1-LinkedHashMap" class="headerlink" title="1.1) LinkedHashMap"></a>1.1) LinkedHashMap</h6><blockquote><p>LinkedHashMap也使用双向链表来维护key-value对的次序，该链表负责维护Map的迭代顺序，与key-value对的插入顺序一致(注意和TreeMap对所有的key-value进行排序进行区<br>分)</p></blockquote><h5 id="2-Hashtable"><a href="#2-Hashtable" class="headerlink" title="2) Hashtable"></a>2) Hashtable</h5><blockquote><p>是一个古老的Map实现类</p></blockquote><h6 id="2-1-Properties"><a href="#2-1-Properties" class="headerlink" title="2.1) Properties"></a>2.1) Properties</h6><blockquote><p>Properties对象在处理属性文件时特别方便(windows平台上的.ini文件)，Properties类可以把Map对象和属性文件关联起来，从而可以把Map对象中的key-value对写入到属性文件中，也可以把属性文件中的”属性名-属性值”加载到Map对象中</p></blockquote><h5 id="3-SortedMap"><a href="#3-SortedMap" class="headerlink" title="3) SortedMap"></a>3) SortedMap</h5><blockquote><p>正如Set接口派生出SortedSet子接口，SortedSet接口有一个TreeSet实现类一样，Map接口也派生出一个SortedMap子接口，SortedMap接口也有一个TreeMap实现类</p></blockquote><h6 id="3-1-TreeMap"><a href="#3-1-TreeMap" class="headerlink" title="3.1) TreeMap"></a>3.1) TreeMap</h6><blockquote><p>TreeMap就是一个红黑树数据结构，每个key-value对即作为红黑树的一个节点。TreeMap存储key-value对(节点)时，需要根据key对节点进行排序。TreeMap可以保证所有的<br>key-value对处于有序状态。同样，TreeMap也有两种排序方式: 自然排序、定制排序</p></blockquote><h5 id="4-WeakHashMap"><a href="#4-WeakHashMap" class="headerlink" title="4) WeakHashMap"></a>4) WeakHashMap</h5><blockquote><p>WeakHashMap与HashMap的用法基本相似。区别在于，HashMap的key保留了对实际对象的”强引用”，这意味着只要该HashMap对象不被销毁，该HashMap所引用的对象就不会被垃圾回收。但WeakHashMap的key只保留了对实际对象的弱引用，这意味着如果WeakHashMap对象的key所引用的对象没有被其他强引用变量所引用，则这些key所引用的对象可能被垃圾回收，当垃圾回收了该key所对应的实际对象之后，WeakHashMap也可能自动删除这些key所对应的key-value对</p></blockquote><h5 id="5-IdentityHashMap"><a href="#5-IdentityHashMap" class="headerlink" title="5) IdentityHashMap"></a>5) IdentityHashMap</h5><blockquote><p>IdentityHashMap的实现机制与HashMap基本相似，在IdentityHashMap中，当且仅当两个key严格相等(key1 == key2)时，IdentityHashMap才认为两个key相等</p></blockquote><h5 id="6-EnumMap"><a href="#6-EnumMap" class="headerlink" title="6) EnumMap"></a>6) EnumMap</h5><blockquote><p>EnumMap是一个与枚举类一起使用的Map实现，EnumMap中的所有key都必须是单个枚举类的枚举值。创建EnumMap时必须显式或隐式指定它对应的枚举类。EnumMap根据key的自然顺序<br>(即枚举值在枚举类中的定义顺序)</p></blockquote><h2 id="3-Java集合类的应用场景代码"><a href="#3-Java集合类的应用场景代码" class="headerlink" title="3. Java集合类的应用场景代码"></a>3. Java集合类的应用场景代码</h2><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">//类A的equals方法总是返回true,但没有重写其hashCode()方法。不能保证当前对象是HashSet中的唯一对象class A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类B的hashCode()方法总是返回1,但没有重写其equals()方法。不能保证当前对象是HashSet中的唯一对象class B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类C的hashCode()方法总是返回2,且有重写其equals()方法class C</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        HashSet books = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="comment">//分别向books集合中添加两个A对象，两个B对象，两个C对象</span></span><br><span class="line">        books.add(<span class="keyword">new</span> A());</span><br><span class="line">        books.add(<span class="keyword">new</span> A());</span><br><span class="line">        books.add(<span class="keyword">new</span> B());</span><br><span class="line">        books.add(<span class="keyword">new</span> B());</span><br><span class="line">        books.add(<span class="keyword">new</span> C());</span><br><span class="line">        books.add(<span class="keyword">new</span> C());</span><br><span class="line">        System.out.println(books);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">result:</span><br><span class="line">[B@<span class="number">1</span>, B@<span class="number">1</span>, C@<span class="number">2</span>, A@<span class="number">3</span>bc257, A@<span class="number">785</span>d65]</span><br></pre></td></tr></table></figure><p>可以看到，如果两个对象通过equals()方法比较返回true，但这两个对象的hashCode()方法返回不同的hashCode值时，这将导致HashSet会把这两个对象保存在Hash表的不同位置，从而使对象可以添加成功，这就与Set集合的规则有些出入了。所以，我们要明确的是: equals()决定是否可以加入HashSet、而hashCode()决定存放的位置，它们两者必须同时满足才能允许一个新元素加入HashSet<br>但是要注意的是: 如果两个对象的hashCode相同，但是它们的equlas返回值不同，HashSet会在这个位置用链式结构来保存多个对象。而HashSet访问集合元素时也是根据元素的HashCode值来快速定位的，这种链式结构会导致性能下降。<br>所以如果需要把某个类的对象保存到HashSet集合中，我们在重写这个类的equlas()方法和hashCode()方法时，应该尽量保证两个对象通过equals()方法比较返回true时，它们的hashCode()方法返回值也相等</p><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSetTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LinkedHashSet books = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">        books.add(<span class="string">"Java"</span>);</span><br><span class="line">        books.add(<span class="string">"LittleHann"</span>);</span><br><span class="line">        System.out.println(books);</span><br><span class="line">        <span class="comment">//删除 Java</span></span><br><span class="line">      books.remove(<span class="string">"Java"</span>);</span><br><span class="line">        <span class="comment">//重新添加 Java</span></span><br><span class="line">        books.add(<span class="string">"Java"</span>);</span><br><span class="line">        System.out.println(books);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>元素的顺序总是与添加顺序一致，同时要明白的是，LinkedHashSetTest是HashSet的子类，因此它不允许集合元素重复</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TreeSet nums = <span class="keyword">new</span> TreeSet();</span><br><span class="line">        <span class="comment">//向TreeSet中添加四个Integer对象</span></span><br><span class="line">        nums.add(<span class="number">5</span>);</span><br><span class="line">        nums.add(<span class="number">2</span>);</span><br><span class="line">        nums.add(<span class="number">10</span>);</span><br><span class="line">        nums.add(-<span class="number">9</span>);</span><br><span class="line">        <span class="comment">//输出集合元素，看到集合元素已经处于排序状态</span></span><br><span class="line">        System.out.println(nums);</span><br><span class="line">        <span class="comment">//输出集合里的第一个元素</span></span><br><span class="line">        System.out.println(nums.first());</span><br><span class="line">        <span class="comment">//输出集合里的最后一个元素</span></span><br><span class="line">        System.out.println(nums.last());</span><br><span class="line">        <span class="comment">//返回小于4的子集，不包含4</span></span><br><span class="line">        System.out.println(nums.headSet(<span class="number">4</span>));</span><br><span class="line">        <span class="comment">//返回大于5的子集，如果Set中包含5，子集中还包含5</span></span><br><span class="line">        System.out.println(nums.tailSet(<span class="number">5</span>));</span><br><span class="line">        <span class="comment">//返回大于等于-3，小于4的子集。</span></span><br><span class="line">        System.out.println(nums.subSet(-<span class="number">3</span> , <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与HashSet集合采用hash算法来决定元素的存储位置不同，TreeSet采用红黑树的数据结构来存储集合元素。TreeSet支持两种排序方式: 自然排序、定制排序</p><ul><li>自然排序:</li></ul><blockquote><p>TreeSet会调用集合元素的compareTo(Object obj)方法来比较元素之间的大小关系，然后将集合元素按升序排序，即自然排序。如果试图把一个对象添加到TreeSet时，则该对象的类必须实现Comparable接口，否则程序会抛出异常。当把一个对象加入TreeSet集合中时，TreeSet会调用该对象的compareTo(Object obj)方法与容器中的其他对象比较大小，然后根据红黑树结构找到它的存储位置。如果两个对象通过compareTo(Object obj)方法比较相等，新对象将无法添加到TreeSet集合中(牢记Set是不允许重复的概念)。</p></blockquote><p>注意: 当需要把一个对象放入TreeSet中，重写该对象对应类的equals()方法时，应该保证该方法与compareTo(Object obj)方法有一致的结果，即如果两个对象通过equals()方法比较返回true时，这两个对象通过compareTo(Object obj)方法比较结果应该也为0(即相等)</p><p>看到这里，我们应该明白：</p><p>1) 对与Set来说，它定义了equals()为唯一性判断的标准，而对于到了具体的实现，HashSet、TreeSet来说，它们又会有自己特有的唯一性判断标准，只有同时满足了才能判定为唯一性</p><p>2) 我们在操作这些集合类的时候，对和唯一性判断有关的函数重写要重点关注</p><ul><li>定制排序</li></ul><blockquote><p>TreeSet的自然排序是根据集合元素的大小，TreeSet将它们以升序排序。如果我们需要实现定制排序，则可以通过Comparator接口的帮助(类似PHP中的array_map回调处理函数的思想)。该接口里包含一个int compare(T o1， T o2)方法，该方法用于比较大小</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">M</span><span class="params">(<span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"M[age:"</span> + age + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest4</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TreeSet ts = <span class="keyword">new</span> TreeSet(<span class="keyword">new</span> Comparator()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//根据M对象的age属性来决定大小</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                M m1 = (M)o1;</span><br><span class="line">                M m2 = (M)o2;</span><br><span class="line">                <span class="keyword">return</span> m1.age &gt; m2.age ? -<span class="number">1</span></span><br><span class="line">                    : m1.age &lt; m2.age ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ts.add(<span class="keyword">new</span> M(<span class="number">5</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> M(-<span class="number">3</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> M(<span class="number">9</span>));</span><br><span class="line">        System.out.println(ts);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1) equals、compareTo决定的是怎么比的问题，即用什么field进行大小比较<br>2) 自然排序、定制排序、Comparator决定的是谁大的问题，即按什么顺序(升序、降序)进行排序它们的关注点是不同的，一定要注意区分</p><h3 id="EnumSet"><a href="#EnumSet" class="headerlink" title="EnumSet"></a>EnumSet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">enum</span> Season</span><br><span class="line">&#123;</span><br><span class="line">    SPRING,SUMMER,FALL,WINTER</span><br><span class="line">&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSetTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个EnumSet集合，集合元素就是Season枚举类的全部枚举值</span></span><br><span class="line">        EnumSet es1 = EnumSet.allOf(Season<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//输出[SPRING,SUMMER,FALL,WINTER]</span></span><br><span class="line">        System.out.println(es1);</span><br><span class="line">        <span class="comment">//创建一个EnumSet空集合，指定其集合元素是Season类的枚举值。</span></span><br><span class="line">        EnumSet es2 = EnumSet.noneOf(Season<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//输出[]</span></span><br><span class="line">        System.out.println(es2);</span><br><span class="line">        <span class="comment">//手动添加两个元素        es2.add(Season.WINTER);</span></span><br><span class="line">        es2.add(Season.SPRING);</span><br><span class="line">        <span class="comment">//输出[SPRING,WINTER]</span></span><br><span class="line">        System.out.println(es2);</span><br><span class="line">        <span class="comment">//以指定枚举值创建EnumSet集合</span></span><br><span class="line">        EnumSet es3 = EnumSet.of(Season.SUMMER , Season.WINTER);</span><br><span class="line">        <span class="comment">//输出[SUMMER,WINTER]</span></span><br><span class="line">        System.out.println(es3);</span><br><span class="line">        EnumSet es4 = EnumSet.range(Season.SUMMER , Season.WINTER);</span><br><span class="line">        <span class="comment">//输出[SUMMER,FALL,WINTER]</span></span><br><span class="line">        System.out.println(es4);</span><br><span class="line">        <span class="comment">//新创建的EnumSet集合的元素和es4集合的元素有相同类型，</span></span><br><span class="line">        <span class="comment">//es5的集合元素 + es4集合元素 = Season枚举类的全部枚举值</span></span><br><span class="line">        EnumSet es5 = EnumSet.complementOf(es4);</span><br><span class="line">        <span class="comment">//输出[SPRING]</span></span><br><span class="line">        System.out.println(es5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是Set集合类的编程应用场景。那么应该怎样选择何时使用这些集合类呢？</p><p>1) HashSet的性能总是比TreeSet好(特别是最常用的添加、查询元素等操作)，因为TreeSet需要额外的红黑树算法来维护集合元素的次序。只有当需要一个保持排序的Set时，才应该使用TreeSet，否则都应该使用HashSet</p><p>2) 对于普通的插入、删除操作，LinkedHashSet比HashSet要略慢一点，这是由维护链表所带来的开销造成的。不过，因为有了链表的存在，遍历LinkedHashSet会更快</p><p>3) EnumSet是所有Set实现类中性能最好的，但它只能保存同一个枚举类的枚举值作为集合元素</p><p>4) HashSet、TreeSet、EnumSet都是”线程不安全”的，通常可以通过Collections工具类的synchronizedSortedSet方法来”包装”该Set集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SortedSet s = Collections.synchronizedSortedSet(<span class="keyword">new</span> TreeSet(...));</span><br></pre></td></tr></table></figure><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>如果一开始就知道ArrayList集合需要保存多少元素，则可以在创建它们时就指定initialCapacity大小，这样可以减少重新分配的次数，提供性能，ArrayList还提供了如下方法来重新分配Object[]数组</p><p>1) ensureCapacity(int minCapacity): 将ArrayList集合的Object[]数组长度增加minCapacity</p><p>2) trimToSize(): 调整ArrayList集合的Object[]数组长度为当前元素的个数。程序可以通过此方法来减少ArrayList集合对象占用的内存空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List books = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="comment">//向books集合中添加三个元素</span></span><br><span class="line">        books.add(<span class="keyword">new</span> String(<span class="string">"轻量级Java EE应用"</span>));</span><br><span class="line">        books.add(<span class="keyword">new</span> String(<span class="string">"疯狂Java"</span>));</span><br><span class="line">        books.add(<span class="keyword">new</span> String(<span class="string">"疯狂Android"</span>));</span><br><span class="line">        System.out.println(books);</span><br><span class="line">        <span class="comment">//将新字符串对象插入在第二个位置</span></span><br><span class="line">        books.add(<span class="number">1</span> , <span class="keyword">new</span> String(<span class="string">"疯狂Ajax"</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; books.size() ; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(books.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除第三个元素</span></span><br><span class="line">        books.remove(<span class="number">2</span>);</span><br><span class="line">        System.out.println(books);</span><br><span class="line">        <span class="comment">//判断指定元素在List集合中位置：输出1，表明位于第二位</span></span><br><span class="line">        System.out.println(books.indexOf(<span class="keyword">new</span> String(<span class="string">"疯狂Ajax"</span>)));  <span class="comment">//①</span></span><br><span class="line">        <span class="comment">//将第二个元素替换成新的字符串对象</span></span><br><span class="line">        books.set(<span class="number">1</span>, <span class="keyword">new</span> String(<span class="string">"LittleHann"</span>));</span><br><span class="line">        System.out.println(books);</span><br><span class="line">        <span class="comment">//将books集合的第二个元素（包括）</span></span><br><span class="line">        <span class="comment">//到第三个元素（不包括）截取成子集合</span></span><br><span class="line">        System.out.println(books.subList(<span class="number">1</span> , <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>List集合类的编程应用场景。我们来梳理一下</p><ol><li><p>java提供的List就是一个”线性表接口”，ArrayList(基于数组的线性表)、LinkedList(基于链的线性表)是线性表的两种典型实现</p></li><li><p>因为数组以一块连续内存来保存所有的数组元素，所以数组在随机访问时性能最好。所以的内部以数组作为底层实现的集合在随机访问时性能最好。</p></li><li><p>内部以链表作为底层实现的集合在执行插入、删除操作时有很好的性能</p></li><li><p>进行迭代操作时，以链表作为底层实现的集合比以数组作为底层实现的集合性能好</p></li></ol><p>我们之前说过，Collection接口继承了Iterable接口，也就是说，我们以上学习到的所有的Collection集合类都具有”可遍历性”</p><p>Iterable接口也是java集合框架的成员，它隐藏了各种Collection实现类的底层细节，向应用程序提供了遍历Collection集合元素的统一编程接口:</p><p>1) boolean hasNext(): 是否还有下一个未遍历过的元素</p><p>2) Object next(): 返回集合里的下一个元素</p><p>3) void remove(): 删除集合里上一次next方法返回的元素</p><p><strong>iterator实现遍历:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个集合</span></span><br><span class="line">        Collection books = <span class="keyword">new</span> HashSet();</span><br><span class="line">        books.add(<span class="string">"轻量级Java EE应用"</span>);</span><br><span class="line">        books.add(<span class="string">"疯狂Java"</span>);</span><br><span class="line">        books.add(<span class="string">"疯狂Android"</span>);</span><br><span class="line">        <span class="comment">//获取books集合对应的迭代器</span></span><br><span class="line">        Iterator it = books.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//it.next()方法返回的数据类型是Object类型，</span></span><br><span class="line">            <span class="comment">//需要强制类型转换</span></span><br><span class="line">            String book = (String)it.next();</span><br><span class="line">            System.out.println(book);</span><br><span class="line">            <span class="keyword">if</span> (book.equals(<span class="string">"疯狂Java"</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//从集合中删除上一次next方法返回的元素                it.remove();</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//对book变量赋值，不会改变集合元素本身</span></span><br><span class="line">            book = <span class="string">"测试字符串"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(books);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码可以看出，iterator必须依附于Collection对象，若有一个iterator对象，必然有一个与之关联的Collection对象。</p><p>除了可以使用iterator接口迭代访问Collection集合里的元素之外，使用java5提供的foreach循环迭代访问集合元素更加便捷</p><p><strong>foreach实现遍历:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForeachTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个集合</span></span><br><span class="line">        Collection books = <span class="keyword">new</span> HashSet();</span><br><span class="line">        books.add(<span class="keyword">new</span> String(<span class="string">"轻量级Java EE应用"</span>));</span><br><span class="line">        books.add(<span class="keyword">new</span> String(<span class="string">"疯狂Java"</span>));</span><br><span class="line">        books.add(<span class="keyword">new</span> String(<span class="string">"疯狂Android"</span>));</span><br><span class="line">        <span class="keyword">for</span> (Object obj : books)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//此处的book变量也不是集合元素本身</span></span><br><span class="line">            String book = (String)obj;</span><br><span class="line">            System.out.println(book);</span><br><span class="line">            <span class="keyword">if</span> (book.equals(<span class="string">"疯狂Android"</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//下面代码会引发ConcurrentModificationException异常</span></span><br><span class="line">                <span class="comment">//books.remove(book);                  &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(books);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了Collection固有的iterator()方法，List还额外提供了一个listIterator()方法，该方法返回一个ListIterator对象，ListIterator接口继承了Iterator接口，提供了专门操作List的方法。ListIterator接口在Iterator接口的继承上增加了如下方法:</p><p>1) boolean hasPrevious(): 返回该迭代器关联的集合是否还有上一个元素</p><p>2) Object previous(): 返回该迭代器的上一个元素(向前迭代)</p><p>3) void add(): 在指定位置插入一个元素</p><p><strong>ListIterator实现遍历:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListIteratorTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String[] books = &#123;</span><br><span class="line">            <span class="string">"疯狂Java"</span>,</span><br><span class="line">            <span class="string">"轻量级Java EE应用"</span></span><br><span class="line">        &#125;;</span><br><span class="line">        List bookList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; books.length ; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            bookList.add(books[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ListIterator lit = bookList.listIterator();</span><br><span class="line">        <span class="keyword">while</span> (lit.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(lit.next());</span><br><span class="line">            lit.add(<span class="string">"-------分隔符-------"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"=======下面开始反向迭代======="</span>);</span><br><span class="line">        <span class="keyword">while</span>(lit.hasPrevious())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(lit.previous());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map实现"><a href="#Map实现" class="headerlink" title="Map实现"></a>Map实现</h3><h4 id="HashMap、Hashtable"><a href="#HashMap、Hashtable" class="headerlink" title="HashMap、Hashtable"></a>HashMap、Hashtable</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据count的值来判断两个对象是否相等。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj!=<span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            obj.getClass()==A<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        </span>&#123;</span><br><span class="line">            A a = (A)obj;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.count == a.count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据count来计算hashCode值。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//重写equals()方法，B对象与任何对象通过equals()方法比较都相等</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashtableTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Hashtable ht = <span class="keyword">new</span> Hashtable();</span><br><span class="line">        ht.put(<span class="keyword">new</span> A(<span class="number">60000</span>) , <span class="string">"疯狂Java"</span>);</span><br><span class="line">        ht.put(<span class="keyword">new</span> A(<span class="number">87563</span>) , <span class="string">"轻量级Java EE应用"</span>);</span><br><span class="line">        ht.put(<span class="keyword">new</span> A(<span class="number">1232</span>) , <span class="keyword">new</span> B());</span><br><span class="line">        System.out.println(ht);</span><br><span class="line">        <span class="comment">//只要两个对象通过equals比较返回true，</span></span><br><span class="line">        <span class="comment">//Hashtable就认为它们是相等的value。</span></span><br><span class="line">        <span class="comment">//由于Hashtable中有一个B对象，</span></span><br><span class="line">        <span class="comment">//它与任何对象通过equals比较都相等，所以下面输出true。</span></span><br><span class="line">        System.out.println(ht.containsValue(<span class="string">"测试字符串"</span>));  <span class="comment">//①</span></span><br><span class="line">        <span class="comment">//只要两个A对象的count相等，它们通过equals比较返回true，且hashCode相等</span></span><br><span class="line">        <span class="comment">//Hashtable即认为它们是相同的key，所以下面输出true。</span></span><br><span class="line">        System.out.println(ht.containsKey(<span class="keyword">new</span> A(<span class="number">87563</span>)));   <span class="comment">//②</span></span><br><span class="line">        <span class="comment">//下面语句可以删除最后一个key-value对</span></span><br><span class="line">        ht.remove(<span class="keyword">new</span> A(<span class="number">1232</span>));    <span class="comment">//③</span></span><br><span class="line">        <span class="comment">//通过返回Hashtable的所有key组成的Set集合，</span></span><br><span class="line">        <span class="comment">//从而遍历Hashtable每个key-value对</span></span><br><span class="line">        <span class="keyword">for</span> (Object key : ht.keySet())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(key + <span class="string">"----&gt;"</span>);</span><br><span class="line">            System.out.print(ht.get(key) + <span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用自定义类作为HashMap、Hashtable的key时，如果重写该类的equals(Object obj)和hashCode()方法，则应该保证两个方法的判断标准一致–当两个key通过equals()方法比较返回true时，两个key的hashCode()的返回值也应该相同</p><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMapTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LinkedHashMap scores = <span class="keyword">new</span> LinkedHashMap();</span><br><span class="line">        scores.put(<span class="string">"语文"</span> , <span class="number">80</span>);</span><br><span class="line">        scores.put(<span class="string">"英文"</span> , <span class="number">82</span>);</span><br><span class="line">        scores.put(<span class="string">"数学"</span> , <span class="number">76</span>);</span><br><span class="line">        <span class="comment">//遍历scores里的所有的key-value对</span></span><br><span class="line">        <span class="keyword">for</span> (Object key : scores.keySet())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(key + <span class="string">"------&gt;"</span> + scores.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">R</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">R</span><span class="params">(<span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"R[count:"</span> + count + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据count来判断两个对象是否相等。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj!=<span class="keyword">null</span></span><br><span class="line">            &amp;&amp; obj.getClass()==R<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        </span>&#123;</span><br><span class="line">            R r = (R)obj;</span><br><span class="line">            <span class="keyword">return</span> r.count == <span class="keyword">this</span>.count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据count属性值来判断两个对象的大小。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        R r = (R)obj;</span><br><span class="line">        <span class="keyword">return</span> count &gt; r.count ? <span class="number">1</span> :</span><br><span class="line">            count &lt; r.count ? -<span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMapTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TreeMap tm = <span class="keyword">new</span> TreeMap();</span><br><span class="line">        tm.put(<span class="keyword">new</span> R(<span class="number">3</span>) , <span class="string">"轻量级Java EE应用"</span>);</span><br><span class="line">        tm.put(<span class="keyword">new</span> R(-<span class="number">5</span>) , <span class="string">"疯狂Java"</span>);</span><br><span class="line">        tm.put(<span class="keyword">new</span> R(<span class="number">9</span>) , <span class="string">"疯狂Android"</span>);</span><br><span class="line">        System.out.println(tm);</span><br><span class="line">        <span class="comment">//返回该TreeMap的第一个Entry对象</span></span><br><span class="line">        System.out.println(tm.firstEntry());</span><br><span class="line">        <span class="comment">//返回该TreeMap的最后一个key值</span></span><br><span class="line">        System.out.println(tm.lastKey());</span><br><span class="line">        <span class="comment">//返回该TreeMap的比new R(2)大的最小key值。</span></span><br><span class="line">        System.out.println(tm.higherKey(<span class="keyword">new</span> R(<span class="number">2</span>)));</span><br><span class="line">        <span class="comment">//返回该TreeMap的比new R(2)小的最大的key-value对。</span></span><br><span class="line">        System.out.println(tm.lowerEntry(<span class="keyword">new</span> R(<span class="number">2</span>)));</span><br><span class="line">        <span class="comment">//返回该TreeMap的子TreeMap</span></span><br><span class="line">        System.out.println(tm.subMap(<span class="keyword">new</span> R(-<span class="number">1</span>) , <span class="keyword">new</span> R(<span class="number">4</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，类似于TreeSet中判断两个元素是否相等的标准，TreeMap中判断两个key相等的标准是:</p><p>1) 两个key通过compareTo()方法返回0</p><p>2) equals()放回true</p><p>我们在重写这两个方法的时候一定要保证它们的逻辑关系一致。</p><p>强调一下:</p><p>Set和Map的关系十分密切，java源码就是先实现了HashMap、TreeMap等集合，然后通过包装一个所有的value都为null的Map集合实现了Set集合类</p><p>以上就是Map集合类的编程应用场景。我们来梳理一下思路</p><p>1) HashMap和Hashtable的效率大致相同，因为它们的实现机制几乎完全一样。但HashMap通常比Hashtable要快一点，因为Hashtable需要额外的线程同步控制</p><p>2) TreeMap通常比HashMap、Hashtable要慢(尤其是在插入、删除key-value对时更慢)，因为TreeMap底层采用红黑树来管理key-value对</p><p>3) 使用TreeMap的一个好处就是： TreeMap中的key-value对总是处于有序状态，无须专门进行排序操作</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Set </tag>
            
            <tag> List </tag>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HotSpot的算法实现</title>
      <link href="/2019/10/15/HotSpot%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/10/15/HotSpot%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2019/10/15/HotSpot%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/1.jpg" alt=" "></p><h2 id="1-枚举根节点"><a href="#1-枚举根节点" class="headerlink" title="1.枚举根节点"></a>1.枚举根节点</h2><p>　　在可达性分析中，可以作为GC Roots的节点有很多，但是现在很多应用仅仅方法区就有上百MB，如果逐个检查的话，效率就会变得不可接受。</p><p>　　而且，可达性分析必须在一个一致性的快照中进行-即整个分析期间，系统就像冻结了一样。否则如果一边分析，系统一边动态表化，得到的结果就没有准确性。这就导致了系统GC时必须停顿所有的Java执行线程。</p><p>　　目前主流Java虚拟机使用的都是准确式GC，所以当执行系统都停顿下来之后，并不需要一个不漏的检查完所有执行上下文和全局的引用位置，虚拟机应该有办法直接知道哪些地方存放着对象引用。在HotSpot实现中，使用一组称为 OopMap 的数据结构来达到这个目的。OopMap会在类加载完成的时候，记录对象内什么偏移量上是什么类型的数据，在JTI编译过程中，也会在特定的位置记录下栈和寄存器哪些位置是引用。这样，在GC扫描的时候就可以直接得到这些信息了。</p><h2 id="2-安全点"><a href="#2-安全点" class="headerlink" title="2.安全点"></a>2.安全点</h2><p>　　如果OopMap内容变化的指令非常多，HotSpot并不会为每条指令都产生OopMap，只是在特定的位置记录了这些信息，这些位置成为“安全点”（SafePoint）。程序执行时只有在达到安全点的时候才停顿开始GC。一般具有较长运行时间的指令才能被选为安全点，如方法调用、循环跳转、异常跳转等。</p><p>　　接下来要考虑的便是，如何在GC时保证所有的线程都“跑”到安全点上停顿下来。这里有两种方案： 抢先式中断 （Preemptive Suspension） 和主动式中断 （Voluntary Suspension）。</p><p>　　抢先式中断会把所有线程中断，如果某个线程不在安全点上，就恢复线程让它跑到安全点上。几乎没有虚拟机采用这种方式。</p><p>　　主动式中断思想是需要中断线程时，不直接对线程操作，而是设置一个GC标志，各个线程会轮询这个标志并在需要时自己中断挂起。这样，轮询标志的地方和安全点是重合的。</p><h2 id="3-安全区域"><a href="#3-安全区域" class="headerlink" title="3.安全区域"></a>3.安全区域</h2><p>　　安全点机制保证程序执行时，在不太长的时间内就会遇到可进入GC的安全点，但是，程序“不执行”的时候呢，程序不执行就是没有分配CPU时间，这时线程无法响应JVM的中断请求，JVM显然不太可能的等待线程重新被分配CPU时间。</p><p>　　安全区域是指一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。</p><p>　　在线程执行到安全区域代码时，首先标识自己进入安全区域，当这段时间里JVM发起GC，不用管标识为安全区域的线程了。在线程要离开安全区域时，要检查系统是否已经完成了根节点枚举，如果完成，线程继续执行，否则等待直到收到可以安全离开安全区域的信号为止。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机（JVM）你只要看这一篇就够了！</title>
      <link href="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/"/>
      <url>/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/JVM.png" alt="JVM"></p><h2 id="1-Java-内存区域与内存溢出异常"><a href="#1-Java-内存区域与内存溢出异常" class="headerlink" title="1.Java 内存区域与内存溢出异常"></a>1.Java 内存区域与内存溢出异常</h2><h3 id="1-1-运行时数据区域"><a href="#1-1-运行时数据区域" class="headerlink" title="1.1 运行时数据区域"></a>1.1 运行时数据区域</h3><blockquote><p>根据《Java 虚拟机规范(Java SE 7 版)》规定，Java 虚拟机所管理的内存如下图所示。</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.jpg" alt="Java虚拟机运行时数据区"></p><h4 id="1-1-1-程序计数器"><a href="#1-1-1-程序计数器" class="headerlink" title="1.1.1 程序计数器"></a>1.1.1 程序计数器</h4><blockquote><p>内存空间小，线程私有。字节码解释器工作是就是通过改变这个计数器的值来选取下一条需要执行指令的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成</p></blockquote><p>如果线程正在执行一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器的值则为 (Undefined)。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</p><h4 id="1-1-2-Java-虚拟机栈"><a href="#1-1-2-Java-虚拟机栈" class="headerlink" title="1.1.2 Java 虚拟机栈"></a>1.1.2 Java 虚拟机栈</h4><blockquote><p>线程私有，生命周期和线程一致。描述的是 Java 方法执行的内存模型：每个方法在执行时都会床创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。</p></blockquote><p>局部变量表：存放了编译期可知的各种基本类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference 类型)和 returnAddress 类型(指向了一条字节码指令的地址)</p><p>StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度。<br>OutOfMemoryError：如果虚拟机栈可以动态扩展，而扩展时无法申请到足够的内存。</p><h4 id="1-1-3-本地方法栈"><a href="#1-1-3-本地方法栈" class="headerlink" title="1.1.3 本地方法栈"></a>1.1.3 本地方法栈</h4><blockquote><p>区别于 Java 虚拟机栈的是，Java 虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。也会有 StackOverflowError 和 OutOfMemoryError 异常。</p></blockquote><h4 id="1-1-4-Java-堆"><a href="#1-1-4-Java-堆" class="headerlink" title="1.1.4 Java 堆"></a>1.1.4 Java 堆</h4><blockquote><p>对于绝大多数应用来说，这块区域是 JVM 所管理的内存中最大的一块。线程共享，主要是存放对象实例和数组。内部会划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)。可以位于物理上不连续的空间，但是逻辑上要连续。</p></blockquote><p>OutOfMemoryError：如果堆中没有内存完成实例分配，并且堆也无法再扩展时，抛出该异常。</p><h4 id="1-1-5-方法区"><a href="#1-1-5-方法区" class="headerlink" title="1.1.5 方法区"></a>1.1.5 方法区</h4><blockquote><p>属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p></blockquote><h4 id="1-1-6-运行时常量池"><a href="#1-1-6-运行时常量池" class="headerlink" title="1.1.6 运行时常量池"></a>1.1.6 运行时常量池</h4><blockquote><p>属于方法区一部分，用于存放编译期生成的各种字面量和符号引用。编译器和运行期(String 的 intern() )都可以将常量放入池中。内存有限，无法申请时抛出 OutOfMemoryError。</p></blockquote><h4 id="1-1-7-直接内存"><a href="#1-1-7-直接内存" class="headerlink" title="1.1.7 直接内存"></a>1.1.7 直接内存</h4><blockquote><p>非虚拟机运行时数据区的部分</p></blockquote><p>在 JDK 1.4 中新加入 NIO (New Input/Output) 类，引入了一种基于通道(Channel)和缓存(Buffer)的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。可以避免在 Java 堆和 Native 堆中来回的数据耗时操作。<br>OutOfMemoryError：会受到本机内存限制，如果内存区域总和大于物理内存限制从而导致动态扩展时出现该异常。</p><h3 id="1-2-HotSpot-虚拟机对象探秘"><a href="#1-2-HotSpot-虚拟机对象探秘" class="headerlink" title="1.2 HotSpot 虚拟机对象探秘"></a>1.2 HotSpot 虚拟机对象探秘</h3><blockquote><p>主要介绍数据是如何创建、如何布局以及如何访问的。</p></blockquote><h4 id="1-2-1-对象的创建"><a href="#1-2-1-对象的创建" class="headerlink" title="1.2.1 对象的创建"></a>1.2.1 对象的创建</h4><p>遇到 new 指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，执行相应的类加载。</p><p>类加载检查通过之后，为新对象分配内存(内存大小在类加载完成后便可确认)。在堆的空闲内存中划分一块区域(‘指针碰撞-内存规整’或‘空闲列表-内存交错’的分配方式)。</p><p>前面讲的每个线程在堆中都会有私有的分配缓冲区(TLAB)，这样可以很大程度避免在并发情况下频繁创建对象造成的线程不安全。</p><p>内存空间分配完成后会初始化为 0(不包括对象头)，接下来就是填充对象头，把对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息存入对象头。</p><p>执行 new 指令后执行 init 方法后才算一份真正可用的对象创建完成。</p><h4 id="1-2-2-对象的内存布局"><a href="#1-2-2-对象的内存布局" class="headerlink" title="1.2.2 对象的内存布局"></a>1.2.2 对象的内存布局</h4><blockquote><p>在 HotSpot 虚拟机中，分为 3 块区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)</p></blockquote><p>对象头(Header)：包含两部分，第一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，32 位虚拟机占 32 bit，64 位虚拟机占 64 bit。官方称为 ‘Mark Word’。第二部分是类型指针，即对象指向它的类的元数据指针，虚拟机通过这个指针确定这个对象是哪个类的实例。另外，如果是 Java 数组，对象头中还必须有一块用于记录数组长度的数据，因为普通对象可以通过 Java 对象元数据确定大小，而数组对象不可以。</p><p>实例数据(Instance Data)：程序代码中所定义的各种类型的字段内容(包含父类继承下来的和子类中定义的)。</p><p>对齐填充(Padding)：不是必然需要，主要是占位，保证对象大小是某个字节的整数倍。</p><h4 id="1-2-3-对象的访问定位"><a href="#1-2-3-对象的访问定位" class="headerlink" title="1.2.3 对象的访问定位"></a>1.2.3 对象的访问定位</h4><blockquote><p>使用对象时，通过栈上的 reference 数据来操作堆上的具体对象。</p></blockquote><p>通过句柄访问</p><blockquote><p>Java 堆中会分配一块内存作为句柄池。reference 存储的是句柄地址。详情见图。</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.jpg" alt="通过句柄访问对象"></p><p>使用直接指针访问</p><blockquote><p>reference 中直接存储对象地址</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/%E9%80%9A%E8%BF%87%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.jpg" alt="通过直接指针访问对象"></p><p>比较：使用句柄的最大好处是 reference 中存储的是稳定的句柄地址，在对象移动(GC)是只改变实例数据指针地址，reference 自身不需要修改。直接指针访问的最大好处是速度快，节省了一次指针定位的时间开销。如果是对象频繁 GC 那么句柄方法好，如果是对象频繁访问则直接指针访问好。</p><h2 id="2-垃圾回收器与内存分配策略"><a href="#2-垃圾回收器与内存分配策略" class="headerlink" title="2. 垃圾回收器与内存分配策略"></a>2. 垃圾回收器与内存分配策略</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><blockquote><p>程序计数器、虚拟机栈、本地方法栈 3 个区域随线程生灭(因为是线程私有)，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。而 Java 堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期才知道那些对象会创建，这部分内存的分配和回收都是动态的，垃圾回收期所关注的就是这部分内存。</p></blockquote><h3 id="2-2-对象已死吗"><a href="#2-2-对象已死吗" class="headerlink" title="2.2 对象已死吗"></a>2.2 对象已死吗</h3><blockquote><p>在进行内存回收之前要做的事情就是判断那些对象是‘死’的，哪些是‘活’的。</p></blockquote><h4 id="2-2-1-引用计数法"><a href="#2-2-1-引用计数法" class="headerlink" title="2.2.1 引用计数法"></a>2.2.1 引用计数法</h4><blockquote><p>给对象添加一个引用计数器。但是难以解决循环引用问题。</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/java%E5%A0%86%E6%A0%88%E5%BC%95%E7%94%A8.jpg" alt="java堆栈引用"></p><p>从图中可以看出，如果不下小心直接把 Obj1-reference 和 Obj2-reference 置 null。则在 Java 堆当中的两块内存依然保持着互相引用无法回收。</p><h4 id="2-2-2-可达性分析法"><a href="#2-2-2-可达性分析法" class="headerlink" title="2.2.2 可达性分析法"></a>2.2.2 可达性分析法</h4><blockquote><p>通过一系列的 ‘GC Roots’ 的对象作为起始点，从这些节点出发所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连的时候说明对象不可用。</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E6%B3%95.jpg" alt="可达性分析"></p><p>可作为 GC Roots 的对象：</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI(即一般说的 Native 方法) 引用的对象</li></ul><h4 id="2-2-3-引用"><a href="#2-2-3-引用" class="headerlink" title="2.2.3 引用"></a>2.2.3 引用</h4><blockquote><p>前面的两种方式判断存活时都与‘引用’有关。但是 JDK 1.2 之后，引用概念进行了扩充</p></blockquote><p>种引用强度一次逐渐减弱</p><p>强引用</p><blockquote><p>类似于 Object obj = new Object(); 创建的，只要强引用在就不回收。</p></blockquote><p>软引用</p><blockquote><p>SoftReference 类实现软引用。在系统要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。</p></blockquote><p>弱引用</p><blockquote><p>WeakReference 类实现弱引用。对象只能生存到下一次垃圾收集之前。在垃圾收集器工作时，无论内存是否足够都会回收掉只被弱引用关联的对象。</p></blockquote><p>虚引用</p><blockquote><p>PhantomReference 类实现虚引用。无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</p></blockquote><h4 id="2-2-4-生存还是死亡"><a href="#2-2-4-生存还是死亡" class="headerlink" title="2.2.4 生存还是死亡"></a>2.2.4 生存还是死亡</h4><p>即使在可达性分析算法中不可达的对象，也并非是“facebook”的，这时候它们暂时出于“缓刑”阶段，一个对象的真正死亡至少要经历两次标记过程：如果对象在进行中可达性分析后发现没有与 GC Roots 相连接的引用链，那他将会被第一次标记并且进行一次筛选，筛选条件是此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p><p>如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象竟会放置在一个叫做 F-Queue 的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。这里所谓的“执行”是指虚拟机会出发这个方法，并不承诺或等待他运行结束。finalize() 方法是对象逃脱死亡命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记，如果对象要在 finalize() 中成功拯救自己 —— 只要重新与引用链上的任何一个对象简历关联即可。</p><p>finalize() 方法只会被系统自动调用一次。</p><h4 id="2-2-5-回收方法区"><a href="#2-2-5-回收方法区" class="headerlink" title="2.2.5 回收方法区"></a>2.2.5 回收方法区</h4><blockquote><p>在堆中，尤其是在新生代中，一次垃圾回收一般可以回收 70% ~ 95% 的空间，而永久代的垃圾收集效率远低于此。<br>永久代垃圾回收主要两部分内容：废弃的常量和无用的类。</p></blockquote><p>判断废弃常量：一般是判断没有该常量的引用。</p><p>判断无用的类：要以下三个条件都满足</p><ul><li>该类所有的实例都已经回收，也就是 Java 堆中不存在该类的任何实例</li><li>加载该类的 ClassLoader 已经被回收</li><li>该类对应的 java.lang.Class 对象没有任何地方呗引用，无法在任何地方通过反射访问该类的方法</li></ul><h3 id="2-3-垃圾回收算法"><a href="#2-3-垃圾回收算法" class="headerlink" title="2.3 垃圾回收算法"></a>2.3 垃圾回收算法</h3><h4 id="2-3-1-标记-——-清除算法"><a href="#2-3-1-标记-——-清除算法" class="headerlink" title="2.3.1 标记 —— 清除算法"></a>2.3.1 标记 —— 清除算法</h4><blockquote><p>直接标记清除就可。</p></blockquote><p>两个不足：</p><ul><li>效率不高</li><li>空间会产生大量碎片</li></ul><h4 id="2-3-2-复制算法"><a href="#2-3-2-复制算法" class="headerlink" title="2.3.2 复制算法"></a>2.3.2 复制算法</h4><blockquote><p>把空间分成两块，每次只对其中一块进行 GC。当这块内存使用完时，就将还存活的对象复制到另一块上面。</p></blockquote><p>解决前一种方法的不足，但是会造成空间利用率低下。因为大多数新生代对象都不会熬过第一次 GC。所以没必要 1 : 1 划分空间。可以分一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另一块 Survivor 上，最后清理 Eden 和 Survivor 空间。大小比例一般是 8 : 1 : 1，每次浪费 10% 的 Survivor 空间。但是这里有一个问题就是如果存活的大于 10% 怎么办？这里采用一种分配担保策略：多出来的对象直接进入老年代。</p><h4 id="2-3-3-标记-整理算法"><a href="#2-3-3-标记-整理算法" class="headerlink" title="2.3.3 标记-整理算法"></a>2.3.3 标记-整理算法</h4><blockquote><p>不同于针对新生代的复制算法，针对老年代的特点，创建该算法。主要是把存活对象移到内存的一端。</p></blockquote><h4 id="2-3-4-分代回收"><a href="#2-3-4-分代回收" class="headerlink" title="2.3.4 分代回收"></a>2.3.4 分代回收</h4><blockquote><p>根据存活对象划分几块内存区，一般是分为新生代和老年代。然后根据各个年代的特点制定相应的回收算法。</p></blockquote><ul><li>新生代</li></ul><blockquote><p>每次垃圾回收都有大量对象死去，只有少量存活，选用复制算法比较合理。</p></blockquote><ul><li>老年代</li></ul><blockquote><p>老年代中对象存活率较高、没有额外的空间分配对它进行担保。所以必须使用 标记 —— 清除 或者 标记 —— 整理 算法回收。</p></blockquote><h3 id="2-4-HotSpot-的算法实现"><a href="#2-4-HotSpot-的算法实现" class="headerlink" title="2.4 HotSpot 的算法实现"></a>2.4 HotSpot 的算法实现</h3><p><a href="http://www.theoak.online/2019/10/15/HotSpot%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">HotSpot的算法实现</a></p><h3 id="2-5-垃圾回收器"><a href="#2-5-垃圾回收器" class="headerlink" title="2.5 垃圾回收器"></a>2.5 垃圾回收器</h3><blockquote><p>收集算法是内存回收的理论，而垃圾回收器是内存回收的实践。</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="HotSpot虚拟机的垃圾收集器"></p><p><strong>说明：</strong> 如果两个收集器之间存在连线说明他们之间可以搭配使用。</p><h4 id="2-5-1-Serial-收集器"><a href="#2-5-1-Serial-收集器" class="headerlink" title="2.5.1 Serial 收集器"></a>2.5.1 Serial 收集器</h4><blockquote><p>这是一个单线程收集器。意味着它只会使用一个 CPU 或一条收集线程去完成收集工作，并且在进行垃圾回收时必须暂停其它所有的工作线程直到收集结束。</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/Serial&SerialOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="Serial&amp;SerialOld收集器运行示意图"></p><h4 id="2-5-2-ParNew-收集器"><a href="#2-5-2-ParNew-收集器" class="headerlink" title="2.5.2 ParNew 收集器"></a>2.5.2 ParNew 收集器</h4><blockquote><p>可以认为是 Serial 收集器的多线程版本。</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/ParNew%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="ParNew收集器运行示意图"></p><p>并行：Parallel</p><blockquote><p>指多条垃圾收集线程并行工作，此时用户线程处于等待状态</p></blockquote><p>并发：Concurrent</p><blockquote><p>指用户线程和垃圾回收线程同时执行(不一定是并行，有可能是交叉执行)，用户进程在运行，而垃圾回收线程在另一个 CPU 上运行。</p></blockquote><h4 id="2-5-3-Parallel-Scavenge-收集器"><a href="#2-5-3-Parallel-Scavenge-收集器" class="headerlink" title="2.5.3 Parallel Scavenge 收集器"></a>2.5.3 Parallel Scavenge 收集器</h4><blockquote><p>这是一个新生代收集器，也是使用复制算法实现，同时也是并行的多线程收集器。</p></blockquote><p>CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程所停顿的时间，而 Parallel Scavenge 收集器的目的是达到一个可控制的吞吐量(Throughput = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间))。</p><p>作为一个吞吐量优先的收集器，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整停顿时间。这就是 GC 的自适应调整策略(GC Ergonomics)。</p><h4 id="2-5-4-Serial-Old-收集器"><a href="#2-5-4-Serial-Old-收集器" class="headerlink" title="2.5.4 Serial Old 收集器"></a>2.5.4 Serial Old 收集器</h4><blockquote><p>收集器的老年代版本，单线程，使用 标记 —— 整理。</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/Serial&SerialOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="SerialOld收集器运行示意图"></p><h4 id="2-5-5-Parallel-Old-收集器"><a href="#2-5-5-Parallel-Old-收集器" class="headerlink" title="2.5.5 Parallel Old 收集器"></a>2.5.5 Parallel Old 收集器</h4><blockquote><p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本。多线程，使用 标记 —— 整理</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/ParallelOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="ParallelOld收集器运行示意图"></p><h4 id="2-5-6-CMS-收集器"><a href="#2-5-6-CMS-收集器" class="headerlink" title="2.5.6 CMS 收集器"></a>2.5.6 CMS 收集器</h4><blockquote><p>CMS (Concurrent Mark Sweep) 收集器是一种以获取最短回收停顿时间为目标的收集器。基于 标记 —— 清除 算法实现。</p></blockquote><p>运作步骤:</p><ul><li>初始标记(CMS initial mark)：标记 GC Roots 能直接关联到的对象</li><li>并发标记(CMS concurrent mark)：进行 GC Roots Tracing</li><li>重新标记(CMS remark)：修正并发标记期间的变动部分</li><li>并发清除(CMS concurrent sweep)</li></ul><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/ConcurrentMarkSweep%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="ConcurrentMarkSweep收集器运行示意图"></p><p>缺点：对 CPU 资源敏感、无法收集浮动垃圾、标记 —— 清除 算法带来的空间碎片</p><h4 id="2-5-7-G1-收集器"><a href="#2-5-7-G1-收集器" class="headerlink" title="2.5.7 G1 收集器"></a>2.5.7 G1 收集器</h4><blockquote><p>面向服务端的垃圾回收器。</p></blockquote><p>优点：并行与并发、分代收集、空间整合、可预测停顿。</p><p>运作步骤:</p><ul><li>初始标记(Initial Marking)</li><li>并发标记(Concurrent Marking)</li><li>最终标记(Final Marking)</li><li>筛选回收(Live Data Counting and Evacuation)</li></ul><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/G1%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="G1收集器运行示意图"></p><h3 id="2-6-内存分配与回收策略"><a href="#2-6-内存分配与回收策略" class="headerlink" title="2.6 内存分配与回收策略"></a>2.6 内存分配与回收策略</h3><h4 id="2-6-1-对象优先在-Eden-分配"><a href="#2-6-1-对象优先在-Eden-分配" class="headerlink" title="2.6.1 对象优先在 Eden 分配"></a>2.6.1 对象优先在 Eden 分配</h4><blockquote><p>对象主要分配在新生代的 Eden 区上，如果启动了本地线程分配缓冲区，将线程优先在 (TLAB) 上分配。少数情况会直接分配在老年代中。</p></blockquote><p>一般来说 Java 堆的内存模型如下图所示：</p><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/java%E5%A0%86%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.jpg" alt="java堆的内存模型"></p><p>新生代 GC (Minor GC)</p><blockquote><p>发生在新生代的垃圾回收动作，频繁，速度快。</p></blockquote><p>老年代 GC (Major GC / Full GC)</p><blockquote><p>发生在老年代的垃圾回收动作，出现了 Major GC 经常会伴随至少一次 Minor GC(非绝对)。Major GC 的速度一般会比 Minor GC 慢十倍以上。</p></blockquote><h4 id="2-6-2-大对象直接进入老年代"><a href="#2-6-2-大对象直接进入老年代" class="headerlink" title="2.6.2 大对象直接进入老年代"></a>2.6.2 大对象直接进入老年代</h4><h4 id="2-6-3-长期存活的对象将进入老年代"><a href="#2-6-3-长期存活的对象将进入老年代" class="headerlink" title="2.6.3 长期存活的对象将进入老年代"></a>2.6.3 长期存活的对象将进入老年代</h4><h4 id="2-6-4-动态对象年龄判定"><a href="#2-6-4-动态对象年龄判定" class="headerlink" title="2.6.4 动态对象年龄判定"></a>2.6.4 动态对象年龄判定</h4><h4 id="2-6-5-空间分配担保"><a href="#2-6-5-空间分配担保" class="headerlink" title="2.6.5 空间分配担保"></a>2.6.5 空间分配担保</h4><h2 id="3-Java-内存模型与线程"><a href="#3-Java-内存模型与线程" class="headerlink" title="3. Java 内存模型与线程"></a>3. Java 内存模型与线程</h2><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/%E5%A4%84%E7%90%86%E5%99%A8%E3%80%81%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E3%80%81%E4%B8%BB%E5%86%85%E5%AD%98%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB.jpg" alt="处理器、高速缓存、主内存间的交互关系"></p><h3 id="3-1-Java-内存模型"><a href="#3-1-Java-内存模型" class="headerlink" title="3.1 Java 内存模型"></a>3.1 Java 内存模型</h3><h4 id="3-1-1-主内存和工作内存之间的交互"><a href="#3-1-1-主内存和工作内存之间的交互" class="headerlink" title="3.1.1 主内存和工作内存之间的交互"></a>3.1.1 主内存和工作内存之间的交互</h4><table><thead><tr><th align="center">操作</th><th align="center">作用对象</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">lock</td><td align="center">主内存</td><td align="center">把一个变量标识为一条线程独占的状态</td></tr><tr><td align="center">unlock</td><td align="center">主内存</td><td align="center">把一个处于锁定状态的变量释放出来，释放后才可被其他线程锁定</td></tr><tr><td align="center">read</td><td align="center">主内存</td><td align="center">把一个变量的值从主内存传输到线程工作内存中，以便 load 操作使用</td></tr><tr><td align="center">load</td><td align="center">工作内存</td><td align="center">把 read 操作从主内存中得到的变量值放入工作内存中</td></tr><tr><td align="center">use</td><td align="center">工作内存</td><td align="center">把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量值的字节码指令时将会执行这个操作</td></tr><tr><td align="center">assign</td><td align="center">工作内存</td><td align="center">把一个从执行引擎接收到的值赋接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</td></tr><tr><td align="center">store</td><td align="center">工作内存</td><td align="center">把工作内存中的一个变量的值传送到主内存中，以便 write 操作</td></tr><tr><td align="center">write</td><td align="center">工作内存</td><td align="center">把 store 操作从工作内存中得到的变量的值放入主内存的变量中</td></tr></tbody></table><h4 id="3-1-2-对于-volatile-型变量的特殊规则"><a href="#3-1-2-对于-volatile-型变量的特殊规则" class="headerlink" title="3.1.2 对于 volatile 型变量的特殊规则"></a>3.1.2 对于 volatile 型变量的特殊规则</h4><blockquote><p>关键字 volatile 是 Java 虚拟机提供的最轻量级的同步机制。</p></blockquote><p>一个变量被定义为 volatile 的特性：</p><p>保证此变量对所有线程的可见性。但是操作并非原子操作，并发情况下不安全。</p><blockquote><p>果不符合 运算结果并不依赖变量当前值，或者能够确保只有单一的线程修改变量的值 和 变量不需要与其他的状态变量共同参与不变约束 就要通过加锁(使用 synchronize 或 java.util.concurrent 中的原子类)来保证原子性。</p></blockquote><p>禁止指令重排序优化。</p><blockquote><p>通过插入内存屏障保证一致性。</p></blockquote><h4 id="3-1-3-对于-long-和-double-型变量的特殊规则"><a href="#3-1-3-对于-long-和-double-型变量的特殊规则" class="headerlink" title="3.1.3 对于 long 和 double 型变量的特殊规则"></a>3.1.3 对于 long 和 double 型变量的特殊规则</h4><blockquote><p>Java 要求对于主内存和工作内存之间的八个操作都是原子性的，但是对于 64 位的数据类型，有一条宽松的规定：允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虚拟机实现选择可以不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性。这就是 long 和 double 的非原子性协定。</p></blockquote><h4 id="3-1-4-原子性、可见性与有序性"><a href="#3-1-4-原子性、可见性与有序性" class="headerlink" title="3.1.4 原子性、可见性与有序性"></a>3.1.4 原子性、可见性与有序性</h4><ul><li>原子性(Atomicity)</li></ul><blockquote><p>由 Java 内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store 和 write。大致可以认为基本数据类型的操作是原子性的。同时 lock 和 unlock 可以保证更大范围操作的原子性。而 synchronize 同步块操作的原子性是用更高层次的字节码指令 monitorenter 和 monitorexit 来隐式操作的。</p></blockquote><ul><li>可见性(Visibility)</li></ul><blockquote><p>是指当一个线程修改了共享变量的值，其他线程也能够立即得知这个通知。主要操作细节就是修改值后将值同步至主内存(volatile 值使用前都会从主内存刷新)，除了 volatile 还有 synchronize 和 final 可以保证可见性。同步块的可见性是由“对一个变量执行 unlock 操作之前，必须先把此变量同步会主内存中( store、write 操作)”这条规则获得。而 final 可见性是指：被 final 修饰的字段在构造器中一旦完成，并且构造器没有把 “this” 的引用传递出去( this 引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象)，那在其他线程中就能看见 final 字段的值。</p></blockquote><ul><li>有序性(Ordering)</li></ul><blockquote><p>如果在被线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。前半句指“线程内表现为串行的语义”，后半句是指“指令重排”现象和“工作内存与主内存同步延迟”现象。Java 语言通过 volatile 和 synchronize 两个关键字来保证线程之间操作的有序性。volatile 自身就禁止指令重排，而 synchronize 则是由“一个变量在同一时刻指允许一条线程对其进行 lock 操作”这条规则获得，这条规则决定了持有同一个锁的两个同步块只能串行的进入。</p></blockquote><h4 id="3-1-5-先行发生原则"><a href="#3-1-5-先行发生原则" class="headerlink" title="3.1.5 先行发生原则"></a>3.1.5 先行发生原则</h4><blockquote><p>也就是 happens-before 原则。这个原则是判断数据是否存在竞争、线程是否安全的主要依据。先行发生是 Java 内存模型中定义的两项操作之间的偏序关系。</p></blockquote><p>天然的先行发生关系</p><table><thead><tr><th align="center">规则</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">程序次序规则</td><td align="center">在一个线程内，代码按照书写的控制流顺序执行</td></tr><tr><td align="center">管程锁定规则</td><td align="center">一个 unlock 操作先行发生于后面对同一个锁的 lock 操作</td></tr><tr><td align="center">volatile 变量规则</td><td align="center">volatile 变量的写操作先行发生于后面对这个变量的读操作</td></tr><tr><td align="center">线程启动规则</td><td align="center">Thread 对象的 start() 方法先行发生于此线程的每一个动作线程终止规则</td></tr><tr><td align="center">线程中断规则</td><td align="center">对线程 interrupt() 方法调用优先发生于被中断线程的代码检测到中断事件的发生(通过 Thread.interrupted() 方法检测)</td></tr><tr><td align="center">对象终结规则</td><td align="center">一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始</td></tr><tr><td align="center">传递性</td><td align="center">如果操作 A 先于 操作 B 发生，操作 B 先于 操作 C 发生，那么操作 A 先于 操作 C</td></tr></tbody></table><h3 id="3-2-Java-与线程"><a href="#3-2-Java-与线程" class="headerlink" title="3.2 Java 与线程"></a>3.2 Java 与线程</h3><h4 id="3-2-1-线程的实现"><a href="#3-2-1-线程的实现" class="headerlink" title="3.2.1 线程的实现"></a>3.2.1 线程的实现</h4><p>使用内核线程实现</p><blockquote><p>直接由操作系统内核支持的线程，这种线程由内核完成切换。程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口 —— 轻量级进程(LWP)，轻量级进程就是我们通常意义上所讲的线程，每个轻量级进程都有一个内核级线程支持。</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0.jpg" alt="内核线程实现"></p><p>使用用户线程实现</p><blockquote><p>广义上来说，只要不是内核线程就可以认为是用户线程，因此可以认为轻量级进程也属于用户线程。狭义上说是完全建立在用户空间的线程库上的并且内核系统不可感知的。</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0.jpg" alt="用户线程实现"></p><p>使用用户线程夹加轻量级进程混合实现</p><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/%E6%B7%B7%E5%90%88%E5%AE%9E%E7%8E%B0.jpg" alt="混合实现"></p><p>Java 线程实现</p><blockquote><p>平台不同实现方式不同，可以认为是一条 Java 线程映射到一条轻量级进程。</p></blockquote><h4 id="3-2-2-Java-线程调度"><a href="#3-2-2-Java-线程调度" class="headerlink" title="3.2.2 Java 线程调度"></a>3.2.2 Java 线程调度</h4><p>协同式线程调度</p><blockquote><p>线程执行时间由线程自身控制，实现简单，切换线程自己可知，所以基本没有线程同步问题。坏处是执行时间不可控，容易阻塞。</p></blockquote><p>抢占式线程调度</p><blockquote><p>每个线程由系统来分配执行时间。</p></blockquote><h4 id="3-2-3-状态转换"><a href="#3-2-3-状态转换" class="headerlink" title="3.2.3 状态转换"></a>3.2.3 状态转换</h4><p>五种状态：</p><ul><li>新建(new)</li></ul><blockquote><p>创建后尚未启动的线程。</p></blockquote><ul><li>运行(Runable)</li></ul><blockquote><p>Runable 包括了操作系统线程状态中的 Running 和 Ready，也就是出于此状态的线程有可能正在执行，也有可能正在等待 CPU 为他分配时间。</p></blockquote><ul><li>无限期等待(Waiting)</li></ul><blockquote><p>出于这种状态的线程不会被 CPU 分配时间，它们要等其他线程显示的唤醒。</p></blockquote><p>以下方法会然线程进入无限期等待状态：<br>没有设置 Timeout 参数的 Object.wait() 方法。<br>没有设置 Timeout 参数的 Thread.join() 方法。<br>LookSupport.park() 方法。</p><ul><li>限期等待(Timed Waiting)</li></ul><blockquote><p>处于这种状态的线程也不会分配时间，不过无需等待配其他线程显示地唤醒，在一定时间后他们会由系统自动唤醒。</p></blockquote><p>以下方法会让线程进入限期等待状态：<br>Thread.sleep() 方法。<br>设置了 Timeout 参数的 Object.wait() 方法。<br>设置了 Timeout 参数的 Thread.join() 方法。<br>LockSupport.parkNanos() 方法。<br>LockSupport.parkUntil() 方法。</p><ul><li>阻塞(Blocked)</li></ul><blockquote><p>线程被阻塞了，“阻塞状态”和“等待状态”的区别是：“阻塞状态”在等待着获取一个排他锁，这个时间将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。</p></blockquote><ul><li>结束(Terminated)</li></ul><blockquote><p>已终止线程的线程状态。</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.jpg" alt="线程状态转换图"></p><h2 id="4-虚拟机类加载机制"><a href="#4-虚拟机类加载机制" class="headerlink" title="4. 虚拟机类加载机制"></a>4. 虚拟机类加载机制</h2><blockquote><p>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、装换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。</p></blockquote><p>在 Java 语言中，类型的加载、连接和初始化过程都是在程序运行期间完成的。</p><h3 id="4-1-类加载时机"><a href="#4-1-类加载时机" class="headerlink" title="4.1 类加载时机"></a>4.1 类加载时机</h3><p>类的生命周期( 7 个阶段)</p><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E6%97%B6%E6%9C%9F.jpg" alt="类的生命时期"></p><p>其中加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的。解析阶段可以在初始化之后再开始(运行时绑定或动态绑定或晚期绑定)。</p><p>以下五种情况必须对类进行初始化(而加载、验证、准备自然需要在此之前完成)：</p><ul><li>遇到 new、getstatic、putstatic 或 invokestatic 这 4 条字节码指令时没初始化触发初始化。使用场景：使用 new 关键字实例化对象、读取一个类的静态字段(被 final 修饰、已在编译期把结果放入常量池的静态字段除外)、调用一个类的静态方法。</li><li>使用 java.lang.reflect 包的方法对类进行反射调用的时候。</li><li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需先触发其父类的初始化。</li><li>当虚拟机启动时，用户需指定一个要加载的主类(包含 main() 方法的那个类)，虚拟机会先初始化这个主类。</li><li>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需先触发其初始化。</li></ul><p>举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SuperClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">1127</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"ConstClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD = <span class="string">"hello world!"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  output : SuperClass init!</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 通过子类引用父类的静态对象不会导致子类的初始化</span></span><br><span class="line"><span class="comment">         * 只有直接定义这个字段的类才会被初始化</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  output :</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 通过数组定义来引用类不会触发此类的初始化</span></span><br><span class="line"><span class="comment">         * 虚拟机在运行时动态创建了一个数组类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(ConstClass.HELLOWORLD);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  output :</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 常量在编译阶段会存入调用类的常量池当中，本质上并没有直接引用到定义类常量的类，</span></span><br><span class="line"><span class="comment">         * 因此不会触发定义常量的类的初始化。</span></span><br><span class="line"><span class="comment">         * “hello world” 在编译期常量传播优化时已经存储到 NotInitialization 常量池中了。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-类的加载过程"><a href="#4-2-类的加载过程" class="headerlink" title="4.2 类的加载过程"></a>4.2 类的加载过程</h3><h4 id="4-2-1-加载"><a href="#4-2-1-加载" class="headerlink" title="4.2.1 加载"></a>4.2.1 加载</h4><ul><li>通过一个类的全限定名来获取定义次类的二进制流(ZIP 包、网络、运算生成、JSP 生成、数据库读取)。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法去这个类的各种数据的访问入口。</li></ul><p>数组类的特殊性：数组类本身不通过类加载器创建，它是由 Java 虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型最终是要靠类加载器去创建的，数组创建过程如下：</p><ul><li>如果数组的组件类型是引用类型，那就递归采用类加载加载。</li><li>如果数组的组件类型不是引用类型，Java 虚拟机会把数组标记为引导类加载器关联。</li><li>数组类的可见性与他的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为 public。</li></ul><p>内存中实例的 java.lang.Class 对象存在方法区中。作为程序访问方法区中这些类型数据的外部接口。<br>加载阶段与连接阶段的部分内容是交叉进行的，但是开始时间保持先后顺序。</p><h4 id="4-2-2-验证"><a href="#4-2-2-验证" class="headerlink" title="4.2.2 验证"></a>4.2.2 验证</h4><blockquote><p>是连接的第一步，确保 Class 文件的字节流中包含的信息符合当前虚拟机要求。</p></blockquote><p>文件格式验证</p><ul><li>是否以魔数 0xCAFEBABE 开头</li><li>主、次版本号是否在当前虚拟机处理范围之内</li><li>常量池的常量是否有不被支持常量的类型（检查常量 tag 标志）</li><li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量</li><li>CONSTANT_Utf8_info 型的常量中是否有不符合 UTF8 编码的数据</li><li>Class 文件中各个部分集文件本身是否有被删除的附加的其他信息</li></ul><p>只有通过这个阶段的验证后，字节流才会进入内存的方法区进行存储，所以后面 3 个验证阶段全部是基于方法区的存储结构进行的，不再直接操作字节流。</p><p>元数据验证</p><ul><li>这个类是否有父类（除 java.lang.Object 之外）</li><li>这个类的父类是否继承了不允许被继承的类（final 修饰的类）</li><li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法</li><li>类中的字段、方法是否与父类产生矛盾（覆盖父类 final 字段、出现不符合规范的重载）</li></ul><p>这一阶段主要是对类的元数据信息进行语义校验，保证不存在不符合 Java 语言规范的元数据信息。</p><p>字节码验证</p><ul><li>保证任意时刻操作数栈的数据类型与指令代码序列都配合工作（不会出现按照 long 类型读一个 int 型数据）</li><li>保证跳转指令不会跳转到方法体以外的字节码指令上</li><li>保证方法体中的类型转换是有效的（子类对象赋值给父类数据类型是安全的，反过来不合法的）</li></ul><p>这是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。这个阶段对类的方法体进行校验分析，保证校验类的方法在运行时不会做出危害虚拟机安全的事件。</p><p>符号引用验证</p><ul><li>符号引用中通过字符创描述的全限定名是否能找到对应的类</li><li>在指定类中是否存在符方法的字段描述符以及简单名称所描述的方法和字段</li><li>符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问</li></ul><p>最后一个阶段的校验发生在迅疾将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，还有以上提及的内容。<br>符号引用的目的是确保解析动作能正常执行，如果无法通过符号引用验证将抛出一个 java.lang.IncompatibleClass.ChangeError 异常的子类。如 java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError 等。</p><h4 id="4-2-3-准备"><a href="#4-2-3-准备" class="headerlink" title="4.2.3 准备"></a>4.2.3 准备</h4><blockquote><p>这个阶段正式为类分配内存并设置类变量初始值，内存在方法去中分配(含 static 修饰的变量不含实例变量)。</p></blockquote><p>public static int value = 1127;<br>这句代码在初始值设置之后为 0，因为这时候尚未开始执行任何 Java 方法。而把 value 赋值为 1127 的 putstatic 指令是程序被编译后，存放于 clinit() 方法中，所以初始化阶段才会对 value 进行赋值。</p><p>基本数据类型的零值</p><table><thead><tr><th align="center">数据类型</th><th align="center">零值</th><th align="center">数据类型</th><th align="center">零值</th></tr></thead><tbody><tr><td align="center">int</td><td align="center">0</td><td align="center">boolean</td><td align="center">false</td></tr><tr><td align="center">long</td><td align="center">0L</td><td align="center">float</td><td align="center">0.0f</td></tr><tr><td align="center">short</td><td align="center">(short) 0</td><td align="center">double</td><td align="center">0.0d</td></tr><tr><td align="center">char</td><td align="center">‘\u0000’</td><td align="center">reference</td><td align="center">null</td></tr><tr><td align="center">byte</td><td align="center">(byte) 0</td><td align="center"></td><td align="center"></td></tr></tbody></table><p><strong>特殊情况：</strong> 如果类字段的字段属性表中存在 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 1127。</p><h4 id="4-2-4-解析"><a href="#4-2-4-解析" class="headerlink" title="4.2.4 解析"></a>4.2.4 解析</h4><blockquote><p>这个阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p></blockquote><p>符号引用<br>符号引用以一组符号来描述所引用的目标，符号可以使任何形式的字面量。<br>直接引用<br>直接引用可以使直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用和迅疾的内存布局实现有关</p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行，分别对应于常量池的 7 种常量类型。</p><h4 id="4-2-5-初始化"><a href="#4-2-5-初始化" class="headerlink" title="4.2.5 初始化"></a>4.2.5 初始化</h4><blockquote><p>前面过程都是以虚拟机主导，而初始化阶段开始执行类中的 Java 代码。</p></blockquote><h3 id="4-3-类加载器"><a href="#4-3-类加载器" class="headerlink" title="4.3 类加载器"></a>4.3 类加载器</h3><blockquote><p>通过一个类的全限定名来获取描述此类的二进制字节流。</p></blockquote><h4 id="4-3-1-双亲委派模型"><a href="#4-3-1-双亲委派模型" class="headerlink" title="4.3.1 双亲委派模型"></a>4.3.1 双亲委派模型</h4><blockquote><p>从 Java 虚拟机角度讲，只存在两种类加载器：一种是启动类加载器（C++ 实现，是虚拟机的一部分）；另一种是其他所有类的加载器（Java 实现，独立于虚拟机外部且全继承自 java.lang.ClassLoader）</p></blockquote><p>启动类加载器<br>加载 lib 下或被 -Xbootclasspath 路径下的类</p><p>扩展类加载器<br>加载 lib/ext 或者被 java.ext.dirs 系统变量所指定的路径下的类</p><p>引用程序类加载器<br>ClassLoader负责，加载用户路径上所指定的类库。</p><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.jpg" alt="类加载过程"></p><p>除顶层启动类加载器之外，其他都有自己的父类加载器。<br>工作过程：如果一个类加载器收到一个类加载的请求，它首先不会自己加载，而是把这个请求委派给父类加载器。只有父类无法完成时子类才会尝试加载。</p><h4 id="4-3-2-破坏双亲委派模型"><a href="#4-3-2-破坏双亲委派模型" class="headerlink" title="4.3.2 破坏双亲委派模型"></a>4.3.2 破坏双亲委派模型</h4><p>keyword：线程上下文加载器(Thread Context ClassLoader)</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的static关键字解析</title>
      <link href="/2019/09/23/Java%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/"/>
      <url>/2019/09/23/Java%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;static关键字是很多朋友在编写代码和阅读代码时碰到的比较难以理解的一个关键字，我打算写这边博客的起因是在牛客上刷到一道题，特别强调static关键词的重要性，使我意识到我在这方面的基础有着很大的方面欠缺，于是打算查阅资料进行补充。<br><img src="/2019/09/23/Java%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/static.png" alt="static"></p><hr><h3 id="一、static关键字的用途"><a href="#一、static关键字的用途" class="headerlink" title="一、static关键字的用途"></a>一、static关键字的用途</h3><a id="more"></a><p>&emsp;查阅资料，有这样一句话说明了static方法的的特殊之处</p><blockquote><p>“static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。”</p></blockquote><p>&emsp;可以看出static关键字的基本作用，简而言之，一句话来描述就是：</p><blockquote><p>方便在没有创建对象的情况下来进行调用（方法/变量）。</p></blockquote><p>&emsp;被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。</p><p>&emsp;static可以用来修饰类的成员方法、类的成员变量，另外可以编写static代码块来优化程序性能。</p><h4 id="（1）static方法"><a href="#（1）static方法" class="headerlink" title="（1）static方法"></a>（1）static方法</h4><p>&emsp;static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。<br>&emsp;虽然在静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法/变量的。举个简单的例子：<br><img src="/2019/09/23/Java%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F.png" alt="静态方法调用非静态成员变量"><br>&emsp;在上面的代码中，由于print2方法是独立于对象存在的，可以直接用过类名调用。假如说可以在静态方法中访问非静态方法/变量的话，那么如果在main方法中有下面一条语句：</p><p>&emsp;MyStr.print2();</p><p>&emsp;此时对象都没有，str2根本就不存在，所以就会产生矛盾了。同样对于方法也是一样，由于你无法预知在print1方法中是否访问了非静态成员变量，所以也禁止在静态成员方法中访问非静态成员方法。</p><p>&emsp;而对于非静态成员方法，它访问静态成员方法/变量显然是毫无限制的。</p><p>&emsp;因此，如果说想在不创建对象的情况下调用某个方法，就可以将这个方法设置为static。我们最常见的static方法就是main方法，至于为什么main方法必须是static的，现在就很清楚了。因为程序在执行main方法的时候没有创建任何对象，因此只有通过类名来访问。</p><h4 id="（2）static变量"><a href="#（2）static变量" class="headerlink" title="（2）static变量"></a>（2）static变量</h4><p>&emsp;static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</p><p>&emsp;static成员变量的初始化顺序按照定义的顺序进行初始化</p><h4 id="（3）static代码块"><a href="#（3）static代码块" class="headerlink" title="（3）static代码块"></a>（3）static代码块</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date birthDate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Date birthDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthDate = birthDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isBornBoomer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date startDate = Date.valueOf(<span class="string">"1997"</span>);</span><br><span class="line">        Date endDate = Date.valueOf(<span class="string">"1999"</span>);</span><br><span class="line">        <span class="keyword">return</span> birthDate.compareTo(startDate)&gt;=<span class="number">0</span> &amp;&amp; birthDate.compareTo(endDate) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isBornBoomer是用来这个人是否是1997-1999年出生的，而每次isBornBoomer被调用的时候，都会生成startDate和birthDate两个对象，造成了空间浪费，如果改成这样效率会更好：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date birthDate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Date startDate,endDate;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        startDate = Date.valueOf(<span class="string">"1997"</span>);</span><br><span class="line">        endDate = Date.valueOf(<span class="string">"1999"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Date birthDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthDate = birthDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isBornBoomer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birthDate.compareTo(startDate)&gt;=<span class="number">0</span> &amp;&amp; birthDate.compareTo(endDate) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</p><hr><h3 id="二、static关键字的误区"><a href="#二、static关键字的误区" class="headerlink" title="二、static关键字的误区"></a>二、static关键字的误区</h3><h4 id="1-static关键字会改变类中成员的访问权限吗"><a href="#1-static关键字会改变类中成员的访问权限吗" class="headerlink" title="1.static关键字会改变类中成员的访问权限吗"></a>1.static关键字会改变类中成员的访问权限吗</h4><p>比较容易java中的static与C/C++中的static关键字的功能混淆。在这里只需要记住一点：与C/C++中的static不同，Java中的static关键字不会影响到变量或者方法的作用域。在Java中能够影响到访问权限的只有private、public、protected（包括包访问权限）这几个关键字。看下面的例子就明白了：<br><img src="/2019/09/23/Java%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/static%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8D%E5%8F%AF%E6%94%B9%E5%8F%98%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90.jpg" alt="static关键字不可改变成员变量访问权限"></p><p>提示’age’ has private access in ‘person’，这说明static关键字并不会改变变量和方法的访问权限。</p><h4 id="2-能通过this访问静态成员变量吗"><a href="#2-能通过this访问静态成员变量吗" class="headerlink" title="2.能通过this访问静态成员变量吗"></a>2.能通过this访问静态成员变量吗</h4><p>虽然对于静态方法来说没有this，那么在非静态方法中能够通过this访问静态成员变量吗？先看下面的一个例子，这段代码输出的结果是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">33</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Main().printValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">3</span>;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">33</span></span><br></pre></td></tr></table></figure><p>这里面主要考察队this和static的理解。this代表什么？this代表当前对象，那么通过new Main()来调用printValue的话，当前对象就是通过new Main()生成的对象。而static变量是被对象所享有的，因此在printValue中的this.value的值毫无疑问是33。在printValue方法内部的value是局部变量，根本不可能与this关联，所以输出结果是33。在这里永远要记住一点：静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够）</p><h4 id="3-static能作用于局部变量么"><a href="#3-static能作用于局部变量么" class="headerlink" title="3.static能作用于局部变量么"></a>3.static能作用于局部变量么</h4><p>　　在C/C++中static是可以作用域局部变量的，但是在Java中切记：static是不允许用来修饰局部变量。不要问为什么，这是Java语法的规定。<br>局部变量最好不要设成静态变量，局变变量是有生命周期的，用完后JAVA很快就回收资源了。如果设成静态变量，那JAVA怎么回收被其占用的内存。</p><hr><h3 id="三、常见的笔试面试题"><a href="#三、常见的笔试面试题" class="headerlink" title="三、常见的笔试面试题"></a>三、常见的笔试面试题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"base static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"base constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">base <span class="keyword">static</span></span><br><span class="line">test <span class="keyword">static</span></span><br><span class="line">base constructor</span><br><span class="line">test constructor</span><br></pre></td></tr></table></figure><p>代码具体的执行过程，在执行开始，先要寻找到main方法，因为main方法是程序的入口，但是在执行main方法之前，必须先加载Test类，而在加载Test类的时候发现Test类继承自Base类，因此会转去先加载Base类，在加载Base类的时候，发现有static块，便执行了static块。在Base类加载完成之后，便继续加载Test类，然后发现Test类中也有static块，便执行static块。在加载完所需的类之后，便开始执行main方法。在main方法中执行new Test()的时候会先调用父类的构造器，然后再调用自身的构造器。因此，便出现了上面的输出结果。</p><hr><p>2.这段代码的输出结果是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">"Test"</span>);</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"person static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"person "</span>+str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">"MyClass"</span>);</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"myclass static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"myclass constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test <span class="keyword">static</span></span><br><span class="line">myclass <span class="keyword">static</span></span><br><span class="line">person <span class="keyword">static</span></span><br><span class="line">person Test</span><br><span class="line">test constructor</span><br><span class="line">person MyClass</span><br><span class="line">myclass constructor</span><br></pre></td></tr></table></figure><p>首先加载Test类，因此会执行Test类中的static块。接着执行new MyClass()，而MyClass类还没有被加载，因此需要加载MyClass类。在加载MyClass类的时候，发现MyClass类继承自Test类，但是由于Test类已经被加载了，所以只需要加载MyClass类，那么就会执行MyClass类的中的static块。在加载完之后，就通过构造器来生成对象。而在生成对象的时候，必须先初始化父类的成员变量，因此会执行Test中的Person person = new Person()，而Person类还没有被加载过，因此会先加载Person类并执行Person类中的static块，接着执行父类的构造器，完成了父类的初始化，然后就来初始化自身了，因此会接着执行MyClass中的Person person = new Person()，最后执行MyClass的构造器。</p><hr><p>3.这段代码的输出结果是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test static 1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test static 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test <span class="keyword">static</span> <span class="number">1</span></span><br><span class="line">test <span class="keyword">static</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>虽然在main方法中没有任何语句，但是还是会输出，原因上面已经讲述过了。另外，static块可以出现类中的任何地方（只要不是方法内部，记住，任何方法内部都不行），并且执行是按照static块的顺序执行的。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> static </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo从零开始搭建个人博客</title>
      <link href="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo+github.jpg" alt="hexo+github"></p><h3 id="1-什么是-Hexo"><a href="#1-什么是-Hexo" class="headerlink" title="1.什么是 Hexo"></a>1.什么是 Hexo</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页<br>具体参考<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">Hexo官方文档</a><br><a href="http://www.theoak.online" target="_blank" rel="noopener">Hexo博客</a></p><a id="more"></a><h3 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2.安装Git"></a>2.安装Git</h3><p>我一直不太喜欢在cmd中操作各种命令，所以挑了这个比较好使的Git, 我的是windows环境，所以下载windows版本并安装就可以了。</p><ul><li><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">下载地址</a></li><li>安装步骤：双击下载好的exe文件，一路next就好啦</li><li>安装好后，打开gitbash，查看版本：<br>命令：git version (写这篇博客的时候最新版本：2.12.2)<br><img src="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/gitVersion.jpg" alt="Git版本"></li></ul><h3 id="3-安装NodeJs"><a href="#3-安装NodeJs" class="headerlink" title="3. 安装NodeJs"></a>3. 安装NodeJs</h3><p>Hexo是基于nodeJS环境的静态博客，里面的npm工具很有用啊，所以还是老老实实把这玩意儿装了吧</p><ul><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">下载地址</a>(说明：LTS为长期支持版，Current为当前最新版)</li><li>安装步骤：反正下载好msi文件后，双击打开安装，也是一路next，不过在Custom Setup这一步记得选 Add to PATH ,这样你就不用自己去配置电脑上环境变量了，装完在按 win + r 快捷键调出运行，然后输入cmd确定，在cmd中输入path可以看到你的node是否配置在里面（环境变量），没有的话你就自由发挥吧。</li><li>查看版本：<br><img src="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/node%E7%89%88%E6%9C%AC.jpg" alt="node版本"></li></ul><h3 id="4-安装hexo"><a href="#4-安装hexo" class="headerlink" title="4. 安装hexo"></a>4. 安装hexo</h3><p>后面的东西都是在gitbash中用npm工具安装就好了。</p><ul><li><p>先创建一个文件夹（用来存放所有blog的东西），然后cd到该文件夹下。</p></li><li><p>安装hexo命令：npm i -g hexo</p></li><li><p>安装完成后，查看版本：<br><img src="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Hexo%E7%89%88%E6%9C%AC.jpg" alt="hexo版本"></p></li><li><p>初始化命令：hexo init ，初始化完成之后打开所在的文件夹可以看到以下文件：<br><img src="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.jpg" alt="目录结构"></p></li><li><p>解释一下：</p><ul><li>node_modules：是依赖包</li><li>public：存放的是生成的页面</li><li>scaffolds：命令生成文章等的模板</li><li>source：用命令创建的各种文章</li><li>themes：主题</li><li>_config.yml：整个博客的配置</li><li>db.json：source解析所得到的</li><li>package.json：项目所需模块项目的配置信息</li></ul></li><li><p>做好这些前置工作之后接下来的就是各种配置了</p></li></ul><h3 id="5-桥接到github"><a href="#5-桥接到github" class="headerlink" title="5.桥接到github"></a>5.桥接到github</h3><ul><li><p>没账号的创建账号，有账号的看下面。</p></li><li><p>创建一个repo，名称为yourname.github.io, 其中yourname是你的github名称，按照这个规则创建才有用哦，如下：<br><img src="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/github%E4%BB%93%E5%BA%93.jpg" alt="github仓库"><br><img src="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95.jpg" alt="创建方法"></p></li><li><p>回到gitbash中，配置github账户信息（YourName和YourEail都替换成你自己的github用户名和注册github使用的邮箱）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;YourName&quot;</span><br><span class="line">git config --global user.email &quot;YourEmail&quot;</span><br></pre></td></tr></table></figure></li><li><p>创建SSH<br>在gitbash中输入：ssh-keygen -t rsa -C “<a href="mailto:youremail@example.com">youremail@example.com</a>，生成ssh。然后按下图的方式找到id_rsa.pub文件的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;. ssh #检查本机已存在的ssh密钥</span><br></pre></td></tr></table></figure><p>如果提示：No such file or directory 说明你是第一次使用git。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure><p>然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：<br><img src="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E9%85%8D%E7%BD%AESSHKey.jpg" alt="配置SSHKey"><br>将刚复制的内容粘贴到key那里，title随便填，保存。</p></li></ul><h3 id="6-做到这里就快接近成功了"><a href="#6-做到这里就快接近成功了" class="headerlink" title="6.做到这里就快接近成功了"></a>6.做到这里就快接近成功了</h3><ul><li><p>用编辑器打开你的blog项目，修改_config.yml文件的一些配置(冒号之后都是有一个半角空格的)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:YourName&#x2F;YourName.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p>回到gitbash中，进入你的blog目录，分别执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server</span><br></pre></td></tr></table></figure></li></ul><p>注：hexo 3.0把服务器独立成个别模块，需要单独安装：npm i hexo-server。</p><p>打开浏览器输入：<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p><p>接着你就可以遇见天使的微笑了</p><h3 id="7-上传到github"><a href="#7-上传到github" class="headerlink" title="7. 上传到github"></a>7. 上传到github</h3><ul><li><p>先安装一波：npm install hexo-deployer-git –save（这样才能将你写好的文章部署到github服务器上并让别人浏览到）</p></li><li><p>执行命令(建议每次都按照如下步骤部署)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean #(或hexo cl)</span><br><span class="line">hexo generate #(或hexo g)</span><br><span class="line">hexo deploy #(或hexo d)部署到GitHub</span><br></pre></td></tr></table></figure><p><strong>注意</strong>deploy的过程中要输入你的username及passward。如下：<br><img src="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E9%83%A8%E7%BD%B2%E5%88%B0github.jpg" alt="部署到github"></p></li><li><p>在浏览器中输入<a href="http://yourgithubname.github.io" target="_blank" rel="noopener">http://yourgithubname.github.io</a>就可以看到你的个人博客啦，是不是很兴奋！</p></li><li><p>感觉gitbash中东西太多的时候输入clear命令清空。</p></li></ul><h3 id="8-绑定个人域名"><a href="#8-绑定个人域名" class="headerlink" title="8. 绑定个人域名"></a>8. 绑定个人域名</h3><ul><li>不想绑定的自行忽略</li><li>第一步购买域名：随便在哪个网站买一个就好了，小花是在* 阿里云购买的visugar.com, DNS也是顺道在那买的。</li><li>第二步添加CNAME：在项目的source文件夹下新建一个名为CNAME的文件，在里面添加你购买的域名，比如我添加的是visugar.com，只能添加一个哦。</li><li>到DNS中添加一条记录(域名解析)：<br><img src="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90.jpg" alt="域名解析"></li><li>其中ip地址为你的github的地址，可在cmd中ping一下就能看到(ping yourname.github.io)</li><li>接着再次部署一下，用你购买的域名打开，就可以看到你的博客啦</li></ul><h3 id="9-修改及配置主题"><a href="#9-修改及配置主题" class="headerlink" title="9. 修改及配置主题"></a>9. 修改及配置主题</h3><ul><li>hexo初始化之后默认的主题是landscape , 然后你可以去<a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo主题</a>里面找到你想要的主题。在github中搜索你要的主题名称，里面都会有该主题的如何使用的介绍，按着来就好了，反正就是改改改！我选的是icarus,看起来挺不错，至少是我喜欢的类型,简洁。<br><img src="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/icarus.jpg" alt="icarus"></li><li>在根目录下./_config.yml里theme：里配置上你需要的主题就可以了</li><li>跟该主题相关的配置在themes/icarus/_config.yml里面,然后根据你的需要在这就行了，可以修改前端的一些信息。</li><li>重新部署一下就OK啦！</li></ul><h3 id="10-常用hexo命令"><a href="#10-常用hexo命令" class="headerlink" title="10.常用hexo命令"></a>10.常用hexo命令</h3><ul><li>总结一些常用的hexo命令相信可以用到后期你还需了解些markdown语法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure><p>缩写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo n &#x3D;&#x3D; hexo new</span><br><span class="line">hexo g &#x3D;&#x3D; hexo generate</span><br><span class="line">hexo s &#x3D;&#x3D; hexo server</span><br><span class="line">hexo d &#x3D;&#x3D; hexo deploy</span><br></pre></td></tr></table></figure><p>组合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo s -g #生成并本地预览</span><br><span class="line">hexo d -g #生成并上传</span><br></pre></td></tr></table></figure><p>同时如需也可以使用&amp;&amp;组合hexo命令使用</p><p>如需了解跟多关注<a href="https://github.com/EricGerry" target="_blank" rel="noopener">github</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> node </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSP简介及其与HTML的区别</title>
      <link href="/2019/08/15/JSP%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%85%B6%E4%B8%8EHTML%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/08/15/JSP%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%85%B6%E4%B8%8EHTML%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-什么是JSP"><a href="#1-什么是JSP" class="headerlink" title="1. 什么是JSP"></a>1. 什么是JSP</h3><blockquote><p>JSP全称Java Server Pages，是一种动态网页开发技术。它使用JSP标签在HTML网页中插入Java代码。标签通常以&lt;%开头以%&gt;结束。</p></blockquote><p>JSP是一种Java servlet，主要用于实现Java web应用程序的用户界面部分。网页开发者们通过结合HTML代码、XHTML代码、XML元素以及嵌入JSP操作和命令来编写JSP。</p><p><img src="/2019/08/15/JSP%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%85%B6%E4%B8%8EHTML%E7%9A%84%E5%8C%BA%E5%88%AB/Jsp.jpg" alt=" "></p><p>JSP通过网页表单获取用户输入数据、访问数据库及其他数据源，然后动态地创建网页。</p><p>JSP标签有多种功能，比如访问数据库、记录用户选择信息、访问JavaBeans组件等，还可以在不同的网页中传递控制信息和共享信息。</p><h3 id="2-什么是HTML"><a href="#2-什么是HTML" class="headerlink" title="2. 什么是HTML"></a>2. 什么是HTML</h3><blockquote><p>HTML（Hyper Text Mark-up Language ）即超文本标记语言，是 WWW 的描述语言。最通俗的说法就是一种超链接，比如收藏一个网页就是保存它的链接。</p></blockquote><p><img src="/2019/08/15/JSP%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%85%B6%E4%B8%8EHTML%E7%9A%84%E5%8C%BA%E5%88%AB/html.jpg" alt=" "></p><p>简单说：</p><ul><li>HTML 是用来描述网页的一种语言。</li><li>HTML 指的是超文本标记语言 (Hyper Text Markup Language)</li><li>HTML 不是一种编程语言，而是一种标记语言 (markup language)</li><li>标记语言是一套标记标签 (markup tag)</li><li>HTML 使用标记标签来描述网页</li></ul><h3 id="3-JSP和HTML的区别"><a href="#3-JSP和HTML的区别" class="headerlink" title="3. JSP和HTML的区别"></a>3. JSP和HTML的区别</h3><ul><li><p>HTML页面是静态页面，也就是事先由用户写好放在服务器上，固定内容，不会变，由web服务器向客户端发送，平时上网看的网页都是大部分都是基于html语言的。</p></li><li><p>JSP页面是有JSP容器执行该页面的Java代码部分然后实时生成动态页面，可动态更新页面上的内容。</p></li></ul><p><img src="/2019/08/15/JSP%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%85%B6%E4%B8%8EHTML%E7%9A%84%E5%8C%BA%E5%88%AB/change.png" alt=" "></p><blockquote><p>动态网页，是指跟静态网页相对的一种网页编程技术。动态页面的内容一般都是依靠服务器端的程序来生成的，不同人、不同时候访问页面，显示的内容都可能不同。网页设计者在写好服务器端的页面程序后，不需要手工控制，页面内容会按照页面程序的安排自动更改变换。<br>静态网页，随着html代码的生成，页面的内容和显示效果就基本上不会发生变化了，不管是谁在任何时候看到的页面内容都是一样的，一成不变，除非你修改页面代码。静态html页面文件，可以直接用本地的浏览器打开。</p></blockquote><p>总而言之：</p><ul><li><p>定义上HTML页面是静态页面可以直接运行，JSP页面是动态页它运行时需要转换成servlet</p></li><li><p>HTML能直接打开，jsp只能发布到Tomact等服务器上才能打开</p></li><li><p>html是w3c规范的一种网页书写格式，是一种统一协议语言，静态网页。我们上网看的网页都是大部分都是基于html语言的。jsp是一种基于动态语言，jsp可以实现html的所有任务。</p></li><li><p>HTML（Hypertext Markup Language）文本标记语言，它是静态页面，和JavaScript一样解释性语言，只要你有一个浏览器那么它就可以正常显示出来，而不需要指定的编译工具，只需在TXT文档中写上HTML标记就可以正常显示。</p></li><li><p>JSP（Java Server Page）是Java服务端的页面，所以它是动态的，它是需要经过JDK编译后把内容发给客户端去显示，我们都知道，Java文件编译后会产生一个class文件，最终执行的就是这个class文件。</p></li></ul><p>html和jsp的表头不一样，这个是JSP的头“ &lt;%@ page language=”java” import=”java.util.*” pageEncoding=”gbk”%&gt;”在表头中有编码格式和倒入包等。也是很好区分的，在jsp中用&lt;%%&gt;就可以写Java代码了，而html没有&lt;%%&gt;。</p><ul><li>简单说，jsp在后台通过服务器解析为相应的html，然后在供浏览器识别显示。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jsp </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SqlOrNoSql，看完这一篇你就懂了</title>
      <link href="/2019/07/26/SqlOrNoSql%EF%BC%8C%E7%9C%8B%E5%AE%8C%E8%BF%99%E4%B8%80%E7%AF%87%E4%BD%A0%E5%B0%B1%E6%87%82%E4%BA%86/"/>
      <url>/2019/07/26/SqlOrNoSql%EF%BC%8C%E7%9C%8B%E5%AE%8C%E8%BF%99%E4%B8%80%E7%AF%87%E4%BD%A0%E5%B0%B1%E6%87%82%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="结构化数据、非结构化数据与半结构化数据"><a href="#结构化数据、非结构化数据与半结构化数据" class="headerlink" title="结构化数据、非结构化数据与半结构化数据"></a>结构化数据、非结构化数据与半结构化数据</h2><blockquote><p>结构化数据，根据定义结构化数据指的是由二维表结构来逻辑表达和实现的数据，严格遵循数据格式与长度规范，也称作为行数据，特点为：数据以行为单位，一行数据表示一个实体的信息，每一行数据的属性是相同的。例如：</p></blockquote><table><thead><tr><th align="center">id</th><th align="center">Name</th><th align="center">age</th><th align="center">phone</th><th align="center">adress</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">张三</td><td align="center">18</td><td align="center">123</td><td align="center">北京</td></tr><tr><td align="center">2</td><td align="center">李四</td><td align="center">19</td><td align="center">234</td><td align="center">杭州</td></tr><tr><td align="center">3</td><td align="center">王五</td><td align="center">20</td><td align="center">345</td><td align="center">上海</td></tr></tbody></table><p>因此关系型数据库完美契合结构化数据的特点，关系型数据库也是关系型数据最主要的存储与管理引擎。</p><p>非结构化数据，指的是<strong>数据结构不规则或不完整，没有任何预定义的数据模型，不方便用二维逻辑表来表现的数据</strong>，例如办公文档（Word）、文本、图片、HTML、各类报表、视频音频等。</p><p>介于结构化与非结构化数据之间的数据就是半结构化数据了，它是结构化数据的一种形式，虽然<strong>不符合二维逻辑这种数据模型结构，但是包含相关标记，用来分割语义元素以及对记录和字段进行分层</strong>。常见的半结构化数据有XML和JSON，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">age</span>&gt;</span>18<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">phone</span>&gt;</span>12345<span class="tag">&lt;/<span class="name">phone</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种结构也被成为自描述的结构。</p><h2 id="以关系型数据库的方式做存储的架构演进"><a href="#以关系型数据库的方式做存储的架构演进" class="headerlink" title="以关系型数据库的方式做存储的架构演进"></a>以关系型数据库的方式做存储的架构演进</h2><p>首先，看一下使用关系型数据库的方式，企业一个系统发展的几个阶段的架构演进（由于本文写的是Sql与NoSql，因此只以存储方式作为切入点，不会涉及类似MQ、ZK这些中间件内容）：</p><p><img src="/2019/07/26/SqlOrNoSql%EF%BC%8C%E7%9C%8B%E5%AE%8C%E8%BF%99%E4%B8%80%E7%AF%87%E4%BD%A0%E5%B0%B1%E6%87%82%E4%BA%86/sql%E5%B8%B8%E7%94%A8%E6%9E%B6%E6%9E%84.png" alt=" "></p><p>阶段一：企业刚发展的阶段，最简单，一个应用服务器配一个关系型数据库，每次读写数据库。</p><p>阶段二：无论是使用MySQL还是Oracle还是别的关系型数据库，数据库通常不会先成为性能瓶颈，通常随着企业规模的扩大，一台应用服务器扛不住上游过来的流量且一台应用服务器会产生单点故障的问题，因此加应用服务器并且在流量入口使用Nginx做一层负载均衡，保证把流量均匀打到应用服务器上。</p><p>阶段三：随着企业规模的继续扩大，此时由于读写都在同一个数据库上，数据库性能出现一定的瓶颈，此时简单地做一层读写分离，每次写主库，读备库，主备库之间通过binlog同步数据，就能很大程度上解决这个阶段的数据库性能问题</p><p>阶段四：企业发展越来越好了，业务越来越大了，做了读写分离数据库压力还是越来越大，这时候怎么办呢，一台数据库扛不住，那我们就分几台吧，做分库分表，对表做垂直拆分，对库做水平拆分。以扩数据库为例，扩出两台数据库，以一定的单号（例如交易单号），以一定的规则（例如取模），交易单号对2取模为0的丢到数据库1去，交易单号对2取模为1的丢到数据库2去，通过这样的方式将写数据库的流量均分到两台数据库上。一般分库分表会使用Shard的方式，通过一个中间件，便于连接管理、数据监控且客户端无需感知数据库ip</p><h2 id="关系型数据库的优点"><a href="#关系型数据库的优点" class="headerlink" title="关系型数据库的优点"></a>关系型数据库的优点</h2><p>上面的方式，看似可以解决问题（实际上确实也能解决很多问题），正常对关系型数据库做一下读写分离 + 分库分表，支撑个1W+的读写QPS还是问题不大的。但是受限于关系型数据库本身，这套架构方案依然有着明显的不足，下面对利用关系型数据库方式做存储的方案的优点先进行一下分析，后一部分再分析一下缺点，对某个技术的优缺点的充分理解是技术选型的前提。</p><h3 id="易理解"><a href="#易理解" class="headerlink" title="易理解"></a>易理解</h3><p>　　因为行 + 列的二维表逻辑是非常贴近逻辑世界的一个概念，关系模型相对网状、层次等其他模型更加容易被理解</p><h3 id="操作方便"><a href="#操作方便" class="headerlink" title="操作方便"></a>操作方便</h3><p>　　通用的SQL语言使得操作关系型数据库非常方便，支持join等复杂查询，Sql + 二维关系是关系型数据库最无可比拟的优点，这种易用性非常贴近开发者</p><h3 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h3><p>　　支持ACID特性，可以维护数据之间的一致性，这是使用数据库非常重要的一个理由之一，例如同银行转账，张三转给李四100元钱，张三扣100元，李四加100元，而且必须同时成功或者同时失败，否则就会造成用户的资损</p><h3 id="数据稳定"><a href="#数据稳定" class="headerlink" title="数据稳定"></a>数据稳定</h3><p>　　数据持久化到磁盘，没有丢失数据风险，支持海量数据存储</p><h3 id="服务稳定"><a href="#服务稳定" class="headerlink" title="服务稳定"></a>服务稳定</h3><p>　　最常用的关系型数据库产品MySql、Oracle服务器性能卓越，服务稳定，通常很少出现宕机异常</p><h2 id="关系型数据库的缺点"><a href="#关系型数据库的缺点" class="headerlink" title="关系型数据库的缺点"></a>关系型数据库的缺点</h2><h3 id="高并发下IO压力大"><a href="#高并发下IO压力大" class="headerlink" title="高并发下IO压力大"></a>高并发下IO压力大</h3><p>　　数据按行存储，即使只针对其中某一列进行运算，也会将整行数据从存储设备中读入内存，导致IO较高</p><h3 id="为维护索引付出的代价大"><a href="#为维护索引付出的代价大" class="headerlink" title="为维护索引付出的代价大"></a>为维护索引付出的代价大</h3><p>　　为了提供丰富的查询能力，通常热点表都会有多个二级索引，一旦有了二级索引，数据的新增必然伴随着所有二级索引的新增，数据的更新也必然伴随着所有二级索引的更新，这不可避免地降低了关系型数据库的读写能力，且索引越多读写能力越差。有机会的话可以看一下自己公司的数据库，除了数据文件不可避免地占空间外，索引占的空间其实也并不少</p><h3 id="为维护数据一致性付出的代价大"><a href="#为维护数据一致性付出的代价大" class="headerlink" title="为维护数据一致性付出的代价大"></a>为维护数据一致性付出的代价大</h3><p>　　数据一致性是关系型数据库的核心，但是同样为了维护数据一致性的代价也是非常大的。我们都知道SQL标准为事务定义了不同的隔离级别，从低到高依次是读未提交、读已提交、可重复度、串行化，事务隔离级别越低，可能出现的并发异常越多，但是通常而言能提供的并发能力越强。那么为了保证事务一致性，数据库就需要提供并发控制与故障恢复两种技术，前者用于减少并发异常，后者可以在系统异常的时候保证事务与数据库状态不会被破坏。对于并发控制，其核心思想就是加锁，无论是乐观锁还是悲观锁，只要提供的隔离级别越高，那么读写性能必然越差</p><h3 id="水平扩展后带来的种种问题难处理"><a href="#水平扩展后带来的种种问题难处理" class="headerlink" title="水平扩展后带来的种种问题难处理"></a>水平扩展后带来的种种问题难处理</h3><p>　　前文提过，随着企业规模扩大，一种方式是对数据库做分库，做了分库之后，数据迁移（1个库的数据按照一定规则打到2个库中）、跨库join（订单数据里有用户数据，两条数据不在同一个库中）、分布式事务处理都是需要考虑的问题，尤其是分布式事务处理，业界当前都没有特别好的解决方案</p><h3 id="表结构扩展不方便"><a href="#表结构扩展不方便" class="headerlink" title="表结构扩展不方便"></a>表结构扩展不方便</h3><p>　　由于数据库存储的是结构化数据，因此表结构schema是固定的，扩展不方便，如果需要修改表结构，需要执行DDL（data definition language）语句修改，修改期间会导致锁表，部分服务不可用</p><h3 id="全文搜索功能弱"><a href="#全文搜索功能弱" class="headerlink" title="全文搜索功能弱"></a>全文搜索功能弱</h3><p>　　例如like “%中国真伟大%”，只能搜索到”2019年中国真伟大，爱祖国”，无法搜索到”中国真是太伟大了”这样的文本，即不具备分词能力，且like查询在”%中国真伟大”这样的搜索条件下，无法命中索引，将会导致查询效率大大降低</p><p>写了这么多，我的理解核心还是前三点，它反映出的一个问题是关系型数据库在高并发下的能力是有瓶颈的，尤其是写入/更新频繁的情况下，出现瓶颈的结果就是数据库CPU高、Sql执行慢、客户端报数据库连接池不够等错误，因此例如万人秒杀这种场景，我们绝对不可能通过数据库直接去扣减库存。</p><p>可能有人会说，数据库在高并发下的能力有瓶颈，如果公司有钱，加CPU、换固态硬盘、继续买服务器加数据库做分库不就好了，问题是这是一种性价比非常低的方式，花1000万达到的效果，换其他方式可能100万就达到了，不考虑人员、服务器投入产出比的Leader就是个不合格的Leader，且关系型数据库的方式，受限于它本身的特点，可能花了钱都未必能达到想要的效果。至于什么是花100万就能达到花1000万效果的方式呢？可以继续往下看，这就是我们要说的NoSql。</p><h2 id="结合NoSql的方式做存储的架构演进"><a href="#结合NoSql的方式做存储的架构演进" class="headerlink" title="结合NoSql的方式做存储的架构演进"></a>结合NoSql的方式做存储的架构演进</h2><p>数据库作为一种关系型数据的存储引擎，存储的是关系型数据，它有优点，同时也有明显的缺点，因此通常在企业规模不断扩大的情况下，不会一味指望通过增强数据库的能力来解决数据存储问题，而是会引入其他存储，也就是我们说的NoSql。</p><p>NoSql的全称为Not Only SQL，泛指非关系型数据库，是对关系型数据库的一种补充，特别注意补充这两个字，这意味着NoSql与关系型数据库并不是对立关系，二者各有优劣，取长补短，在合适的场景下选择合适的存储引擎才是正确的做法。</p><p>比较简单的NoSql就是缓存：</p><p><img src="/2019/07/26/SqlOrNoSql%EF%BC%8C%E7%9C%8B%E5%AE%8C%E8%BF%99%E4%B8%80%E7%AF%87%E4%BD%A0%E5%B0%B1%E6%87%82%E4%BA%86/%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98.png" alt=" "></p><p>针对那些读远多于写的数据，引入一层缓存，每次读从缓存中读取，缓存中读取不到，再去数据库中取，取完之后再写入到缓存，对数据做好失效机制通常就没有大问题了。通常来说，缓存是性能优化的第一选择也是见效最明显的方案。</p><p>但是，缓存通常都是KV型存储且容量有限（基于内存），无法解决所有问题，于是再进一步的优化，继续引入其他NoSql：</p><p><img src="/2019/07/26/SqlOrNoSql%EF%BC%8C%E7%9C%8B%E5%AE%8C%E8%BF%99%E4%B8%80%E7%AF%87%E4%BD%A0%E5%B0%B1%E6%87%82%E4%BA%86/%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98.png" alt=" "></p><p>数据库、缓存与其他NoSql并行工作，充分发挥每种NoSql的特点。当然NoSql在性能方面大大优于关系挺数据库的同时，往往也伴随着一些特性的缺失，比较常见的就是事务功能的缺失。</p><p>下面看一下常用的NoSql及他们的代表产品，并对每种NoSql的优缺点和适用场景做一下分析，便于熟悉每种NoSql的特点，方便技术选型。</p><h2 id="KV型NoSql（代表—-Redis）"><a href="#KV型NoSql（代表—-Redis）" class="headerlink" title="KV型NoSql（代表—-Redis）"></a>KV型NoSql（代表—-Redis）</h2><p>KV型NoSql顾名思义就是以键值对形式存储的非关系型数据库，是最简单、最容易理解也是大家最熟悉的一种NoSql，因此比较快地带过。Redis、MemCache是其中的代表，Redis又是KV型NoSql中应用最广泛的NoSql，KV型数据库以Redis为例，最大的优点我总结下来就两点：</p><ul><li><p>数据基于内存，读写效率高</p></li><li><p>KV型数据，时间复杂度为O(1)，查询速度快<br>因此，KV型NoSql最大的优点就是高性能，利用Redis自带的BenchMark做基准测试，TPS可达到10万的级别，性能非常强劲。同样的Redis也有所有KV型NoSql都有的比较明显的缺点：</p></li><li><p>只能根据K查V，无法根据V查K</p></li><li><p>查询方式单一，只有KV的方式，不支持条件查询，多条件查询唯一的做法就是数据冗余，但这会极大的浪费存储空间</p></li><li><p>内存是有限的，无法支持海量数据存储</p></li><li><p>同样的，由于KV型NoSql的存储是基于内存的，会有丢失数据的风险</p></li></ul><p>综上所述，KV型NoSql最合适的场景就是缓存的场景：</p><ul><li>读远多于写</li><li>读取能力强</li><li>没有持久化的需求，可以容忍数据丢失，反正丢了再查询一把写入就是了</li></ul><p>例如根据用户id查询用户信息，每次根据用户id去缓存中查询一把，查到数据直接返回，查不到去关系型数据库里面根据id查询一把数据写到缓存中去。</p><h2 id="搜索型NoSql（代表—-ElasticSearch）"><a href="#搜索型NoSql（代表—-ElasticSearch）" class="headerlink" title="搜索型NoSql（代表—-ElasticSearch）"></a>搜索型NoSql（代表—-ElasticSearch）</h2><p>传统关系型数据库主要通过索引来达到快速查询的目的，但是在全文搜索的场景下，索引是无能为力的，like查询一来无法满足所有模糊匹配需求，二来使用限制太大且使用不当容易造成慢查询，搜索型NoSql的诞生正是为了解决关系型数据库全文搜索能力较弱的问题，ElasticSearch是搜索型NoSql的代表产品。</p><p>全文搜索的原理是倒排索引，我们看一下什么是倒排索引。要说倒排索引我们先看下什么是正排索引，传统的正排索引是文档–&gt;关键字的映射，例如”Tom is my friend”这句话，会将其切分为”Tom”、”is”、”my”、”friend”四个单词，在搜索的时候对文档进行扫描，符合条件的查出来。这种方式原理非常简单，但是由于其检索效率太低，基本没什么实用价值。</p><p>倒排索引则完全相反，它是关键字–&gt;文档的映射，我用张表格展示一下就比较清楚了：</p><table><thead><tr><th align="center"></th><th align="center">Tom is Tom</th><th align="center">Tom is my friend</th><th align="center">Thank you, Betty</th><th align="center">Tom is Betty’s husband</th></tr></thead><tbody><tr><td align="center">Tom</td><td align="center">2</td><td align="center">1</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">is</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">my</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">friend</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">Thank</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">you</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">Betty</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">husband</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td></tr></tbody></table><p> 意思现在这里有四个短句：</p><ul><li>“Tom is Tom”</li><li>“Tom is my friend”</li><li>“Thank you, Betty”</li><li>“Tom is Betty’s husband”</li></ul><p>搜索引擎会根据一定的切分规则将这句话切成N个关键字，并以关键字的维度维护关键字在每个文本中的出现次数。这样下次搜索”Tom”的时候，由于Tom这个词语在”Tom is Tom”、”Tom is my friend”、”Tom is Betty’s husband”三句话中都有出现，因此这三条记录都会被检索出来，且由于”Tom is Tom”这句话中”Tom”出现了2次，因此这条记录对”Tom”这个单词的匹配度最高，最先展示。这就是搜索引擎倒排索引的基本原理，假设某个关键字在某个文档中出现，那么倒排索引中有两部分内容：</p><ul><li>文档ID</li><li>在该文档中出现的位置情况</li></ul><p>可以举一反三，搜索”Betty Tom”这两个词语也是一样，搜索引擎将”Betty Tom”切分为”Tom”、”Betty”两个单词，根据开发者指定的满足率，比如满足率=50%，那么只要记录中出现了两个单词之一的记录都会被检索出来，再按照匹配度进行展示。</p><p>搜索型NoSql以ElasticSearch为例，它的优点为：</p><ul><li>支持分词场景、全文搜索，这是区别于关系型数据库最大特点</li><li>支持条件查询，支持聚合操作，类似关系型数据库的Group By，但是功能更加强大，适合做数据分析</li><li>数据写文件无丢失风险，在集群环境下可以方便横向扩展，可承载PB级别的数据</li><li>高可用，自动发现新的或者失败的节点，重组和重新平衡数据，确保数据是安全和可访问的</li></ul><p>同样，ElasticSearch也有比较明显的缺点：</p><ul><li>性能全靠内存来顶，也是使用的时候最需要注意的点，非常吃硬件资源、吃内存，大数据量下64G + SSD基本是标配，算得上是数据库中的爱马仕了。为什么要专门提一下内存呢，因为内存这个东西是很值钱的，相同的配置多一倍内存，一个月差不多就要多花几百块钱，至于ElasticSearch内存用在什么地方，大概有如下这些：</li></ul><p>1、Indexing Buffer—-ElasticSearch基于Luence，Lucene的倒排索引是先在内存里生成，然后定期以Segment File的方式刷磁盘的，每个Segment File实际就是一个完整的倒排索引<br>2、Segment Memory—-倒排索引前面说过是基于关键字的，Lucene在4.0后会将所有关键字以FST这种数据结构的方式将所有关键字在启动的时候全量加载到内存，加快查询速度，官方建议至少留系统一半内存给Lucene<br>3、各类缓存—-Filter Cache、Field Cache、Indexing Cache等，用于提升查询分析性能，例如Filter Cache用于缓存使用过的Filter的结果集<br>4、Cluter State Buffer—-ElasticSearch被设计为每个Node都可以响应用户请求，因此每个Node的内存中都包含有一份集群状态的拷贝，一个规模很大的集群这个状态信息可能会非常大</p><ul><li>读写之间有延迟，写入的数据差不多1s样子会被读取到，这也正常，写入的时候自动加入这么多索引肯定影响性能</li><li>数据结构灵活性不高，ElasticSearch这个东西，字段一旦建立就没法修改类型了，假如建立的数据表某个字段没有加全文索引，想加上，那么只能把整个表删了再重建</li></ul><p>因此，搜索型NoSql最适用的场景就是有条件搜索尤其是全文搜索的场景，作为关系型数据库的一种替代方案。</p><p>另外，搜索型数据库还有一种特别重要的应用场景。我们可以想，一旦对数据库做了分库分表后，原来可以在单表中做的聚合操作、统计操作是否统统失效？例如我把订单表分16个库，1024张表，那么订单数据就散落在1024张表中，我想要统计昨天浙江省单笔成交金额最高的订单是哪笔如何做？我想要把昨天的所有订单按照时间排序分页展示如何做？这就是搜索型NoSql的另一大作用了，我们可以把分表之后的数据统一打在搜索型NoSql中，利用搜索型NoSql的搜索与聚合能力完成对全量数据的查询。</p><p>至于为什么把它放在KV型NoSql后面作为第二个写呢，因为通常搜索型NoSql也会作为一层前置缓存，来对关系型数据库进行保护。</p><h2 id="列式NoSql（代表—-HBase）"><a href="#列式NoSql（代表—-HBase）" class="headerlink" title="列式NoSql（代表—-HBase）"></a>列式NoSql（代表—-HBase）</h2><p>列式NoSql，大数据时代最具代表性的技术之一了，以HBase为代表。</p><p>列式NoSql是基于列式存储的，那么什么是列式存储呢，列式NoSql和关系型数据库一样都有主键的概念，区别在于关系型数据库是按照行组织的数据：</p><table><thead><tr><th align="center">id</th><th align="center">name</th><th align="center">phone</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">张三</td><td align="center">123</td></tr><tr><td align="center">2</td><td align="center">李四</td><td align="center"></td></tr></tbody></table><p>看到每行有name、phone、address三个字段，这是行式存储的方式，且可以观察id = 2的这条数据，即使phone字段没有，它也是占空间的。</p><p>列式存储完全是另一种方式，它是按每一列进行组织的数据：</p><table><thead><tr><th align="center">id</th><th align="center">name</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">张三</td></tr><tr><td align="center">2</td><td align="center">李四</td></tr></tbody></table><table><thead><tr><th align="center">id</th><th align="center">phone</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">123</td></tr></tbody></table><p>这么做有什么好处呢？大致有以下几点：</p><ul><li>查询时只有指定的列会被读取，不会读取所有列</li><li>存储上节约空间，Null值不会被存储，一列中有时候会有很多重复数据（尤其是枚举数据，性别、状态等），这类数据可压缩，行式数据库压缩率通常在3:1<del>5:1之间，列式数据库的压缩率一般在8:1</del>30:1左右</li><li>列数据被组织到一起，一次磁盘IO可以将一列数据一次性读取到内存中<br>第二点说到了数据压缩，什么意思呢，以比较常见的字典表压缩方式举例：<br><img src="/2019/07/26/SqlOrNoSql%EF%BC%8C%E7%9C%8B%E5%AE%8C%E8%BF%99%E4%B8%80%E7%AF%87%E4%BD%A0%E5%B0%B1%E6%87%82%E4%BA%86/%E9%80%9A%E8%BF%87%E5%AD%97%E5%85%B8%E8%A1%A8%E5%8E%8B%E7%BC%A9%E6%95%B0%E6%8D%AE.jpg" alt="通过字典表压缩数据"></li></ul><p>自己看图理解一下，应该就懂了。</p><p>接着继续讲讲优缺点，列式NoSql，以HBase为代表的，优点为：</p><ul><li><p>海量数据无限存储，PB级别数据随便存，底层基于HDFS（Hadoop文件系统），数据持久化</p></li><li><p>读写性能好，只要没有滥用造成数据热点，读写基本随便玩</p></li><li><p>横向扩展在关系型数据库及非关系型数据库中都是最方便的之一，只需要添加新机器就可以实现数据容量的线性增长，且可用在廉价服务器上，节省成本</p></li><li><p>本身没有单点故障，可用性高</p></li><li><p>可存储结构化或者半结构化的数据</p></li><li><p>列数理论上无限，HBase本身只对列族数量有要求，建议1~3个<br>说了这么多HBase的优点，又到了说HBase缺点的时候了：</p></li><li><p>HBase是Hadoop生态的一部分，因此它本身是一款比较重的产品，依赖很多Hadoop组件，数据规模不大没必要用，运维还是有点复杂的</p></li><li><p>KV式，不支持条件查询，或者说条件查询非常非常弱吧，HBase在Scan扫描一批数据的情况下还是提供了前缀匹配这种API的，条件查询除非定义多个RowKey做数据冗余</p></li><li><p>不支持分页查询，因为统计不了数据总数<br>因此<strong>HBase比较适用于那种KV型的且未来无法预估数据增长量的场景</strong>，另外HBase使用还是需要一定的经验，主要体现在RowKey的设计上。</p></li></ul><h2 id="文档型NoSql（代表—-MongoDB）"><a href="#文档型NoSql（代表—-MongoDB）" class="headerlink" title="文档型NoSql（代表—-MongoDB）"></a>文档型NoSql（代表—-MongoDB）</h2><p>什么是文档型NoSql呢，文档型NoSql指的是将半结构化数据存储为文档的一种NoSql，文档型NoSql通常以JSON或者XML格式存储数据，因此文档型NoSql是没有Schema的，由于没有Schema的特性，我们可以随意地存储与读取数据，因此文档型NoSql的出现是解决关系型数据库表结构扩展不方便的问题的。</p><p>MongoDB是文档型NoSql的代表产品，同时也是所有NoSql产品中的明星产品之一，因此这里以MongoDB为例。按我的理解，作为文档型NoSql，MongoDB是一款完全和关系型数据库对标的产品，就我们从存储上来看：</p><p><img src="/2019/07/26/SqlOrNoSql%EF%BC%8C%E7%9C%8B%E5%AE%8C%E8%BF%99%E4%B8%80%E7%AF%87%E4%BD%A0%E5%B0%B1%E6%87%82%E4%BA%86/MongoDB.png" alt=" "></p><p>关系型数据库是按部就班地每个字段一列存，在MongDB里面就是一个JSON字符串存储。关系型数据可以为name、phone建立索引，MongoDB使用createIndex命令一样可以为列建立索引，建立索引之后可以大大提升查询效率。其他方面而言，就大的基本概念，二者之间基本也是类似的：</p><p><img src="/2019/07/26/SqlOrNoSql%EF%BC%8C%E7%9C%8B%E5%AE%8C%E8%BF%99%E4%B8%80%E7%AF%87%E4%BD%A0%E5%B0%B1%E6%87%82%E4%BA%86/MongoDB.png" alt=" "></p><p>因此，对于MongDB，我们只要理解成一个Free-Schema的关系型数据库就完事了，它的优缺点比较一目了然，优点：</p><ul><li>没有预定义的字段，扩展字段容易</li><li>相较于关系型数据库，读写性能优越，命中二级索引的- 查询不会比关系型数据库慢，对于非索引字段的查询则是全面胜出</li></ul><p>缺点在于：</p><ul><li>不支持事务操作，虽然Mongodb4.0之后宣称支持事务，但是效果待观测</li><li>多表之间的关联查询不支持（虽然有嵌入文档的方式），join查询还是需要多次操作</li><li>空间占用较大，这个是MongDB的设计问题，空间预分配机制 + 删除数据后空间不释放，只有用db.repairDatabase()去修复才能释放</li><li>目前没发现MongoDB有关系型数据库例如MySql的Navicat这种成熟的运维工具<br>总而言之，MongDB的使用场景很大程度上可以对标关系型数据库，但是比较适合处理那些没有join、没有强一致性要求且表Schema会常变化的数据</li></ul><h2 id="总结：数据库与NoSql及各种NoSql间的对比"><a href="#总结：数据库与NoSql及各种NoSql间的对比" class="headerlink" title="总结：数据库与NoSql及各种NoSql间的对比"></a>总结：数据库与NoSql及各种NoSql间的对比</h2><p>最后一部分，做一个总结，本文归根到底是两个话题：</p><ul><li>何时选用关系型数据库，何时选用非关系型数据库</li><li>选用非关系型数据库，使用哪种非关系型数据库<br>首先是第一个话题，关系型数据库与非关系型数据库的选择，在我理解里面无非就是两点考虑：</li></ul><p><img src="/2019/07/26/SqlOrNoSql%EF%BC%8C%E7%9C%8B%E5%AE%8C%E8%BF%99%E4%B8%80%E7%AF%87%E4%BD%A0%E5%B0%B1%E6%87%82%E4%BA%86/%E5%85%B3%E7%B3%BB%E5%9E%8B%E4%B8%8E%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B.png" alt=" "></p><p>第一点，不多解释应该都理解，非关系型数据库都是通过牺牲了ACID特性来获取更高的性能的，假设两张表之间有比较强的一致性需求，那么这类数据是不适合放在非关系型数据库中的。</p><p>第二点，核心数据不走非关系型数据库，例如用户表、订单表，但是这有一个前提，就是这一类核心数据会有多种查询模式，例如用户表有ABCD四个字段，可能根据AB查，可能根据AC查，可能根据D查，假设核心数据，但是就是个KV形式，比如用户的聊天记录，那么HBase一存就完事了。</p><p>非核心数据尤其是日志、流水一类中间数据千万不要写在关系型数据库中，这一类数据通常有两个特点：</p><ul><li>写远高于读</li><li>写入量巨大</li></ul><p><img src="/2019/07/26/SqlOrNoSql%EF%BC%8C%E7%9C%8B%E5%AE%8C%E8%BF%99%E4%B8%80%E7%AF%87%E4%BD%A0%E5%B0%B1%E6%87%82%E4%BA%86/%E6%80%BB%E7%BB%93.png" alt=" "></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sql </tag>
            
            <tag> NoSql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>StackAndQueue</title>
      <link href="/2019/07/10/StackAndQueue/"/>
      <url>/2019/07/10/StackAndQueue/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2019/07/10/StackAndQueue/1.jpg" alt=" "></p><h2 id="实现一个简单的栈"><a href="#实现一个简单的栈" class="headerlink" title="实现一个简单的栈"></a>实现一个简单的栈</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        array[size] = x;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = array[size - <span class="number">1</span>];</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[size - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用链表和数组实现队列"><a href="#用链表和数组实现队列" class="headerlink" title="用链表和数组实现队列"></a>用链表和数组实现队列</h2><h3 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Node Tail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(x);</span><br><span class="line">        <span class="comment">//处理头结点为空的情况，直接插入</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = newNode;</span><br><span class="line">            Tail = newNode;</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//头结点不为空</span></span><br><span class="line">        Tail.next = newNode;</span><br><span class="line">        Tail = Tail.next;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//头结点为空直接返回null</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回头结点的val</span></span><br><span class="line">        Integer ret = head.val;</span><br><span class="line">        head = head.next;</span><br><span class="line">        <span class="comment">//处理队列里只有一个元素的情况</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//修改Tail的指向</span></span><br><span class="line">            Tail = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取队首元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判定队列为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyQueue MyQueue = <span class="keyword">new</span> MyQueue();</span><br><span class="line">        MyQueue.offer(<span class="number">1</span>);</span><br><span class="line">        MyQueue.offer(<span class="number">2</span>);</span><br><span class="line">        MyQueue.offer(<span class="number">3</span>);</span><br><span class="line">        MyQueue.offer(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">while</span> (!MyQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> curFront = MyQueue.peek();</span><br><span class="line">            System.out.print(curFront+<span class="string">"\t"</span>);</span><br><span class="line">            MyQueue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="comment">// [head, tail)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>; <span class="comment">// 队首元素的下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>; <span class="comment">// 队尾元素的下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 入队列, 如果插入成功, 返回 true, 否则返回 false</span></span><br><span class="line">    <span class="comment">//    如果队列满了, 再插入就会失败</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == data.length) &#123;</span><br><span class="line">                       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新元素放到 tail 的位置上</span></span><br><span class="line">        data[tail] = x;</span><br><span class="line">        tail++;</span><br><span class="line">        <span class="keyword">if</span> (tail == data.length) &#123;</span><br><span class="line">            tail = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 出队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Integer ret = data[head];</span><br><span class="line">        head++;</span><br><span class="line">        <span class="keyword">if</span> (head == data.length) &#123;</span><br><span class="line">            head = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 取队首元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[head];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 判定为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 取长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyQueue2 myQueue2 = <span class="keyword">new</span> MyQueue2();</span><br><span class="line">        myQueue2.offer(<span class="number">1</span>);</span><br><span class="line">        myQueue2.offer(<span class="number">2</span>);</span><br><span class="line">        myQueue2.offer(<span class="number">3</span>);</span><br><span class="line">        myQueue2.offer(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">while</span> (!myQueue2.isEmpty()) &#123;</span><br><span class="line">            Integer cur = myQueue2.peek();</span><br><span class="line">            System.out.print(cur+<span class="string">"\t"</span>);</span><br><span class="line">            myQueue2.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="括号匹配问题"><a href="#括号匹配问题" class="headerlink" title="括号匹配问题"></a>括号匹配问题</h2><ul><li>采用遇到左括号入栈</li><li>再从栈顶区出，与右括号匹配</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'['</span> || c == <span class="string">'('</span> || c == <span class="string">'&lt;'</span>) &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> top = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (top == <span class="string">'('</span> &amp;&amp; c == <span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (top == <span class="string">'&#123;'</span> &amp;&amp; c == <span class="string">'&#125;'</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (top == <span class="string">'['</span> &amp;&amp; c == <span class="string">']'</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStackBy2Queue</span> </span>&#123;</span><br><span class="line">    <span class="comment">//A始终用来入栈，B始终用来出栈</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; A = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; B = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        A.offer(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (A.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = A.removeFirst();</span><br><span class="line">            B.addLast(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = A.removeFirst();</span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; tmp = A;</span><br><span class="line">        A = B;</span><br><span class="line">        B = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (A.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = A.removeFirst();</span><br><span class="line">            B.addLast(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终要出栈的元素</span></span><br><span class="line">        <span class="keyword">int</span> ret = A.removeFirst();</span><br><span class="line">               B.addLast(ret);</span><br><span class="line">        <span class="comment">// 交换 AB</span></span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈实现队列"><a href="#栈实现队列" class="headerlink" title="栈实现队列"></a>栈实现队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueBY2Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; A=<span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; B=<span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!B.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=B.pop();</span><br><span class="line">            A.push(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        A.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.isEmpty()&amp;&amp;B.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!A.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=A.pop();</span><br><span class="line">            B.push(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.isEmpty()&amp;&amp;B.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!A.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=A.pop();</span><br><span class="line">            B.push(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> A.isEmpty()&amp;&amp;B.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; A=<span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; B=<span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        A.push(x);</span><br><span class="line">        <span class="keyword">if</span>(B.isEmpty())&#123;</span><br><span class="line">            B.push(x);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min=B.peek();</span><br><span class="line">        <span class="keyword">if</span>(x&lt;min)&#123;</span><br><span class="line">            min=x;</span><br><span class="line">        &#125;</span><br><span class="line">        B.push(min);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        A.pop();</span><br><span class="line">        B.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> B.peek();</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Stack </tag>
            
            <tag> Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见的http错误描述原因</title>
      <link href="/2019/06/14/%E5%B8%B8%E8%A7%81%E7%9A%84http%E9%94%99%E8%AF%AF%E6%8F%8F%E8%BF%B0%E5%8E%9F%E5%9B%A0/"/>
      <url>/2019/06/14/%E5%B8%B8%E8%A7%81%E7%9A%84http%E9%94%99%E8%AF%AF%E6%8F%8F%E8%BF%B0%E5%8E%9F%E5%9B%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1xx（临时响应）"><a href="#1xx（临时响应）" class="headerlink" title="1xx（临时响应）"></a>1xx（临时响应）</h2><blockquote><p>表示临时响应并需要请求者继续执行操作的状态代码</p></blockquote><table><thead><tr><th align="center">状态码</th><th align="center">返回信息</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">100</td><td align="center">（继续）</td><td align="center">请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。</td></tr><tr><td align="center">101</td><td align="center">（切换协议）</td><td align="center">请求者已要求服务器切换协议，服务器已确认并准备切换。</td></tr></tbody></table><h2 id="2xx-（成功）"><a href="#2xx-（成功）" class="headerlink" title="2xx （成功）"></a>2xx （成功）</h2><blockquote><p>表示成功处理了请求的状态代码。</p></blockquote><table><thead><tr><th align="center">状态码</th><th align="center">返回信息</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">200</td><td align="center">（成功）</td><td align="center">服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。</td></tr><tr><td align="center">201</td><td align="center">（已创建）</td><td align="center">请求成功并且服务器创建了新的资源。</td></tr><tr><td align="center">202</td><td align="center">（已接受）</td><td align="center">服务器已接受请求，但尚未处理。</td></tr><tr><td align="center">203</td><td align="center">（非授权信息）</td><td align="center">服务器已成功处理了请求，但返回的信息可能来自另一来源。</td></tr><tr><td align="center">204</td><td align="center">（无内容）</td><td align="center">服务器成功处理了请求，但没有返回任何内容。</td></tr><tr><td align="center">205</td><td align="center">（重置内容）</td><td align="center">服务器成功处理了请求，但没有返回任何内容。</td></tr><tr><td align="center">206</td><td align="center">（部分内容）</td><td align="center">服务器成功处理了部分 GET 请求。</td></tr></tbody></table><h2 id="3xx-（重定向）"><a href="#3xx-（重定向）" class="headerlink" title="3xx （重定向）"></a>3xx （重定向）</h2><blockquote><p>表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</p></blockquote><table><thead><tr><th align="center">状态码</th><th align="center">返回信息</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">300</td><td align="center">（多种选择）</td><td align="center">针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</td></tr><tr><td align="center">301</td><td align="center">（永久移动）</td><td align="center">请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</td></tr><tr><td align="center">302</td><td align="center">（临时移动）</td><td align="center">服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</td></tr><tr><td align="center">303</td><td align="center">（查看其他位置）</td><td align="center">请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</td></tr><tr><td align="center">304</td><td align="center">（未修改）</td><td align="center">自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。</td></tr><tr><td align="center">305</td><td align="center">（使用**）</td><td align="center">请求者只能使用<em>访问请求的网页。如果服务器返回此响应，还表示请求者应使用**</em>。</td></tr><tr><td align="center">307</td><td align="center">（临时重定向）</td><td align="center">服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</td></tr></tbody></table><h2 id="4xx（请求错误）"><a href="#4xx（请求错误）" class="headerlink" title="4xx（请求错误）"></a>4xx（请求错误）</h2><blockquote><p>这些状态代码表示请求可能出错，妨碍了服务器的处理。</p></blockquote><table><thead><tr><th align="center">状态码</th><th align="center">返回信息</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">400</td><td align="center">（错误请求）</td><td align="center">服务器不理解请求的语法。</td></tr><tr><td align="center">401</td><td align="center">（未授权）</td><td align="center">请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</td></tr><tr><td align="center">403</td><td align="center">（禁止）</td><td align="center">服务器拒绝请求。</td></tr><tr><td align="center">404</td><td align="center">（未找到）</td><td align="center">服务器找不到请求的网页。</td></tr><tr><td align="center">405</td><td align="center">（方法禁用）</td><td align="center">禁用请求中指定的方法。</td></tr><tr><td align="center">406</td><td align="center">（不接受）</td><td align="center">无法使用请求的内容特性响应请求的网页。</td></tr><tr><td align="center">407</td><td align="center">（需要*授权）</td><td align="center">此状态代码与 401（未授权）类似，但指定请求者应当授权使用*。</td></tr><tr><td align="center">408</td><td align="center">（请求超时）</td><td align="center">服务器等候请求时发生超时。</td></tr><tr><td align="center">409</td><td align="center">（冲突）</td><td align="center">服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。</td></tr><tr><td align="center">410</td><td align="center">（已删除）</td><td align="center">如果请求的资源已永久删除，服务器就会返回此响应。</td></tr><tr><td align="center">411</td><td align="center">（需要有效长度）</td><td align="center">服务器不接受不含有效内容长度标头字段的请求。</td></tr><tr><td align="center">412</td><td align="center">（未满足前提条件）</td><td align="center">服务器未满足请求者在请求中设置的其中一个前提条件。</td></tr><tr><td align="center">413</td><td align="center">（请求实体过大）</td><td align="center">服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</td></tr><tr><td align="center">414</td><td align="center">（请求的 URI 过长）</td><td align="center">请求的 URI（通常为网址）过长，服务器无法处理。</td></tr><tr><td align="center">415</td><td align="center">（不支持的媒体类型）</td><td align="center">请求的格式不受请求页面的支持。</td></tr><tr><td align="center">416</td><td align="center">（请求范围不符合要求）</td><td align="center">如果页面无法提供请求的范围，则服务器会返回此状态代码。</td></tr><tr><td align="center">417</td><td align="center">（未满足期望值）</td><td align="center">服务器未满足”期望”请求标头字段的要求。</td></tr></tbody></table><h2 id="5xx（服务器错误）"><a href="#5xx（服务器错误）" class="headerlink" title="5xx（服务器错误）"></a>5xx（服务器错误）</h2><blockquote><p>这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</p></blockquote><table><thead><tr><th align="center">状态码</th><th align="center">返回信息</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">500</td><td align="center">（服务器内部错误）</td><td align="center">服务器遇到错误，无法完成请求。</td></tr><tr><td align="center">501</td><td align="center">（尚未实施）</td><td align="center">服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。</td></tr><tr><td align="center">502</td><td align="center">（错误网关）</td><td align="center">服务器作为网关或***，从上游服务器收到无效响应。</td></tr><tr><td align="center">503</td><td align="center">（服务不可用）</td><td align="center">服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。</td></tr><tr><td align="center">504</td><td align="center">（网关超时）</td><td align="center">服务器作为网关或***，但是没有及时从上游服务器收到请求。</td></tr><tr><td align="center">505</td><td align="center">（HTTP 版本不受支持）</td><td align="center">服务器不支持请求中所用的 HTTP 协议版本</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Book_Manager</title>
      <link href="/2019/05/11/Book-Manager/"/>
      <url>/2019/05/11/Book-Manager/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2019/05/11/Book-Manager/BookManager.jpg" alt=" "></p><h2 id="代码实现（基于封装多态）"><a href="#代码实现（基于封装多态）" class="headerlink" title="代码实现（基于封装多态）"></a>代码实现（基于封装多态）</h2><h3 id="Book"><a href="#Book" class="headerlink" title="Book"></a>Book</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Package_BookManager.Book;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isBorrowed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">book</span><span class="params">(String name, String id, String author, <span class="keyword">int</span> price, String type, Boolean isBorrowed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.author = author;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.isBorrowed = isBorrowed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBorrowed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isBorrowed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBorrowed</span><span class="params">(<span class="keyword">boolean</span> borrowed)</span> </span>&#123;</span><br><span class="line">        isBorrowed = borrowed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"book&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", id='"</span> + id + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", author='"</span> + author + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", price="</span> + price +</span><br><span class="line">                <span class="string">", type='"</span> + type + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", isBorrowed="</span> + isBorrowed +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Package_BookManager.Book;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bookList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> book[] books=<span class="keyword">new</span> book[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">bookList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        books[<span class="number">0</span>]=<span class="keyword">new</span> book(<span class="string">"C语言"</span>,<span class="string">"001"</span>,<span class="string">"mou1"</span>,<span class="number">100</span>,<span class="string">"计算机"</span>,<span class="keyword">false</span>);</span><br><span class="line">                books[<span class="number">1</span>]=<span class="keyword">new</span> book(<span class="string">"水浒"</span>,<span class="string">"002"</span>,<span class="string">"施耐庵"</span>,<span class="number">58</span>,<span class="string">"古典名著"</span>,<span class="keyword">true</span>);</span><br><span class="line">        books[<span class="number">2</span>]=<span class="keyword">new</span> book(<span class="string">"西游记"</span>,<span class="string">"003"</span>,<span class="string">"吴承恩"</span>,<span class="number">103</span>,<span class="string">"古典名著"</span>,<span class="keyword">false</span>);</span><br><span class="line">        books[<span class="number">3</span>]=<span class="keyword">new</span> book(<span class="string">"三国"</span>,<span class="string">"004"</span>,<span class="string">"罗贯中"</span>,<span class="number">124</span>,<span class="string">"古典名著"</span>,<span class="keyword">false</span>);</span><br><span class="line">        size=<span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> book <span class="title">getBooks</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> books[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBooks</span><span class="params">(book books,<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.books[index] = books;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Operation"><a href="#Operation" class="headerlink" title="Operation"></a>Operation</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Package_BookManager.Operation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Book.bookList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Ioperation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(bookList bookList)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Package_BookManager.Operation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Book.book;</span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Book.bookList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddOperation</span> <span class="keyword">implements</span> <span class="title">Ioperation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(bookList bookList)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"新增一本书籍"</span>);</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入书名:"</span>);</span><br><span class="line">        String name = scanner.next();</span><br><span class="line">        System.out.println(<span class="string">"请输入序号:"</span>);</span><br><span class="line">        String id = scanner.next();</span><br><span class="line">        System.out.println(<span class="string">"请输入作者: "</span>);</span><br><span class="line">        String author = scanner.next();</span><br><span class="line">        System.out.println(<span class="string">"请输入价格:"</span>);</span><br><span class="line">        <span class="keyword">int</span> price = scanner.nextInt();</span><br><span class="line">        System.out.println(<span class="string">"请输入类别: "</span>);</span><br><span class="line">        String type = scanner.next();</span><br><span class="line">        book book = <span class="keyword">new</span> book(name, id,</span><br><span class="line">                author, price, type, <span class="keyword">false</span>);</span><br><span class="line">        bookList.setBooks(book, bookList.getSize());</span><br><span class="line">        bookList.setSize(bookList.getSize() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Package_BookManager.Operation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Book.book;</span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Book.bookList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BorrowOperation</span> <span class="keyword">implements</span> <span class="title">Ioperation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(bookList bookList)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"借阅书籍"</span>);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入要借阅的书号："</span>);</span><br><span class="line">        String id = sc.next();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bookList.getSize(); i++) &#123;</span><br><span class="line">            book book = bookList.getBooks(i);</span><br><span class="line">            <span class="keyword">if</span> (!book.getId().equals(id)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (book.isBorrowed()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"这本书已经被借走！"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            book.setBorrowed(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Package_BookManager.Operation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Book.book;</span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Book.bookList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelOperation</span> <span class="keyword">implements</span> <span class="title">Ioperation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(bookList bookList)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"删除书籍"</span>);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.print(<span class="string">"请输入要删除的书号："</span>);</span><br><span class="line">        String id = sc.next();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; bookList.getSize(); i++) &#123;</span><br><span class="line">            book book = bookList.getBooks(i);</span><br><span class="line">            <span class="keyword">if</span> (book.getId().equals(id)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; bookList.getSize()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"未找到要删除的书籍"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        book lastbook = bookList.getBooks(bookList.getSize() - <span class="number">1</span>);</span><br><span class="line">        bookList.setBooks(lastbook, i);</span><br><span class="line">        bookList.setSize(bookList.getSize() - <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"删除成功"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Package_BookManager.Operation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Book.bookList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExitOperation</span> <span class="keyword">implements</span> <span class="title">Ioperation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(bookList bookList)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"GoodBye!"</span>);</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Package_BookManager.Operation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Book.book;</span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Book.bookList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindOperation</span> <span class="keyword">implements</span> <span class="title">Ioperation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(bookList bookList)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"查找书籍"</span>);</span><br><span class="line">        System.out.print(<span class="string">"请输入要查找的书名："</span>);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String name = sc.next();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bookList.getSize(); i++) &#123;</span><br><span class="line">            book book = bookList.getBooks(i);</span><br><span class="line">            <span class="keyword">if</span> (book.getName().equals(name)) &#123;</span><br><span class="line">                System.out.println(book);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"未找到该书籍！"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"共计找到"</span> + count + <span class="string">"本"</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Package_BookManager.Operation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Book.bookList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintAllOperation</span> <span class="keyword">implements</span> <span class="title">Ioperation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(bookList bookList)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打印所有书籍信息"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bookList.getSize();i++)&#123;</span><br><span class="line">            System.out.println(bookList.getBooks(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"共计"</span>+bookList.getSize()+<span class="string">"本书"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Package_BookManager.Operation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Book.book;</span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Book.bookList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnOperation</span> <span class="keyword">implements</span> <span class="title">Ioperation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(bookList bookList)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"归还书籍"</span>);</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.print(<span class="string">"请输入要归还书籍的编号："</span>);</span><br><span class="line">        String id=sc.next();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bookList.getSize();i++)&#123;</span><br><span class="line">            book book=bookList.getBooks(i);</span><br><span class="line">            <span class="keyword">if</span>(!book.getId().equals(id))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!book.isBorrowed())&#123;</span><br><span class="line">                System.out.println(<span class="string">"这本书已经被归还"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            book.setBorrowed(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="User"><a href="#User" class="headerlink" title="User"></a>User</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Package_BookManager.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Book.bookList;</span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Operation.Ioperation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> Ioperation[] operations;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">menu</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> choice, bookList bookList)</span> </span>&#123;</span><br><span class="line">        operations[choice].work(bookList);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Package_BookManager.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Operation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Admin</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Admin</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        operations = <span class="keyword">new</span> Ioperation[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ExitOperation(),</span><br><span class="line">                <span class="keyword">new</span> FindOperation(),</span><br><span class="line">                <span class="keyword">new</span> AddOperation(),</span><br><span class="line">                <span class="keyword">new</span> DelOperation(),</span><br><span class="line">                <span class="keyword">new</span> PrintAllOperation(),</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">menu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"============"</span>);</span><br><span class="line">        System.out.println(<span class="string">"hello "</span> + name);</span><br><span class="line">        System.out.println(<span class="string">"1. 查找书籍"</span>);</span><br><span class="line">        System.out.println(<span class="string">"2. 增加书籍"</span>);</span><br><span class="line">        System.out.println(<span class="string">"3. 删除书籍"</span>);</span><br><span class="line">        System.out.println(<span class="string">"4. 打印所有信息"</span>);</span><br><span class="line">        System.out.println(<span class="string">"0. 退出"</span>);</span><br><span class="line">        System.out.println(<span class="string">"============"</span>);</span><br><span class="line">        System.out.println(<span class="string">"请输入您的选择: "</span>);</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> choice = scanner.nextInt();</span><br><span class="line">        <span class="keyword">return</span> choice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Package_BookManager.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Operation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalUser</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">NormalUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line"><span class="comment">// 在这里构造 operation 数组</span></span><br><span class="line">        <span class="comment">// 我们让数组中 operation 对象的顺序和菜单中的序号相匹配</span></span><br><span class="line">        operations = <span class="keyword">new</span> Ioperation[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ExitOperation(),</span><br><span class="line">                <span class="keyword">new</span> FindOperation(),</span><br><span class="line">                <span class="keyword">new</span> BorrowOperation(),</span><br><span class="line">                <span class="keyword">new</span> ReturnOperation()</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">menu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"============"</span>);</span><br><span class="line">        System.out.println(<span class="string">"hello "</span> + name);</span><br><span class="line">        System.out.println(<span class="string">"1. 查找图书"</span>);</span><br><span class="line">        System.out.println(<span class="string">"2. 借阅图书"</span>);</span><br><span class="line">        System.out.println(<span class="string">"3. 归还图书"</span>);</span><br><span class="line">        System.out.println(<span class="string">"0. 退出"</span>);</span><br><span class="line">        System.out.println(<span class="string">"============"</span>);</span><br><span class="line">        System.out.println(<span class="string">"请输入您的选择: "</span>);</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> choice = scanner.nextInt();</span><br><span class="line">        <span class="comment">// close 本质上是在关闭 System.in</span></span><br><span class="line">        <span class="comment">// 由于后面还需要用到 System.in, 此处不能盲目关闭.</span></span><br><span class="line">        <span class="comment">// scanner.close();</span></span><br><span class="line">        <span class="keyword">return</span> choice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Package_BookManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Package_BookManager.Book.bookList;</span><br><span class="line"><span class="keyword">import</span> Package_BookManager.User.Admin;</span><br><span class="line"><span class="keyword">import</span> Package_BookManager.User.NormalUser;</span><br><span class="line"><span class="keyword">import</span> Package_BookManager.User.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        bookList bookList = <span class="keyword">new</span> bookList();</span><br><span class="line">        User User = login();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> choice = User.menu();</span><br><span class="line">            User.doOperation(choice, bookList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入您的姓名:"</span>);</span><br><span class="line">        String name = scanner.next();</span><br><span class="line">        System.out.println(<span class="string">"请输入您的角色:(1 普通用户 2 管理员)"</span>);</span><br><span class="line">        <span class="keyword">int</span> role = scanner.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (role == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NormalUser(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Admin(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Java面向对象三大特性封装、继承、多态</title>
      <link href="/2019/03/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81/"/>
      <url>/2019/03/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-封装"><a href="#1-封装" class="headerlink" title="1.封装"></a>1.封装</h2><h3 id="1-1-封装的定义"><a href="#1-1-封装的定义" class="headerlink" title="1.1 封装的定义"></a>1.1 封装的定义</h3><blockquote><p>首先是抽象，把事物抽象成一个类，其次才是封装，将事物拥有的属性和动作隐藏起来，只保留特定的方法与外界联系,封装主要是因为Java有访问权限的控制。public&gt;protected（继承访问权限）&gt;package = default（包访问权限） &gt; private。封装可以保护类中的信息，只提供想要被外界访问的信息。</p></blockquote><p>Java中的访问权限控制主要分为四个级别，如下表</p><table><thead><tr><th align="center">修饰符</th><th align="center">当前类</th><th align="center">同包</th><th align="center">子类</th><th align="center">其他包</th></tr></thead><tbody><tr><td align="center">private</td><td align="center">√</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr><tr><td align="center">dufalut</td><td align="center">√</td><td align="center">√</td><td align="center">×</td><td align="center">×</td></tr><tr><td align="center">protect</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">public</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr></tbody></table><h3 id="1-2-为什么需要封装"><a href="#1-2-为什么需要封装" class="headerlink" title="1.2 为什么需要封装"></a>1.2 为什么需要封装</h3><blockquote><p>封装符合面向对象设计原则的第一条：单一性原则，一个类把自己该做的事情封装起来，而不是暴露给其他类去处理，当内部的逻辑发生变化时，外部调用不用因此而修改，他们只调用开放的接口，而不用去关心内部的实现</p></blockquote><h3 id="1-3-实现"><a href="#1-3-实现" class="headerlink" title="1.3 实现"></a>1.3 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">( <span class="keyword">int</span> age )</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//封装age的检验逻辑，而不是暴露给每个调用者去处理</span></span><br><span class="line">        <span class="keyword">if</span>( age &gt; <span class="number">120</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception( <span class="string">"Invalid value of age"</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">( String name )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-继承"><a href="#2-继承" class="headerlink" title="2. 继承"></a>2. 继承</h2><h3 id="2-1-Java的类可以分为三类"><a href="#2-1-Java的类可以分为三类" class="headerlink" title="2.1 Java的类可以分为三类"></a>2.1 Java的类可以分为三类</h3><ul><li>类：使用class定义，没有抽象方法</li><li>抽象类：使用abstract class定义，可以有也可以没有抽象方法</li><li>接口：使用interface定义，只能有抽象方法</li></ul><h3 id="2-2-在这三个类型之间存在如下关系"><a href="#2-2-在这三个类型之间存在如下关系" class="headerlink" title="2.2 在这三个类型之间存在如下关系"></a>2.2 在这三个类型之间存在如下关系</h3><ul><li>类可以extends：类、抽象类（必须实现所有抽象方法），但只能extends一个，可以implements多个接口（必须实现所有接口方法）</li><li>抽象类可以extends：类，抽象类（可全部、部分、或者完全不实现父类抽象方法），可以implements多个接口（可全部、部分、或者完全不实现接口方法）</li><li>接口可以extends多个接口</li></ul><h3 id="2-3-继承以后子类可以得到什么"><a href="#2-3-继承以后子类可以得到什么" class="headerlink" title="2.3 继承以后子类可以得到什么"></a>2.3 继承以后子类可以得到什么</h3><ul><li>子类拥有父类非private的属性和方法</li><li>子类可以添加自己的方法和属性，即对父类进行扩展</li><li>子类可以重新定义父类的方法，即多态里面的覆盖，后面会详述</li></ul><h3 id="2-4-关于构造函数"><a href="#2-4-关于构造函数" class="headerlink" title="2.4 关于构造函数"></a>2.4 关于构造函数</h3><ul><li>构造函数不能被继承，子类可以通过super()显示调用父类的构造函数</li><li>创建子类时，编译器会自动调用父类的 无参构造函数</li><li>如果父类没有定义无参构造函数，子类必须在构造函数的第一行代码使用super()显示调用</li></ul><p>类默认拥有无参构造函数，如果定义了其他有参构造函数，则无参函数失效，所以父类没有定义无参构造函数，不是指父类没有写无参构造函数。看下面的例子，父类为Human，子类为Programmer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//定义了有参构造函数，默认无参构造函数失效</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Human</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Programmer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Human</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Programmer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//如不显示调用，编译器会出现如下错误</span></span><br><span class="line">        <span class="comment">//Implicit super constructor Human() is undefined. Must explicitly invoke another constructor</span></span><br><span class="line">        <span class="keyword">super</span>( <span class="string">"x"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-为什么需要继承"><a href="#2-5-为什么需要继承" class="headerlink" title="2.5 为什么需要继承"></a>2.5 为什么需要继承</h3><blockquote><p>代码重用是一点，最重要的还是所谓想上转型，即父类的引用变量可以指向子类对象，这是Java面向对象最重要特性多态的基础</p></blockquote><h2 id="3-多态"><a href="#3-多态" class="headerlink" title="3. 多态"></a>3. 多态</h2><h3 id="3-1-在了解多态之前，首先需要知道方法的唯一性标识即什么是相同-不同的方法"><a href="#3-1-在了解多态之前，首先需要知道方法的唯一性标识即什么是相同-不同的方法" class="headerlink" title="3.1 在了解多态之前，首先需要知道方法的唯一性标识即什么是相同/不同的方法"></a>3.1 在了解多态之前，首先需要知道方法的唯一性标识即什么是相同/不同的方法</h3><ul><li>一个方法可以由：修饰符如public、static+返回值+方法名+参数+throw的异常5部分构成</li><li>其中只有方法名和参数是唯一性标识，意即只要方法名和参数相同那他们就是相同的方法</li><li>所谓参数相同，是指参数的个数，类型，顺序一致，其中任何一项不同都是不同的方法</li></ul><h3 id="3-2-何谓重载"><a href="#3-2-何谓重载" class="headerlink" title="3.2 何谓重载"></a>3.2 何谓重载</h3><ul><li>重载是指一个类里面（包括父类的方法）存在方法名相同，但是参数不一样的方法，参数不一样可以是不同的参数个数、类型或顺序</li><li>如果仅仅是修饰符、返回值、throw的异常 不同，那这是2个相同的方法，编译都通不过，更不要说重载了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重载的例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Programmer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Human</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">( String langType )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">coding</span><span class="params">( String langType, String project )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这不是重载，而是三个相同的方法，编译报错</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Programmer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Human</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">coding</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-何谓覆盖-重写"><a href="#3-3-何谓覆盖-重写" class="headerlink" title="3.3 何谓覆盖/重写"></a>3.3 何谓覆盖/重写</h3><ul><li>覆盖描述存在继承关系时子类的一种行为</li><li>子类中存在和父类相同的方法即为覆盖，何谓相同方法请牢记前面的描述，方法名和参数相同，包括参数个数、类型、顺序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">( String langType )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Programmer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Human</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//此方法为覆盖/重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">( String langType )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此方法为上面方法的重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">( String langType, String project )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-覆盖-重写的规则"><a href="#3-4-覆盖-重写的规则" class="headerlink" title="3.4 覆盖/重写的规则"></a>3.4 覆盖/重写的规则</h3><ul><li>子类不能覆盖父类private的方法，private对子类不可见，如果子类定义了一个和父类private方法相同的方法，实为新增方法</li><li>重写方法的修饰符一定要大于或等于被重写方法的修饰符(public &gt; protected &gt; default &gt; private)</li><li>重写抛出的异常需与父类相同或是父类异常的子类，或者重写方法干脆不写throws</li><li>重写方法的返回值必须与被重写方法一致，否则编译报错</li><li>静态方法不能被重写为非静态方法，否则编译出错</li></ul><h3 id="3-5-理解了上述知识点，就可以定义多态了"><a href="#3-5-理解了上述知识点，就可以定义多态了" class="headerlink" title="3.5 理解了上述知识点，就可以定义多态了"></a>3.5 理解了上述知识点，就可以定义多态了</h3><ul><li>多态可以说是“一个接口，多种实现”或者说是父类的引用变量可以指向子类的实例，被引用对象的类型决定调用谁的方法，但这个方法必须在父类中定义</li><li>多态可以分为两种类型：编译时多态（方法的重载）和运行时多态（继承时方法的重写），编译时多态很好理解，后述内容针对运行时多态</li><li>运行时多态依赖于继承、重写和向上转型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println( <span class="string">"I am Human"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承关系</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Doctor</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Human</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//方法重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println( <span class="string">"I am Doctor"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Human</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println( <span class="string">"I am Programmer"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//向上转型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Human <span class="title">humanFactory</span><span class="params">( String humanType )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( <span class="string">"doctor"</span>.equals( humanType ) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Doctor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( <span class="string">"programmer"</span>.equals( humanType ) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Programmer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Human();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String args[] )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        Human human = test.humanFactory( <span class="string">"doctor"</span> );</span><br><span class="line">        human.showName();<span class="comment">//Output:I am Doctor</span></span><br><span class="line">        human = test.humanFactory( <span class="string">"programmer"</span> );</span><br><span class="line">        human.showName();<span class="comment">//Output:I am Programmer</span></span><br><span class="line">        <span class="comment">//一个接口的方法，表现出不同的形态，意即为多态也</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-向上转型的缺憾"><a href="#3-6-向上转型的缺憾" class="headerlink" title="3.6 向上转型的缺憾"></a>3.6 向上转型的缺憾</h3><blockquote><p>只能调用父类中定义的属性和方法，对于子类中的方法和属性它就望尘莫及了，必须强转成子类类型</p></blockquote><h3 id="3-7-总结概括"><a href="#3-7-总结概括" class="headerlink" title="3.7 总结概括"></a>3.7 总结概括</h3><ul><li>当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法，但是它仍然要根据继承链中方法调用的优先级来确认方法，该优先级为：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Human fun1"</span>);</span><br><span class="line">        fun2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Human fun2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Programmer's fun1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Programmer's fun2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human human = <span class="keyword">new</span> Programmer();</span><br><span class="line">        human.fun1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Output:</span></span><br><span class="line"><span class="comment">     *  Human fun1</span></span><br><span class="line"><span class="comment">     *  Programmer's fun2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Programmer中的fun1(String name) 和Human中的fun1()，只是方法名相同但参数不一样，所以是重载关系</li><li>Programmer中的fun2()和Human中的fun2()是相同的方法，即Programmer重写了Human的fun2()方法</li><li>把Programmer的对象向上转型赋值个Human后，human.fun1()会调用父类中的fun1()方法，子类的fun1(String name)是不同的方法</li><li>在human的fun1()中又调用了fun2()方法，该方法在Programmer中被重写，实际调用的是被引用变量Programmer中的fun2()方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"func in A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"func in B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"func in B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        a.func();</span><br><span class="line">        System.out.println(<span class="string">"test A in Bar"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(C c)</span> </span>&#123;</span><br><span class="line">        c.func();</span><br><span class="line">        System.out.println(<span class="string">"test C in Bar"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Bar bar = <span class="keyword">new</span> Bar();</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        C c = <span class="keyword">new</span> C();</span><br><span class="line">        bar.test(a);</span><br><span class="line">        bar.test(b);</span><br><span class="line">        bar.test(c);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            func in A</span></span><br><span class="line"><span class="comment">            test A in Bar</span></span><br><span class="line"><span class="comment">            func in B</span></span><br><span class="line"><span class="comment">            test A in Bar</span></span><br><span class="line"><span class="comment">            func in B</span></span><br><span class="line"><span class="comment">            test C in Bar</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Pycharm搭建Selenium、Python自动化环境</title>
      <link href="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/"/>
      <url>/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/python.jpg" alt="我用Python"><br><a href="https://pan.baidu.com/s/1tiwcFLKU11WpmJ4flgNjMg" target="_blank" rel="noopener">Pycharm、Python</a>下载<br>提取码：ided</p><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><h3 id="Python安装"><a href="#Python安装" class="headerlink" title="Python安装"></a>Python安装</h3><a id="more"></a><p><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/python%E4%B8%8B%E8%BD%BD%E6%89%80%E5%9C%A8%E7%9B%AE%E5%BD%95.jpg" alt="下载文件所在目录"></p><p>勾选<strong>Add Python to Path</strong>添加环境变量</p><p><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/%E5%AE%89%E8%A3%85.jpg" alt="进行安装"></p><p>点击<strong>install</strong>进行安装</p><p>验证Python和环境变量是否配置成功：</p><p>win+r 输入cmd以管理员方式运行，在dos窗口下输入python出现如下窗口则说明你就成功啦<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/%E6%9F%A5%E7%9C%8BPython.jpg" alt="查看Python"></p><hr><h3 id="安装Pycharm"><a href="#安装Pycharm" class="headerlink" title="安装Pycharm"></a>安装Pycharm</h3><p>点击安装Pycharm<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/Pycharm.jpg" alt="Pycharm"></p><p>安装好后，点击启动后，点击新建项目，配置Project Interpreter下Base interpreter中选择刚刚安装的python文件，此时创建，则pycharm的python环境搭建完成，参考图见下：<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/Pycharm%E9%85%8D%E7%BD%AE.jpg" alt="Pycharm配置"></p><p>以上pycharm中的python环境已搭建完成，我们现在开始配置selenium环境；</p><hr><h3 id="安装Selenium"><a href="#安装Selenium" class="headerlink" title="安装Selenium"></a>安装Selenium</h3><p>点击pycharm的File-Settings-Project:Pycharm-Project Interpreter，点击窗口右侧绿色的“+”按钮，搜索“selenium”，搜索后点击添加，安装OK之后，如图中所示，直接会在窗口中显示<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/Selenium%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85.jpg" alt="Selenium下载安装"></p><p>安装成功之后，就会显示在面板上，如下图：<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/selenium%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.jpg" alt="selenium安装成功"></p><p><strong><em>接下来我们就可以愉快的写我们的自动化测试代码啦！</em></strong></p><p><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/%E5%86%B2%E9%B8%AD.jpg" alt="***冲鸭！***"></p><h2 id="自动化搭建"><a href="#自动化搭建" class="headerlink" title="自动化搭建"></a>自动化搭建</h2><h3 id="确定当前浏览器版本"><a href="#确定当前浏览器版本" class="headerlink" title="确定当前浏览器版本"></a>确定当前浏览器版本</h3><p>确定好Chrome浏览器版本号，浏览器右上角三个点-帮助-关于Google Chrome，就能看到当前版本号，我的是版本是81.0.4044.113（正式版本）（64 位），确定好之后接下来我们要去找到对应的chromedirver驱动；<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/chrome%E7%89%88%E6%9C%AC.jpg" alt="Chrome版本"></p><h2 id="下载对应版本驱动chromedriver"><a href="#下载对应版本驱动chromedriver" class="headerlink" title="下载对应版本驱动chromedriver"></a>下载对应版本驱动chromedriver</h2><p>这里我们依赖淘宝的镜像下载<a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">ChromeDriver</a></p><p>注意下载的版本要一致，我们这里下载的是81.0.4044.69<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/%E4%B8%8B%E8%BD%BD%E7%9A%84chromedriver%E7%89%88%E6%9C%AC.jpg" alt="chromedriver版本"></p><p> 下载chromedriver后，将chromedriver文件放到python目录下<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/chromedriver%E5%AD%98%E6%94%BE%E7%9B%AE%E5%BD%95.jpg" alt="chromedriver存放目录"></p><h2 id="用例编写测试"><a href="#用例编写测试" class="headerlink" title="用例编写测试"></a>用例编写测试</h2><h3 id="启动pycharm，创建一个项目，File-New-Project-Location，更改位置，创建test项目"><a href="#启动pycharm，创建一个项目，File-New-Project-Location，更改位置，创建test项目" class="headerlink" title="启动pycharm，创建一个项目，File-New Project-Location，更改位置，创建test项目"></a>启动pycharm，创建一个项目，File-New Project-Location，更改位置，创建test项目</h3><p><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/testProject.jpg" alt="test"></p><h3 id="在test下创建一个python-package"><a href="#在test下创建一个python-package" class="headerlink" title="在test下创建一个python package"></a>在test下创建一个python package</h3><p>  右击test-New-Python Package，输入包名：testbag;<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/testbag.jpg" alt="testbag"></p><h3 id="包下创建一个Python文件"><a href="#包下创建一个Python文件" class="headerlink" title="包下创建一个Python文件"></a>包下创建一个Python文件</h3><p>  右击testbag-New-Python File，输入名字：testDemo<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/testDemo.jpg" alt="testDemo"></p><h3 id="写代码通过谷歌浏览器访问TheOak"><a href="#写代码通过谷歌浏览器访问TheOak" class="headerlink" title="写代码通过谷歌浏览器访问TheOak"></a>写代码通过谷歌浏览器访问<a href="http://www.theoak.online/" target="_blank" rel="noopener">TheOak</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">"http://www.theoak.online/"</span>)</span><br><span class="line">time.sleep(<span class="number">10</span>)</span><br><span class="line">driver.close()</span><br></pre></td></tr></table></figure><p>右键直接run就可以了，当浏览器能自动打开，就证明一切OK了，就像这样呀<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/TheOak.jpg" alt="TheOak"><br>以上selenium+pycharm 自动化环境搭建完成了</p><p>今天又是美好的一天，加油呀！铁铁<br><img src="/2020/04/18/Pycharm%E6%90%AD%E5%BB%BASelenium%E3%80%81Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/%E5%8A%A0%E6%B2%B9%E9%B8%AD%EF%BC%81.jpg" alt="加油鸭！"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pycharm </tag>
            
            <tag> Selenium </tag>
            
            <tag> Python </tag>
            
            <tag> 测试 </tag>
            
            <tag> chromdriver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lombok可真香！！！</title>
      <link href="/2020/03/19/Lombok%E5%8F%AF%E7%9C%9F%E9%A6%99%EF%BC%81%EF%BC%81%EF%BC%81/"/>
      <url>/2020/03/19/Lombok%E5%8F%AF%E7%9C%9F%E9%A6%99%EF%BC%81%EF%BC%81%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Lombok到底是什么"><a href="#Lombok到底是什么" class="headerlink" title="Lombok到底是什么"></a>Lombok到底是什么</h3><p>先看一下它的官网<br><img src="/2020/03/19/Lombok%E5%8F%AF%E7%9C%9F%E9%A6%99%EF%BC%81%EF%BC%81%EF%BC%81/Lombok%E5%AE%98%E7%BD%91.jpg" alt="Lombok官网"><br><strong>大致意思是</strong>：Lombok项目是一个Java库，它会自动插入您的编辑器和构建工具中，从而为您的Java增光添彩。永远不要再编写另一个getter或equals方法，带有一个注释的类将具有功能全面的生成器，自动执行日志记录变量等等。</p><p>听起来好像是挺不错吼，亲自尝试一下吧！</p><hr><h3 id="项目中引入Lombok"><a href="#项目中引入Lombok" class="headerlink" title="项目中引入Lombok"></a>项目中引入Lombok</h3><a id="more"></a><p>首先在项目的 pom.xml中引入 Lombok依赖：</p><p>如果不知道如何导入的话，可以在<a href="https://mvnrepository.com/" target="_blank" rel="noopener">MvnRepository</a>进行查找一下，是不是就很nice。<br><img src="/2020/03/19/Lombok%E5%8F%AF%E7%9C%9F%E9%A6%99%EF%BC%81%EF%BC%81%EF%BC%81/MvnRepository.jpg" alt="MvnRepository"><br>接下来你就会看到如下界面<br><img src="/2020/03/19/Lombok%E5%8F%AF%E7%9C%9F%E9%A6%99%EF%BC%81%EF%BC%81%EF%BC%81/Choose.jpg" alt="ChooseLombok"><br><strong>选择安装版本</strong><br>一般我们选择使用人数多且不是最新版本的，于是我们选择1.18.8<br><img src="/2020/03/19/Lombok%E5%8F%AF%E7%9C%9F%E9%A6%99%EF%BC%81%EF%BC%81%EF%BC%81/version.jpg" alt="version"><br>于是乎我们复制这段代码到pom.xml中引入 Lombok依赖：<br><img src="/2020/03/19/Lombok%E5%8F%AF%E7%9C%9F%E9%A6%99%EF%BC%81%EF%BC%81%EF%BC%81/%E5%AF%BC%E5%85%A5%E4%BE%9D%E8%B5%96.jpg" alt="导入依赖"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.projectlombok&#x2F;lombok --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.18.8&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>项目中导入<img src="/2020/03/19/Lombok%E5%8F%AF%E7%9C%9F%E9%A6%99%EF%BC%81%EF%BC%81%EF%BC%81/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%AF%BC%E5%85%A5.jpg" alt=" "><br>接下来就是愉快的代码环节了。</p><hr><h3 id="get-set-toString不用写了"><a href="#get-set-toString不用写了" class="headerlink" title="get/set/toString不用写了"></a>get/set/toString不用写了</h3><p>定义一个课程 Course，需要自己手动写上每个字段的 get()和 set()方法以及toString()方法，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Dao;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：Eric</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020/3/19 21:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;    <span class="comment">// 课程ID</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 课程名称</span></span><br><span class="line">    <span class="keyword">private</span> Integer score;  <span class="comment">// 课程成绩</span></span><br><span class="line">    <span class="comment">// 自己手写下面的 get/set/toString 方法！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(Integer score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Course&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", score="</span> + score +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是借助于Lombok，一切都变得优雅起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：Eric</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020/3/19 21:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> Long id;    <span class="comment">// 课程ID</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 课程名称</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> Integer score;  <span class="comment">// 课程成绩</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个注解：@Getter、@Setter和@ToString即可方便搞定。</p><hr><h3 id="new对象变得优雅了"><a href="#new对象变得优雅了" class="headerlink" title="new对象变得优雅了"></a>new对象变得优雅了</h3><p>在没有用Lombok之前，我们假如想new一个对象，我们往往会这么做（以上面的 Course类为例）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Course course = <span class="keyword">new</span> Course(); <span class="comment">//首先new一个对象</span></span><br><span class="line">      <span class="comment">//逐步去填充各个字段</span></span><br><span class="line">  course.setId(<span class="number">124l</span>);</span><br><span class="line">  course.setName(<span class="string">"javaWeb"</span>);</span><br><span class="line">  course.setScore(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>引进Lombok之后，我们只需要在 Course类上用上 @Builder注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> Long id;    <span class="comment">// 课程ID</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 课程名称</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> Integer score;  <span class="comment">// 课程成绩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则 Course类对象的创建即可使用 链式表达 的方式一行代码完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ourse course = Course.builder().id(<span class="number">123l</span>).name(<span class="string">"javaWeb"</span>).score(<span class="number">100</span>).build();</span><br></pre></td></tr></table></figure><p>Builder注解就是一个典型的“建造者模式”的实现案例</p><hr><h3 id="构造函数不用写了"><a href="#构造函数不用写了" class="headerlink" title="构造函数不用写了"></a>构造函数不用写了</h3><p>1、全参构造器不用写了</p><p>当你在你的类上使用了Lombok的注解 AllArgsConstructor时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：Eric</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020/3/19 21:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;    <span class="comment">// 课程ID</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 课程名称</span></span><br><span class="line">    <span class="keyword">private</span> Integer score;  <span class="comment">// 课程成绩</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候你的类在编译后会自动生成一个无参构造函数，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：Eric</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020/3/19 21:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;    <span class="comment">// 课程ID</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 课程名称</span></span><br><span class="line">    <span class="keyword">private</span> Integer score;  <span class="comment">// 课程成绩</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Course</span><span class="params">(Long id, String name, Integer score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、无参数构造器也不用写了</p><p>当你在你的类上使用了Lombok的注解 NoArgsConstructor时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：Eric</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020/3/19 21:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;    <span class="comment">// 课程ID</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 课程名称</span></span><br><span class="line">    <span class="keyword">private</span> Integer score;  <span class="comment">// 课程成绩</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候你的类在编译后会自动生成一个无参构造函数，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：Eric</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020/3/19 21:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;    <span class="comment">// 课程ID</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 课程名称</span></span><br><span class="line">    <span class="keyword">private</span> Integer score;  <span class="comment">// 课程成绩</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lombok自动会帮你生成一个无参构造器！！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Course</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、部分参数构造器也不用写了</p><p>当你在你的类上使用了Lombok的注解 RequiredArgsConstructor时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：Eric</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020/3/19 21:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;    <span class="comment">// 课程ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;    <span class="comment">// 课程名称</span></span><br><span class="line">    <span class="keyword">private</span> Integer score;  <span class="comment">// 课程成绩</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候你的类在编译后会自动生成一个具备部分参数的构造函数，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：Eric</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020/3/19 21:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;    <span class="comment">// 课程ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;    <span class="comment">// 课程名称</span></span><br><span class="line">    <span class="keyword">private</span> Integer score;  <span class="comment">// 课程成绩</span></span><br><span class="line">    <span class="comment">// 因为name字段定义成final，所以Lombok自动会帮你生成一个部分参数的构造器！！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Course</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="null判空不用写了"><a href="#null判空不用写了" class="headerlink" title="null判空不用写了"></a>null判空不用写了</h3><p>Lombok的 @NonNull注解可以自动帮我们避免空指针判断。该注解作用在方法参数上，用于自动生成空值参数检查，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">JudgeNull</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (name == <span class="keyword">null</span>)&#123;</span><br><span class="line">          System.out.println(<span class="string">"参数为空"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(name);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>大批量的判空会不会让你感到烦躁呢？但是有了Lombok之后，事情就变得简单了，一个注解搞定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">JudgeNull</span><span class="params">(@NonNull String name)</span></span>&#123;</span><br><span class="line">       System.out.println(name);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="再也不用收尾了"><a href="#再也不用收尾了" class="headerlink" title="再也不用收尾了"></a>再也不用收尾了</h3><p>比如我们打开一个 txt文本文件亦或是调用Scanner输入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileReader fileReader = <span class="keyword">null</span>;</span><br><span class="line">            fileReader = <span class="keyword">new</span> FileReader(<span class="string">"Lombok.txt"</span>);</span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(fileReader);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(br.readLine());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>注意，这个文件句柄在使用完成之后是一定要手动 close的，否则就有可能资源泄漏。有了Lombok之后，这些统统不用干了，一个 @Cleanup注解即可搞定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cleanup</span> BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">       FileReader fileReader = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           fileReader = <span class="keyword">new</span> FileReader(<span class="string">"Lombok.txt"</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       br = <span class="keyword">new</span> BufferedReader(fileReader);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           System.out.println(br.readLine());</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="异常不用捕捉了"><a href="#异常不用捕捉了" class="headerlink" title="异常不用捕捉了"></a>异常不用捕捉了</h3><p>以上面那个作为例子</p><p>这地方的 FileNotFoundException异常，要么显式地在函数级抛出，要么就像上面一样 try/catch内部消灭。</p><p>如果在编码时，不想处理这种繁杂的异常处理，你可以使用Lombok的 @SneakyThrows注解进行简化，比如上面的代码就可以简化为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OpnTxt</span><span class="params">( String fileName)</span></span>&#123;</span><br><span class="line">    <span class="meta">@Cleanup</span> BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">    FileReader fileReader = <span class="keyword">null</span>;</span><br><span class="line">    fileReader = <span class="keyword">new</span> FileReader(<span class="string">"Lombok.txt"</span>);</span><br><span class="line">    br = <span class="keyword">new</span> BufferedReader(fileReader);</span><br><span class="line">    System.out.println(br.readLine());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样你编码时就无需处理异常了</p><hr><h3 id="还有一些"><a href="#还有一些" class="headerlink" title="还有一些"></a>还有一些</h3><p>上面列举了几个平时项目开发中使用非常频繁的Lombok注解，除此之外，还有诸如像：</p><ul><li>@EqualsAndHashCode：为类自动生成hashCode和equals实现</li><li>@Log：为类自动生成log日志记录</li><li>@Synchronized：为类方法或实例方法自动生成synchronized保护</li></ul><hr><p>从此，代码5分钟，划水2小时不是梦。。。<br><img src="/2020/03/19/Lombok%E5%8F%AF%E7%9C%9F%E9%A6%99%EF%BC%81%EF%BC%81%EF%BC%81/%E5%88%92%E6%B0%B4%E5%96%BD.jpg" alt="只想本分划水"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lombok </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea常用的一些插件</title>
      <link href="/2020/03/15/idea%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/"/>
      <url>/2020/03/15/idea%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2020/03/15/idea%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/idea%E6%8F%92%E4%BB%B6.jpg" alt="idea插件"></p><p>今天给分享一下中常用的几款能提升幸福感IDEA插件</p><hr><h3 id="1-Background-Image-Plus"><a href="#1-Background-Image-Plus" class="headerlink" title="1.Background Image Plus"></a>1.Background Image Plus</h3><a id="more"></a><p>默认IDEA的背景一般都比较单调，要么白乎乎，要么褐乎乎，而Background Image Plus这个插件可以为IDEA设置自定义图片作为背景，而且还可以设置透明度，从此写代码乐趣十足</p><p><strong>背景图设置效果如下：</strong></p><p><img src="/2020/03/15/idea%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/Background.png" alt="Background Image Plus"></p><hr><h3 id="2-CodeGlance"><a href="#2-CodeGlance" class="headerlink" title="2.CodeGlance"></a>2.CodeGlance</h3><p>CodeGlance是一款非常好用的代码地图插件，可以在代码编辑区的右侧生成一个竖向可拖动的代码缩略区，可以快速定位代码的同时，并且提供放大镜功能</p><p><strong>右侧代码缩略图效果:</strong></p><p><img src="/2020/03/15/idea%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/CodeGlance.jpg" alt="codeGlance"></p><hr><h3 id="3-Translation"><a href="#3-Translation" class="headerlink" title="3.Translation"></a>3.Translation</h3><p>代码中经常遇到不认识的英文单词或者句子，很懵怎么办？</p><p>Translation是一款非常好用的翻译插件，可以随时随地翻译单词、甚至一段话，从此不再需要额外打开浏览器搜索翻译网站了！</p><p><img src="/2020/03/15/idea%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/TranslationIn.jpg" alt="TranslationIn"></p><p><strong>翻译逐个单词：</strong></p><p><img src="/2020/03/15/idea%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/%E7%BF%BB%E8%AF%91%E5%8D%95%E8%AF%8D.jpg" alt="翻译单词"></p><p><strong>翻译一段话：</strong></p><p><img src="/2020/03/15/idea%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/%E7%BF%BB%E8%AF%91%E4%B8%80%E6%AE%B5%E8%AF%9D.jpg" alt="翻译一段话"></p><hr><h3 id="4-Rainbow-Brackets"><a href="#4-Rainbow-Brackets" class="headerlink" title="4.Rainbow Brackets"></a>4.Rainbow Brackets</h3><p>在代码非常复杂时，各种俄罗斯套娃式的括号简直让人心碎，Rainbow Brackets则是一款可以对成对括号进行着色的插件，顾名思义“彩虹色的括号”，从此复杂代码一眼即可看穿！</p><p>装完插件，括号都被染上了彩虹的颜色</p><p><img src="/2020/03/15/idea%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/RainbowBrackets.jpg" alt="Rainbow Brackets"></p><hr><h3 id="5-Statistic"><a href="#5-Statistic" class="headerlink" title="5.Statistic"></a>5.Statistic</h3><p>天天闷头写代码！</p><ul><li>你知道你项目到底有多少行代码吗？</li><li>你知道项目代码里有多少是实际代码？</li><li>有多少是空行？</li><li>有多少是注释吗？</li><li>. . .</li></ul><p>Statistic则是一款可以做项目全局代码统计信息的小插件</p><p><img src="/2020/03/15/idea%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/Statistic.jpg" alt="Statistic"></p><hr><h3 id="6-Lombok"><a href="#6-Lombok" class="headerlink" title="6.Lombok"></a>6.Lombok</h3><h4 id="Lombok到底是什么"><a href="#Lombok到底是什么" class="headerlink" title="Lombok到底是什么"></a>Lombok到底是什么</h4><p>先看一下它的官网<br><img src="/2020/03/15/idea%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/lombok%E5%AE%98%E7%BD%91.jpg" alt="lombok官网"><br><strong>大致意思是：</strong> Lombok是一个很牛批的插件（本质是个Java库），项目里一旦引入了Lombok之后，你项目中所有诸如：对象的构造函数、 equals()方法，属性的 get()/set()方法等等，这些没有技术含量的代码统统都不用写了，Lombok帮你搞定一切，全部帮你自动生成。<br>总之很香就是啦，后面会写一篇有关于lombok的博客！</p>]]></content>
      
      
      <categories>
          
          <category> idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo本地图片不显示</title>
      <link href="/2020/03/13/hexo%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA/"/>
      <url>/2020/03/13/hexo%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1、修改文件-config-yml-里的post-asset-folder-这个选项设置为true"><a href="#1、修改文件-config-yml-里的post-asset-folder-这个选项设置为true" class="headerlink" title="1、修改文件_config.yml 里的post_asset_folder:这个选项设置为true"></a>1、修改文件_config.yml 里的post_asset_folder:这个选项设置为true</h3><ul><li>修改之后，再使用hexo n “hexo 本地图片不显示”时，目录的样子是</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hexo本地图片不显示</span><br><span class="line">    ├── 01.jpg</span><br><span class="line">    ├── 02.jpg</span><br><span class="line">    └── 03.jpg</span><br><span class="line">    ...</span><br><span class="line">    hexo本地图片不显示.md</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2、安装hexo-asset-image-可以上传本地图片的插件"><a href="#2、安装hexo-asset-image-可以上传本地图片的插件" class="headerlink" title="2、安装hexo-asset-image,可以上传本地图片的插件"></a>2、安装<a href="https://github.com/EricGerry/hexo-asset-image-0.0.5.git" target="_blank" rel="noopener">hexo-asset-image</a>,可以上传本地图片的插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https:&#x2F;&#x2F;github.com&#x2F;EricGerry&#x2F;hexo-asset-image-0.0.5.git --save</span><br></pre></td></tr></table></figure><p><img src="/2020/03/13/hexo%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA/1.png" alt=" "><br>注意 不要使用npm install hexo-asset-image –save这个命令安装,版本号不对<br><img src="/2020/03/13/hexo%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA/2.jpg" alt=" "></p><ul><li>0.0.5版本<br><img src="/2020/03/13/hexo%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA/3.png" alt=" "></li><li>1.0.0版本<br><img src="/2020/03/13/hexo%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA/4.png" alt=" "></li></ul><h3 id="3、在md使用如下形式引用图片"><a href="#3、在md使用如下形式引用图片" class="headerlink" title="3、在md使用如下形式引用图片"></a>3、在md使用如下形式引用图片</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">01</span>](<span class="link">hexo本地图片不显示/01.jpg</span>)</span><br></pre></td></tr></table></figure><p><strong>注意</strong> 这里要使用”/“</p><h3 id="4、使用以下命令发布博客"><a href="#4、使用以下命令发布博客" class="headerlink" title="4、使用以下命令发布博客"></a>4、使用以下命令发布博客</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p><strong>注意</strong> 重命名md文件之后记得重命名文件夹，当md文件的名称与文件夹名称不同时，映射关系以md文件名称为主。会导致src图片路径找不到</p><p><strong>总结</strong>：</p><ul><li>检查_config.yml 文件的post_asset_folder:选项是否为true</li><li>检查创建文件之后的目录结构</li><li>检查hexo-asset-image插件的版本</li><li>检查路径引用图片的路径使用/</li><li>检查md文件的文件名称和图片存放文件夹名称是否相同</li></ul>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的几种排序你学会了吗？</title>
      <link href="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/"/>
      <url>/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><h3 id="1-1-排序"><a href="#1-1-排序" class="headerlink" title="1.1 排序"></a>1.1 排序</h3><p>&emsp;排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。<br>平时的上下文中，如果提到排序，通常指的是排升序（非降序）。<br>通常意义上的排序，都是指的原地排序(in place sort)。</p><h3 id="1-2-稳定性（重要）"><a href="#1-2-稳定性（重要）" class="headerlink" title="1.2 稳定性（重要）"></a>1.2 稳定性（重要）</h3><p>&emsp;两个相等的数据，如果经过排序后，排序算法能保证其相对位置不发生变化，则我们称该算法是具备稳定性的排序算法。</p><p><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/Sort.png" alt=" "></p><h3 id="1-3-应用"><a href="#1-3-应用" class="headerlink" title="1.3 应用"></a>1.3 应用</h3><ol><li>各大商城的价格从低到高等<br><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E6%B7%98%E5%AE%9D%E6%8E%92%E5%BA%8F.png" alt=" "></li><li>中国大学排名<br><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6.png" alt=" "></li></ol><h2 id="2-七大基于比较的排序"><a href="#2-七大基于比较的排序" class="headerlink" title="2.七大基于比较的排序"></a>2.七大基于比较的排序</h2><p><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E4%B8%83%E5%A4%A7%E6%8E%92%E5%BA%8F.png" alt=" "></p><p><a href="https://www.bilibili.com/video/av17449274" target="_blank" rel="noopener">排序舞蹈</a></p><h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h2><h3 id="3-1-直接插入排序-原理"><a href="#3-1-直接插入排序-原理" class="headerlink" title="3.1 直接插入排序-原理"></a>3.1 直接插入排序-原理</h3><p>整个区间被分为</p><ul><li><ol><li>有序区间</li></ol></li><li><ol start="2"><li>无序区间</li></ol></li></ul><p>每次选择无序区间的第一个元素，在有序区间内选择合适的位置插入<br><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.png" alt=" "></p><h3 id="3-2-实现"><a href="#3-2-实现" class="headerlink" title="3.2 实现"></a>3.2 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 有序区间: [0, i)</span></span><br><span class="line">        <span class="comment">// 无序区间: [i, array.length)</span></span><br><span class="line">        <span class="keyword">int</span> v = array[i]; <span class="comment">// 无序区间的第一个数</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 不写 array[j] == v 是保证排序的稳定性</span></span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; v; j--) &#123;</span><br><span class="line">            array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">       &#125;</span><br><span class="line">        array[j + <span class="number">1</span>] = v;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-性能分析"><a href="#3-3-性能分析" class="headerlink" title="3.3 性能分析"></a>3.3 性能分析</h3><p>时间复杂度</p><table><thead><tr><th align="center">最好</th><th align="center">平均</th><th align="center">最坏</th></tr></thead><tbody><tr><td align="center">O(n)</td><td align="center">O(n^2)</td><td align="center">O(n^2)</td></tr><tr><td align="center">数据有序</td><td align="center"></td><td align="center">数据逆序</td></tr></tbody></table><table><thead><tr><th align="center">空间复杂度</th><th align="center">O(1)</th></tr></thead></table><h3 id="3-4-折半插入排序"><a href="#3-4-折半插入排序" class="headerlink" title="3.4 折半插入排序"></a>3.4 折半插入排序</h3><p>在有序区间选择数据应该插入的位置时，因为区间的有序性，可以利用折半查找的思想。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bsInsertSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = array[i];</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = i;</span><br><span class="line">        <span class="comment">// [left, right)</span></span><br><span class="line">        <span class="comment">// 需要考虑稳定性</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (v &gt;= array[m]) &#123;</span><br><span class="line">                left = m + <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = m;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="comment">// 搬移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; left; j--) &#123;</span><br><span class="line">            array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">       &#125;</span><br><span class="line">         array[left] = v;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h2><h3 id="4-1-原理"><a href="#4-1-原理" class="headerlink" title="4.1 原理"></a>4.1 原理</h3><p>&emsp;希尔排序法又称缩小增量法。希尔排序法的基本思想是：先选定一个整数，把待排序文件中所有记录分成个组，所有<br>距离为的记录分在同一组内，并对每一组内的记录进行排序。然后，取，重复上述分组和排序的工作。当到达=1时，<br>所有记录在统一组内排好序。</p><ul><li><ol><li>希尔排序是对直接插入排序的优化。</li></ol></li><li><ol start="2"><li>当gap &gt; 1时都是预排序，目的是让数组更接近于有序。当gap == 1时，数组已经接近有序的了，这样就会很快。这样整体而言，可以达到优化的效果。我们实现后可以进行性能测试的对比。<br><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.png" alt=" "><br><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.png" alt=" "></li></ol></li></ul><h3 id="4-2-实现"><a href="#4-2-实现" class="headerlink" title="4.2 实现"></a>4.2 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap = array.length;</span><br><span class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        insertSortGap(array, gap);</span><br><span class="line">        gap = (gap / <span class="number">3</span>) + <span class="number">1</span>; <span class="comment">// OR gap = gap / 2;</span></span><br><span class="line">   &#125;</span><br><span class="line">    insertSortGap(array, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSortGap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> gap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = array[i];</span><br><span class="line">        <span class="keyword">int</span> j = i - gap;</span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; v; j -= gap) &#123;</span><br><span class="line">            array[j + gap] = array[j];</span><br><span class="line">       &#125;</span><br><span class="line">        array[j + gap] = v;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-性能分析"><a href="#4-3-性能分析" class="headerlink" title="4.3 性能分析"></a>4.3 性能分析</h3><p>时间复杂度</p><table><thead><tr><th align="center">最好</th><th align="center">平均</th><th align="center">最坏</th></tr></thead><tbody><tr><td align="center">O(n)</td><td align="center">O(n^1.3)</td><td align="center">O(n^2)</td></tr><tr><td align="center">数据有序</td><td align="center"></td><td align="center">比较难构造</td></tr></tbody></table><table><thead><tr><th align="center">空间复杂度</th><th align="center">O(1)</th></tr></thead></table><p>稳定性：不稳定</p><h2 id="5-选择排序"><a href="#5-选择排序" class="headerlink" title="5. 选择排序"></a>5. 选择排序</h2><h3 id="5-1-直接选择排序-原理"><a href="#5-1-直接选择排序-原理" class="headerlink" title="5.1 直接选择排序-原理"></a>5.1 直接选择排序-原理</h3><p>每一次从无序区间选出最大（或最小）的一个元素，存放在无序区间的最后（或最前），直到全部待排序的数据元素排完 。<br><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.png" alt=" "></p><h3 id="5-2-实现"><a href="#5-2-实现" class="headerlink" title="5.2 实现"></a>5.2 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 无序区间: [0, array.length - i)</span></span><br><span class="line">        <span class="comment">// 有序区间: [array.length - i, array.length)</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; array.length - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[max]) &#123;</span><br><span class="line">                max = j;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">int</span> t = array[max];</span><br><span class="line">        array[max] = array[array.length - i - <span class="number">1</span>];</span><br><span class="line">        array[array.length - i - <span class="number">1</span>] = t;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-性能分析"><a href="#5-3-性能分析" class="headerlink" title="5.3 性能分析"></a>5.3 性能分析</h3><table><thead><tr><th align="center">时间复杂度</th><th align="center">空间复杂度</th></tr></thead><tbody><tr><td align="center">O(n^2)</td><td align="center">O(1)</td></tr><tr><td align="center">数据不敏感</td><td align="center">数据不敏感</td></tr></tbody></table><p>稳定性：不稳定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123; <span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>a, <span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>b &#125;;</span><br><span class="line"><span class="comment">// 交换中该情况无法识别，保证 5a 还在 5b 前边</span></span><br></pre></td></tr></table></figure><h3 id="5-4-双向选择排序"><a href="#5-4-双向选择排序" class="headerlink" title="5.4 双向选择排序"></a>5.4 双向选择排序</h3><p>每一次从无序区间选出最小 + 最大的元素，存放在无序区间的最前和最后，直到全部待排序的数据元素排完。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSortOP</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// [low, high] 表示整个无序区间</span></span><br><span class="line">    <span class="comment">// 无序区间内只有一个数也可以停止排序了</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = low;</span><br><span class="line">        <span class="keyword">int</span> max = low;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = low + <span class="number">1</span>; i &lt;= max; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt; array[min]) &#123;</span><br><span class="line">                min = i;</span><br><span class="line">           &#125;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &gt; array[max]) &#123;</span><br><span class="line">                max = i;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        swap(array, min, low);</span><br><span class="line">        <span class="comment">// 见下面例子讲解</span></span><br><span class="line">        <span class="keyword">if</span> (max == low) &#123;</span><br><span class="line">            max = min;</span><br><span class="line">       &#125;</span><br><span class="line">        swap(array, max, high);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = t; &#125;</span><br><span class="line">array = &#123; <span class="number">9</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span> &#125;; <span class="comment">// 交换之前</span></span><br><span class="line"><span class="comment">// low = 0; high = 6</span></span><br><span class="line"><span class="comment">// max = 0; min = 2</span></span><br><span class="line">array = &#123; <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span> &#125;; <span class="comment">// 将最小的交换到无序区间的最开始后</span></span><br><span class="line"><span class="comment">// max = 0，但实际上最大的数已经不在 0 位置，而是被交换到 min 即 2 位置了</span></span><br><span class="line"><span class="comment">// 所以需要让 max = min 即 max = 2</span></span><br><span class="line">array = &#123; <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span> &#125;; <span class="comment">// 将最大的交换到无序区间的最结尾后</span></span><br></pre></td></tr></table></figure><h2 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6. 堆排序"></a>6. 堆排序</h2><h3 id="6-1-原理"><a href="#6-1-原理" class="headerlink" title="6.1 原理"></a>6.1 原理</h3><p>基本原理也是选择排序，只是不在使用遍历的方式查找无序区间的最大的数，而是通过堆来选择无序区间的最大的<br>数。<br>注意： 排升序要建大堆；排降序要建小堆。</p><p><a href="https://www.cs.usfca.edu/~galles/visualization/HeapSort.html" target="_blank" rel="noopener">堆排序</a></p><p><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E5%A0%86%E6%8E%92%E5%BA%8F.png" alt=" "></p><h3 id="6-2-实现"><a href="#6-2-实现" class="headerlink" title="6.2 实现"></a>6.2 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    createHeap(array);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 交换前</span></span><br><span class="line">        <span class="comment">// 无序区间: [0, array.length - i)</span></span><br><span class="line">        <span class="comment">// 有序区间: [array.length - i, array.length)</span></span><br><span class="line">        swap(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 交换后</span></span><br><span class="line">        <span class="comment">// 无序区间: [0, array.length - i - 1)</span></span><br><span class="line">        <span class="comment">// 有序区间: [array.length - i - 1, array.length)</span></span><br><span class="line">        <span class="comment">// 无序区间长度: array.length - i - 1</span></span><br><span class="line">        shiftDown(array, array.length - i - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = t; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createHeap</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (array.length - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        shiftDown(array, array.length, i);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> size, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; size) &#123;</span><br><span class="line">        <span class="keyword">int</span> max = left;</span><br><span class="line">   <span class="keyword">int</span> right = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[right] &gt; array[left]) &#123;</span><br><span class="line">                max = right;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">if</span> (array[index] &gt;= array[max]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">int</span> t = array[index];</span><br><span class="line">        array[index] = array[max];</span><br><span class="line">        array[max] = t;</span><br><span class="line">        index = max;</span><br><span class="line">        left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-性能分析"><a href="#6-3-性能分析" class="headerlink" title="6.3 性能分析"></a>6.3 性能分析</h3><table><thead><tr><th align="center">时间复杂度</th><th align="center">空间复杂度</th></tr></thead><tbody><tr><td align="center">O(n * log(n))</td><td align="center">O(1)</td></tr><tr><td align="center">数据不敏感</td><td align="center">数据不敏感</td></tr></tbody></table><p>稳定性：不稳定</p><h2 id="7-冒泡排序"><a href="#7-冒泡排序" class="headerlink" title="7. 冒泡排序"></a>7. 冒泡排序</h2><h3 id="7-1-原理"><a href="#7-1-原理" class="headerlink" title="7.1 原理"></a>7.1 原理</h3><p>在无序区间，通过相邻数的比较，将最大的数冒泡到无序区间的最后，持续这个过程，直到数组整体有序<br><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.png" alt=" "></p><h3 id="7-2-实现"><a href="#7-2-实现" class="headerlink" title="7.2 实现"></a>7.2 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"> <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line"> <span class="comment">// 相等不交换，保证稳定性</span></span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(array, j, j + <span class="number">1</span>);</span><br><span class="line">                isSorted = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-性能分析"><a href="#7-3-性能分析" class="headerlink" title="7.3 性能分析"></a>7.3 性能分析</h3><p>时间复杂度<br>最好|平均|最坏<br>:-:|:-:|:-:<br>O(n)|O(n^2)|O(n^2)<br>数据有序| |数据逆序</p><table><thead><tr><th align="center">空间复杂度</th><th align="center">O(1)</th></tr></thead></table><p>稳定性：稳定</p><h2 id="8-快速排序"><a href="#8-快速排序" class="headerlink" title="8. 快速排序"></a>8. 快速排序</h2><h3 id="8-1-原理"><a href="#8-1-原理" class="headerlink" title="8.1 原理"></a>8.1 原理</h3><ul><li><ol><li>从待排序区间选择一个数，作为基准值(pivot)；</li></ol></li><li><ol start="2"><li>Partition: 遍历整个待排序区间，将比基准值小的（可以包含相等的）放到基准值的左边，将比基准值大的（可以包含相等的）放到基准值的右边；</li></ol></li><li><ol start="3"><li>采用分治思想，对左右两个小区间按照同样的方式处理，直到小区间的长度 == 1，代表已经有序，或者小区间的长度 == 0，代表没有数据。<br><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png" alt=" "></li></ol></li></ul><p><strong>实现:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line"> quickSortInternal(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [left, right] 为待排序区间</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortInternal</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 最简单的选择基准值的方式，选择 array[left] 作为基准值</span></span><br><span class="line"> <span class="comment">// pivotIndex 代表基准值最终停留的下标</span></span><br><span class="line"> <span class="keyword">int</span> pivotIndex = partition(array, left, right);</span><br><span class="line"> <span class="comment">// [left, pivotIndex - 1] 都是小于等于基准值的</span></span><br><span class="line"> <span class="comment">// [pivotIndex + 1, right] 都是大于等于基准值的</span></span><br><span class="line"> quickSortInternal(array, left, pivotIndex - <span class="number">1</span>);</span><br><span class="line"> quickSortInternal(array, pivotIndex + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-原理-partition"><a href="#8-2-原理-partition" class="headerlink" title="8.2 原理-partition"></a>8.2 原理-partition</h3><h4 id="Hoare-法"><a href="#Hoare-法" class="headerlink" title="Hoare 法"></a>Hoare 法</h4><p><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/Hoare.png" alt=" "><br><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/Hoare2.png" alt=" "></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> i = left;</span><br><span class="line"> <span class="keyword">int</span> j = right;</span><br><span class="line"> <span class="keyword">int</span> pivot = array[left];</span><br><span class="line"> <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"> <span class="keyword">while</span> (i &lt; j &amp;&amp; array[j] &gt;= pivot) &#123;</span><br><span class="line"> j--;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">while</span> (i &lt; j &amp;&amp; array[i] &lt;= pivot) &#123;</span><br><span class="line"> i++;</span><br><span class="line"> &#125;</span><br><span class="line"> swap(array, i, j);</span><br><span class="line"> &#125;</span><br><span class="line"> swap(array, i, left);</span><br><span class="line"> <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-性能分析"><a href="#8-3-性能分析" class="headerlink" title="8.3 性能分析"></a>8.3 性能分析</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><table><thead><tr><th align="center">最好</th><th align="center">平均</th><th align="center">最坏</th></tr></thead><tbody><tr><td align="center">O(n*log(n))</td><td align="center">O(n*log(n))</td><td align="center">O(n^2)</td></tr></tbody></table><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><table><thead><tr><th align="center">最好</th><th align="center">平均</th><th align="center">最坏</th></tr></thead><tbody><tr><td align="center">O(log(n))</td><td align="center">O(log(n))</td><td align="center">O(n)</td></tr></tbody></table><p>稳定性：不稳定</p><h3 id="8-4-原理-基准值的选择"><a href="#8-4-原理-基准值的选择" class="headerlink" title="8.4 原理-基准值的选择"></a>8.4 原理-基准值的选择</h3><ul><li><ol><li>选择边上（左或者右）</li></ol></li><li><ol start="2"><li>随机选择</li></ol></li><li><ol start="3"><li>几数取中（例如三数取中）：array[left], array[mid], array[right] 大小是中间的为基准值</li></ol></li></ul><h3 id="8-5-原理-非递归分治"><a href="#8-5-原理-非递归分治" class="headerlink" title="8.5 原理-非递归分治"></a>8.5 原理-非递归分治</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line"> Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"> stack.push(array.length - <span class="number">1</span>);</span><br><span class="line"> stack.push(<span class="number">0</span>);</span><br><span class="line"> <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line"> <span class="keyword">int</span> left = stack.pop();</span><br><span class="line"> <span class="keyword">int</span> right = stack.pop();</span><br><span class="line"> <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line"> <span class="keyword">continue</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">int</span> pivotIndex = partition(array, left, right);</span><br><span class="line"> stack.push(right);</span><br><span class="line"> stack.push(pivotIndex + <span class="number">1</span>);</span><br><span class="line"> stack.push(pivotIndex - <span class="number">1</span>);</span><br><span class="line"> stack.push(left);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-归并排序"><a href="#9-归并排序" class="headerlink" title="9. 归并排序"></a>9. 归并排序</h2><h3 id="9-1-原理"><a href="#9-1-原理" class="headerlink" title="9.1 原理"></a>9.1 原理</h3><p>&emsp;归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and<br>Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><p><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.png" alt=" "><br><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F2.png" alt=" "></p><h3 id="9-2-原理-合并两个有序数组"><a href="#9-2-原理-合并两个有序数组" class="headerlink" title="9.2 原理-合并两个有序数组"></a>9.2 原理-合并两个有序数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> i = low;</span><br><span class="line"> <span class="keyword">int</span> j = mid;</span><br><span class="line"> <span class="keyword">int</span> length = high - low;</span><br><span class="line"> <span class="keyword">int</span>[] extra = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"> <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"> <span class="comment">// 选择小的放入 extra</span></span><br><span class="line"> <span class="keyword">while</span> (i &lt; mid &amp;&amp; j &lt; high) &#123;</span><br><span class="line"> <span class="comment">// 加入等于，保证稳定性</span></span><br><span class="line"> <span class="keyword">if</span> (array[i] &lt;= array[j]) &#123;</span><br><span class="line"> extra[k++] = array[i++];</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> extra[k++] = array[j++];</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 将属于元素放入 extra</span></span><br><span class="line"> <span class="keyword">while</span> (i &lt; mid) &#123;</span><br><span class="line"> extra[k++] = array[i++];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> j &lt; right) &#123;</span><br><span class="line"> extra[k++] = array[j++];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 从 extra 搬移回 array</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; length; t++) &#123;</span><br><span class="line"> <span class="comment">// 需要搬移回原位置，从 low 开始</span></span><br><span class="line"> array[low + t] = extra[t];</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-实现"><a href="#9-3-实现" class="headerlink" title="9.3 实现"></a>9.3 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line"> mergeSortInternal(array, <span class="number">0</span>, array.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 待排序区间为 [low, high)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSortInternal</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (low - <span class="number">1</span> &gt;= high) &#123;</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"> mergeSortInternal(array, low, mid);</span><br><span class="line"> mergeSortInternal(array, mid, high);</span><br><span class="line"> merge(array, low, mid, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-4-性能分析"><a href="#9-4-性能分析" class="headerlink" title="9.4 性能分析"></a>9.4 性能分析</h3><table><thead><tr><th align="center">时间复杂度</th><th align="center">空间复杂度</th></tr></thead><tbody><tr><td align="center">O(n*log(n))</td><td align="center">O(n)</td></tr><tr><td align="center">数据不敏感</td><td align="center">数据不敏感</td></tr></tbody></table><p>稳定性：稳定</p><h3 id="9-5-优化总结"><a href="#9-5-优化总结" class="headerlink" title="9.5 优化总结"></a>9.5 优化总结</h3><p>在排序过程中重复利用两个数组，减少元素的复制过程</p><h3 id="9-6-非递归版本"><a href="#9-6-非递归版本" class="headerlink" title="9.6 非递归版本"></a>9.6 非递归版本</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i = i * <span class="number">2</span>) &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length; j = j + <span class="number">2</span> * i) &#123;</span><br><span class="line"> <span class="keyword">int</span> low = j;</span><br><span class="line"> <span class="keyword">int</span> mid = j + i;</span><br><span class="line"> <span class="keyword">if</span> (mid &gt;= array.length) &#123;</span><br><span class="line"> <span class="keyword">continue</span>;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">int</span> high = mid + i;</span><br><span class="line"> <span class="keyword">if</span> (high &gt; array.length) &#123;</span><br><span class="line"> high = array.length;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> merge(array, low, mid, high);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-7-海量数据的排序问题"><a href="#9-7-海量数据的排序问题" class="headerlink" title="9.7 海量数据的排序问题"></a>9.7 海量数据的排序问题</h3><p>外部排序：排序过程需要在磁盘等外部存储进行的排序<br>前提：内存只有 1G，需要排序的数据有 100G<br>因为内存中因为无法把所有数据全部放下，所以需要外部排序，而归并排序是最常用的外部排序</p><ul><li><ol><li>先把文件切分成 200 份，每个 512 M</li></ol></li><li><ol start="2"><li>分别对 512 M 排序，因为内存已经可以放的下，所以任意排序方式都可以</li></ol></li><li><ol start="3"><li>进行 200 路归并，同时对 200 份有序文件做归并过程，最终结果就有序了</li></ol></li></ul><h2 id="10-排序总结"><a href="#10-排序总结" class="headerlink" title="10.  排序总结"></a>10.  排序总结</h2><p><img src="/2020/01/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93.png" alt=" "></p><p>排序方法|最好|平均|最坏|空间复杂度|稳定性<br>:-:|:-:|:-:|:-:|:-:|:-:|:-:<br>冒泡排序|O(n)|O(n^2)|O(n^2)|O(1)|稳定<br>插入排序|O(n)|O(n^2)|O(n^2)|O(1)|稳定<br>选择排序|O(n^2)|O(n^2)|O(n^2)|O(1)|不稳定<br>希尔排序|O(n)|O(n^1.3)|O(n^2)|O(1)|不稳定<br>堆排序|O(n<em>log(n))|O(n</em>log(n))|O(n<em>log(n))|O(1)|不稳定<br>快速排序|O(n</em>log(n))|O(n<em>log(n))|O(n^2)|O(log(n))~O(n)|不稳定<br>归并排序|O(n</em>log(n))|O(n<em>log(n))|O(n</em>log(n))|O(n)|稳定</p><h2 id="11-其他非基于比较的排序"><a href="#11-其他非基于比较的排序" class="headerlink" title="11. 其他非基于比较的排序"></a>11. 其他非基于比较的排序</h2><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a><a href="https://zhuanlan.zhihu.com/p/26595385?group_id=842495057868226560" target="_blank" rel="noopener">计数排序</a></h3><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a><a href="https://www.runoob.com/w3cnote/radix-sort.html" target="_blank" rel="noopener">基数排序</a></h3><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a><a href="https://www.cnblogs.com/bqwzx/p/11029264.html" target="_blank" rel="noopener">桶排序</a></h3>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap和TreeMap对比</title>
      <link href="/2019/12/04/HashMap%E5%92%8CTreeMap%E5%AF%B9%E6%AF%94/"/>
      <url>/2019/12/04/HashMap%E5%92%8CTreeMap%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap主要用来存放键值对，它基于哈希表的Map接口实现，是常用的Java集合之一，数据是无序的</p><p><img src="/2019/12/04/HashMap%E5%92%8CTreeMap%E5%AF%B9%E6%AF%94/HashMap%E5%AD%98%E6%94%BE.png" alt="HashMap存放"></p><p>jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p><p><img src="/2019/12/04/HashMap%E5%92%8CTreeMap%E5%AF%B9%E6%AF%94/jdk1.8%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81.png" alt="jdk1.8解决哈希冲突"></p><p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的.</p><p>HashMap的时间复杂度O(1),但是如果冲突较多，链表的时间复杂度是O(n)，所以在JDK1.8 以后，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间，红黑树的时间复杂度是O(log n)。 所以查询一个HashMap数据的时间为 O(1) + O(n)或O(1) + O(log n）平均为O(1)<br>总结：HashMap根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度，插入、删除和定位元素，HashMap是最好的选择。</p><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap是基于红黑树实现的一个保证有序性的Map 基于红黑树，所以TreeMap的时间复杂度是O(log n)，如果需要有排序的数据，直接存放进TreeMap中就行，TreeMap自己会给排序，不需要再写排序代码。</p><p>总结：TreeMap取出来的是排序后的键值对。插入、删除需要维护平衡会牺牲一些效率。但如果要按自然顺序或自定义顺序遍历，那么TreeMap会更好。</p><p>HashMap通过hashcode对其内容进行快速查找，而 TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap。HashMap通常比TreeMap效率要高一些，一个是哈希表，一个是二叉树，建议多使用HashMap，在需要排序的Map时候才用TreeMap。HashMap的查询速度比TreeMap要快</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
            <tag> TreeMap </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合类：Set、List、Map使用场景</title>
      <link href="/2019/11/08/Java%E9%9B%86%E5%90%88%E7%B1%BB%EF%BC%9ASet%E3%80%81List%E3%80%81Map%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2019/11/08/Java%E9%9B%86%E5%90%88%E7%B1%BB%EF%BC%9ASet%E3%80%81List%E3%80%81Map%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-Java集合类基本概念"><a href="#1-Java集合类基本概念" class="headerlink" title="1. Java集合类基本概念"></a>1. Java集合类基本概念</h2><p>&emsp;在编程中，常常需要集中存放多个数据。从传统意义上讲，数组是我们的一个很好的选择，前提是我们事先已经明确知道我们将要保存的对象的数量。一旦在数组初始化时指定了这个数组长度，这个数组长度就是不可变的，如果我们需要保存一个可以动态增长的数据(在编译时无法确定具体的数量)，java的集合类就是一个很好的设计方案了。</p><p>&emsp;集合类主要负责保存、盛装其他数据，因此集合类也被称为容器类。所以的集合类都位于java.util包下，后来为了处理多线程环境下的并发安全问题，java5还在java.util.concurrent包下提供了一些多线程支持的集合类。</p><p>&emsp;在学习Java中的集合类的API、编程原理的时候，我们一定要明白，”集合”是一个很古老的数学概念，它远远早于Java的出现。从数学概念的角度来理解集合能帮助我们更好的理解编程中什么时候该使用什么类型的集合类。</p><p><img src="/2019/11/08/Java%E9%9B%86%E5%90%88%E7%B1%BB%EF%BC%9ASet%E3%80%81List%E3%80%81Map%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.jpg" alt="java集合框架"></p><p>Java容器类类库的用途是”保存对象”，并将其划分为两个不同的概念：</p><h3 id="1-Collection"><a href="#1-Collection" class="headerlink" title="1) Collection"></a>1) Collection</h3><p>一组”对立”的元素，通常这些元素都服从某种规则</p><ul><li><p>1.1) List必须保持元素特定的顺序</p></li><li><p>1.2) Set不能有重复元素</p></li><li><p>1.3) Queue保持一个队列(先进先出)的顺序</p></li></ul><h3 id="2-Map"><a href="#2-Map" class="headerlink" title="2) Map"></a>2) Map</h3><p>一组成对的”键值对”对象</p><p>Collection和Map的区别在于容器中每个位置保存的元素个数:</p><ul><li>1) Collection 每个位置只能保存一个元素(对象)</li><li>2) Map保存的是”键值对”，就像一个小型数据库。我们可以通过”键”找到该键对应的”值”</li></ul><h2 id="2-Java集合类架构层次关系"><a href="#2-Java集合类架构层次关系" class="headerlink" title="2. Java集合类架构层次关系"></a>2. Java集合类架构层次关系</h2><h3 id="1）Interface-Iterable"><a href="#1）Interface-Iterable" class="headerlink" title="1）Interface Iterable"></a>1）Interface Iterable</h3><blockquote><p>迭代器接口，这是Collection类的父接口。实现这个Iterable接口的对象允许使用foreach进行遍历，也就是说，所有的Collection集合对象都具有”foreach可遍历性”。这个Iterable接口只有一个方法: iterator()。它返回一个代表当前集合对象的泛型&lt; T &gt;迭代器，用于之后的遍历操作</p></blockquote><h4 id="1-1-Collection"><a href="#1-1-Collection" class="headerlink" title="1.1 Collection"></a>1.1 Collection</h4><blockquote><p>Collection是最基本的集合接口，一个Collection代表一组Object的集合，这些Object被称作Collection的元素。Collection是一个接口，用以提供规范定义，不能被实例化使用</p></blockquote><h5 id="1-Set"><a href="#1-Set" class="headerlink" title="1) Set"></a>1) Set</h5><blockquote><p>Set集合类似于一个罐子，”丢进”Set集合里的多个对象之间没有明显的顺序。Set继承自Collection接口，不能包含有重复元素(记住，这是整个Set类层次的共有属性)。</p></blockquote><p>Set判断两个对象相同不是使用”==”运算符，而是根据equals方法。也就是说，我们在加入一个新元素的时候，如果这个新元素对象和Set中已有对象进行注意equals比较都返回false，　　<br>则Set就会接受这个新元素对象，否则拒绝。</p><p>因为Set的这个制约，在使用Set集合的时候，应该注意两点：</p><ul><li><p>1) 为Set集合里的元素的实现类实现一个有效的equals(Object)方法</p></li><li><p>2) 对Set的构造函数，传入的Collection参数不能包<br>　　含重复的元素</p></li></ul><h6 id="1-1-HashSet"><a href="#1-1-HashSet" class="headerlink" title="1.1) HashSet"></a>1.1) HashSet</h6><blockquote><p>HashSet是Set接口的典型实现，HashSet使用HASH算法来存储集合中的元素，因此具有良好的存取和查找性能。当向HashSet集合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据该HashCode值决定该对象在HashSet中的存储位置。</p></blockquote><p>值得主要的是，HashSet集合判断两个元素相等的标准是两个对象通过equals()方法比较相等，并且两个对象的hashCode()方法的返回值相等</p><ul><li>1.1.1) LinkedHashSet</li></ul><blockquote><p>LinkedHashSet集合也是根据元素的hashCode值来决定元素的存储位置，但和HashSet不同的是，它同时使用链表维护元素的次序，这样使得元素看起来是以插入的顺序保存的。当遍历LinkedHashSet集合里的元素时,LinkedHashSet将会按元素的添加顺序来访问集合里的元素。</p></blockquote><p>LinkedHashSet需要维护元素的插入顺序，因此性能略低于HashSet的性能，但在迭代访问Set里的全部元素时(遍历)将有很好的性能(链表很适合进行遍历)</p><h6 id="1-2-SortedSet"><a href="#1-2-SortedSet" class="headerlink" title="1.2) SortedSet"></a>1.2) SortedSet</h6><blockquote><p>此接口主要用于排序操作，即实现此接口的子类都属于排序的子类</p></blockquote><ul><li>1.2.1) TreeSet</li></ul><blockquote><p>TreeSet是SortedSet接口的实现类，TreeSet可以确保集合元素处于排序状态</p></blockquote><h6 id="1-3-EnumSet"><a href="#1-3-EnumSet" class="headerlink" title="1.3) EnumSet"></a>1.3) EnumSet</h6><blockquote><p>EnumSet是一个专门为枚举类设计的集合类，EnumSet中所有元素都必须是指定枚举类型的枚举值，该枚举类型在创建EnumSet时显式、或隐式地指定。EnumSet的集合元素也是有序的，<br>它们以枚举值在Enum类内的定义顺序来决定集合元素的顺序</p></blockquote><h5 id="2-List"><a href="#2-List" class="headerlink" title="2) List"></a>2) List</h5><blockquote><p>List集合代表一个元素有序、可重复的集合，集合中每个元素都有其对应的顺序索引。List集合允许加入重复元素，因为它可以通过索引来访问指定位置的集合元素。List集合默认按元素的添加顺序设置元素的索引</p></blockquote><h6 id="2-1-ArrayList"><a href="#2-1-ArrayList" class="headerlink" title="2.1) ArrayList"></a>2.1) ArrayList</h6><blockquote><p>ArrayList是基于数组实现的List类，它封装了一个动态的增长的、允许再分配的Object[]数组。</p></blockquote><h6 id="2-2-Vector"><a href="#2-2-Vector" class="headerlink" title="2.2) Vector"></a>2.2) Vector</h6><blockquote><p>Vector和ArrayList在用法上几乎完全相同，但由于Vector是一个古老的集合，所以Vector提供了一些方法名很长的方法，但随着JDK1.2以后，java提供了系统的集合框架，就将<br>Vector改为实现List接口，统一归入集合框架体系中</p></blockquote><ul><li>2.2.1) Stack</li></ul><blockquote><p>Stack是Vector提供的一个子类，用于模拟”栈”这种数据结构(LIFO后进先出)</p></blockquote><h6 id="2-3-LinkedList"><a href="#2-3-LinkedList" class="headerlink" title="2.3) LinkedList"></a>2.3) LinkedList</h6><blockquote><p>implements List&lt; E &gt;, Deque&lt; E &gt;。实现List接口，能对它进行队列操作，即可以根据索引来随机访问集合中的元素。同时它还实现Deque接口，即能将LinkedList当作双端队列<br>使用。自然也可以被当作”栈来使用”</p></blockquote><h5 id="3-Queue"><a href="#3-Queue" class="headerlink" title="3) Queue"></a>3) Queue</h5><blockquote><p>Queue用于模拟”队列”这种数据结构(先进先出 FIFO)。队列的头部保存着队列中存放时间最长的元素，队列的尾部保存着队列中存放时间最短的元素。新元素插入(offer)到队列的尾部，访问元素(poll)操作会返回队列头部的元素，队列不允许随机访问队列中的元素。结合生活中常见的排队就会很好理解这个概念</p></blockquote><h6 id="3-1-PriorityQueue"><a href="#3-1-PriorityQueue" class="headerlink" title="3.1) PriorityQueue"></a>3.1) PriorityQueue</h6><blockquote><p>PriorityQueue并不是一个比较标准的队列实现，PriorityQueue保存队列元素的顺序并不是按照加入队列的顺序，而是按照队列元素的大小进行重新排序，这点从它的类名也可以看出来。</p></blockquote><h6 id="3-2-Deque"><a href="#3-2-Deque" class="headerlink" title="3.2) Deque"></a>3.2) Deque</h6><blockquote><p>Deque接口代表一个”双端队列”，双端队列可以同时从两端来添加、删除元素，因此Deque的实现类既可以当成队列使用、也可以当成栈使用</p></blockquote><ul><li>3.2.1) ArrayDeque</li></ul><blockquote><p>是一个基于数组的双端队列，和ArrayList类似，它们的底层都采用一个动态的、可重分配的Object[]数组来存储集合元素，当集合元素超出该数组的容量时，系统会在底层重新分配一个Object[]数组来存储集合元素</p></blockquote><ul><li>3.2.2) LinkedList</li></ul><blockquote><p>LinkedList基于链表的数据结构,地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址，对于新增和删除操作add和remove，LinedList比较占优势。</p></blockquote><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><blockquote><p>Map用于保存具有”映射关系”的数据，因此Map集合里保存着两组值，一组值用于保存Map里的key，另外一组值用于保存Map里的value。key和value都可以是任何引用类型的数据。Map的key不允许重复，即同一个Map对象的任何两个key通过equals方法比较结果总是返回false。关于Map，我们要从代码复用的角度去理解，java是先实现了Map，然后通过包装了一个所有value都为null的Map就实现了Set集合</p></blockquote><p>Map的这些实现类和子接口中key集的存储形式和Set集合完全相同(即key不能重复)</p><p>Map的这些实现类和子接口中value集的存储形式和List非常类似(即value可以重复、根据索引来查找)</p><h5 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1) HashMap"></a>1) HashMap</h5><blockquote><p>和HashSet集合不能保证元素的顺序一样，HashMap也不能保证key-value对的顺序。并且类似于HashSet判断两个key是否相等的标准也是: 两个key通过equals()方法比较返回true、<br>同时两个key的hashCode值也必须相等</p></blockquote><h6 id="1-1-LinkedHashMap"><a href="#1-1-LinkedHashMap" class="headerlink" title="1.1) LinkedHashMap"></a>1.1) LinkedHashMap</h6><blockquote><p>LinkedHashMap也使用双向链表来维护key-value对的次序，该链表负责维护Map的迭代顺序，与key-value对的插入顺序一致(注意和TreeMap对所有的key-value进行排序进行区<br>分)</p></blockquote><h5 id="2-Hashtable"><a href="#2-Hashtable" class="headerlink" title="2) Hashtable"></a>2) Hashtable</h5><blockquote><p>是一个古老的Map实现类</p></blockquote><h6 id="2-1-Properties"><a href="#2-1-Properties" class="headerlink" title="2.1) Properties"></a>2.1) Properties</h6><blockquote><p>Properties对象在处理属性文件时特别方便(windows平台上的.ini文件)，Properties类可以把Map对象和属性文件关联起来，从而可以把Map对象中的key-value对写入到属性文件中，也可以把属性文件中的”属性名-属性值”加载到Map对象中</p></blockquote><h5 id="3-SortedMap"><a href="#3-SortedMap" class="headerlink" title="3) SortedMap"></a>3) SortedMap</h5><blockquote><p>正如Set接口派生出SortedSet子接口，SortedSet接口有一个TreeSet实现类一样，Map接口也派生出一个SortedMap子接口，SortedMap接口也有一个TreeMap实现类</p></blockquote><h6 id="3-1-TreeMap"><a href="#3-1-TreeMap" class="headerlink" title="3.1) TreeMap"></a>3.1) TreeMap</h6><blockquote><p>TreeMap就是一个红黑树数据结构，每个key-value对即作为红黑树的一个节点。TreeMap存储key-value对(节点)时，需要根据key对节点进行排序。TreeMap可以保证所有的<br>key-value对处于有序状态。同样，TreeMap也有两种排序方式: 自然排序、定制排序</p></blockquote><h5 id="4-WeakHashMap"><a href="#4-WeakHashMap" class="headerlink" title="4) WeakHashMap"></a>4) WeakHashMap</h5><blockquote><p>WeakHashMap与HashMap的用法基本相似。区别在于，HashMap的key保留了对实际对象的”强引用”，这意味着只要该HashMap对象不被销毁，该HashMap所引用的对象就不会被垃圾回收。但WeakHashMap的key只保留了对实际对象的弱引用，这意味着如果WeakHashMap对象的key所引用的对象没有被其他强引用变量所引用，则这些key所引用的对象可能被垃圾回收，当垃圾回收了该key所对应的实际对象之后，WeakHashMap也可能自动删除这些key所对应的key-value对</p></blockquote><h5 id="5-IdentityHashMap"><a href="#5-IdentityHashMap" class="headerlink" title="5) IdentityHashMap"></a>5) IdentityHashMap</h5><blockquote><p>IdentityHashMap的实现机制与HashMap基本相似，在IdentityHashMap中，当且仅当两个key严格相等(key1 == key2)时，IdentityHashMap才认为两个key相等</p></blockquote><h5 id="6-EnumMap"><a href="#6-EnumMap" class="headerlink" title="6) EnumMap"></a>6) EnumMap</h5><blockquote><p>EnumMap是一个与枚举类一起使用的Map实现，EnumMap中的所有key都必须是单个枚举类的枚举值。创建EnumMap时必须显式或隐式指定它对应的枚举类。EnumMap根据key的自然顺序<br>(即枚举值在枚举类中的定义顺序)</p></blockquote><h2 id="3-Java集合类的应用场景代码"><a href="#3-Java集合类的应用场景代码" class="headerlink" title="3. Java集合类的应用场景代码"></a>3. Java集合类的应用场景代码</h2><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">//类A的equals方法总是返回true,但没有重写其hashCode()方法。不能保证当前对象是HashSet中的唯一对象class A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类B的hashCode()方法总是返回1,但没有重写其equals()方法。不能保证当前对象是HashSet中的唯一对象class B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类C的hashCode()方法总是返回2,且有重写其equals()方法class C</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        HashSet books = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="comment">//分别向books集合中添加两个A对象，两个B对象，两个C对象</span></span><br><span class="line">        books.add(<span class="keyword">new</span> A());</span><br><span class="line">        books.add(<span class="keyword">new</span> A());</span><br><span class="line">        books.add(<span class="keyword">new</span> B());</span><br><span class="line">        books.add(<span class="keyword">new</span> B());</span><br><span class="line">        books.add(<span class="keyword">new</span> C());</span><br><span class="line">        books.add(<span class="keyword">new</span> C());</span><br><span class="line">        System.out.println(books);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">result:</span><br><span class="line">[B@<span class="number">1</span>, B@<span class="number">1</span>, C@<span class="number">2</span>, A@<span class="number">3</span>bc257, A@<span class="number">785</span>d65]</span><br></pre></td></tr></table></figure><p>可以看到，如果两个对象通过equals()方法比较返回true，但这两个对象的hashCode()方法返回不同的hashCode值时，这将导致HashSet会把这两个对象保存在Hash表的不同位置，从而使对象可以添加成功，这就与Set集合的规则有些出入了。所以，我们要明确的是: equals()决定是否可以加入HashSet、而hashCode()决定存放的位置，它们两者必须同时满足才能允许一个新元素加入HashSet<br>但是要注意的是: 如果两个对象的hashCode相同，但是它们的equlas返回值不同，HashSet会在这个位置用链式结构来保存多个对象。而HashSet访问集合元素时也是根据元素的HashCode值来快速定位的，这种链式结构会导致性能下降。<br>所以如果需要把某个类的对象保存到HashSet集合中，我们在重写这个类的equlas()方法和hashCode()方法时，应该尽量保证两个对象通过equals()方法比较返回true时，它们的hashCode()方法返回值也相等</p><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSetTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LinkedHashSet books = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">        books.add(<span class="string">"Java"</span>);</span><br><span class="line">        books.add(<span class="string">"LittleHann"</span>);</span><br><span class="line">        System.out.println(books);</span><br><span class="line">        <span class="comment">//删除 Java</span></span><br><span class="line">      books.remove(<span class="string">"Java"</span>);</span><br><span class="line">        <span class="comment">//重新添加 Java</span></span><br><span class="line">        books.add(<span class="string">"Java"</span>);</span><br><span class="line">        System.out.println(books);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>元素的顺序总是与添加顺序一致，同时要明白的是，LinkedHashSetTest是HashSet的子类，因此它不允许集合元素重复</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TreeSet nums = <span class="keyword">new</span> TreeSet();</span><br><span class="line">        <span class="comment">//向TreeSet中添加四个Integer对象</span></span><br><span class="line">        nums.add(<span class="number">5</span>);</span><br><span class="line">        nums.add(<span class="number">2</span>);</span><br><span class="line">        nums.add(<span class="number">10</span>);</span><br><span class="line">        nums.add(-<span class="number">9</span>);</span><br><span class="line">        <span class="comment">//输出集合元素，看到集合元素已经处于排序状态</span></span><br><span class="line">        System.out.println(nums);</span><br><span class="line">        <span class="comment">//输出集合里的第一个元素</span></span><br><span class="line">        System.out.println(nums.first());</span><br><span class="line">        <span class="comment">//输出集合里的最后一个元素</span></span><br><span class="line">        System.out.println(nums.last());</span><br><span class="line">        <span class="comment">//返回小于4的子集，不包含4</span></span><br><span class="line">        System.out.println(nums.headSet(<span class="number">4</span>));</span><br><span class="line">        <span class="comment">//返回大于5的子集，如果Set中包含5，子集中还包含5</span></span><br><span class="line">        System.out.println(nums.tailSet(<span class="number">5</span>));</span><br><span class="line">        <span class="comment">//返回大于等于-3，小于4的子集。</span></span><br><span class="line">        System.out.println(nums.subSet(-<span class="number">3</span> , <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与HashSet集合采用hash算法来决定元素的存储位置不同，TreeSet采用红黑树的数据结构来存储集合元素。TreeSet支持两种排序方式: 自然排序、定制排序</p><ul><li>自然排序:</li></ul><blockquote><p>TreeSet会调用集合元素的compareTo(Object obj)方法来比较元素之间的大小关系，然后将集合元素按升序排序，即自然排序。如果试图把一个对象添加到TreeSet时，则该对象的类必须实现Comparable接口，否则程序会抛出异常。当把一个对象加入TreeSet集合中时，TreeSet会调用该对象的compareTo(Object obj)方法与容器中的其他对象比较大小，然后根据红黑树结构找到它的存储位置。如果两个对象通过compareTo(Object obj)方法比较相等，新对象将无法添加到TreeSet集合中(牢记Set是不允许重复的概念)。</p></blockquote><p>注意: 当需要把一个对象放入TreeSet中，重写该对象对应类的equals()方法时，应该保证该方法与compareTo(Object obj)方法有一致的结果，即如果两个对象通过equals()方法比较返回true时，这两个对象通过compareTo(Object obj)方法比较结果应该也为0(即相等)</p><p>看到这里，我们应该明白：</p><p>1) 对与Set来说，它定义了equals()为唯一性判断的标准，而对于到了具体的实现，HashSet、TreeSet来说，它们又会有自己特有的唯一性判断标准，只有同时满足了才能判定为唯一性</p><p>2) 我们在操作这些集合类的时候，对和唯一性判断有关的函数重写要重点关注</p><ul><li>定制排序</li></ul><blockquote><p>TreeSet的自然排序是根据集合元素的大小，TreeSet将它们以升序排序。如果我们需要实现定制排序，则可以通过Comparator接口的帮助(类似PHP中的array_map回调处理函数的思想)。该接口里包含一个int compare(T o1， T o2)方法，该方法用于比较大小</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">M</span><span class="params">(<span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"M[age:"</span> + age + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest4</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TreeSet ts = <span class="keyword">new</span> TreeSet(<span class="keyword">new</span> Comparator()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//根据M对象的age属性来决定大小</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                M m1 = (M)o1;</span><br><span class="line">                M m2 = (M)o2;</span><br><span class="line">                <span class="keyword">return</span> m1.age &gt; m2.age ? -<span class="number">1</span></span><br><span class="line">                    : m1.age &lt; m2.age ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ts.add(<span class="keyword">new</span> M(<span class="number">5</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> M(-<span class="number">3</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> M(<span class="number">9</span>));</span><br><span class="line">        System.out.println(ts);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1) equals、compareTo决定的是怎么比的问题，即用什么field进行大小比较<br>2) 自然排序、定制排序、Comparator决定的是谁大的问题，即按什么顺序(升序、降序)进行排序它们的关注点是不同的，一定要注意区分</p><h3 id="EnumSet"><a href="#EnumSet" class="headerlink" title="EnumSet"></a>EnumSet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">enum</span> Season</span><br><span class="line">&#123;</span><br><span class="line">    SPRING,SUMMER,FALL,WINTER</span><br><span class="line">&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSetTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个EnumSet集合，集合元素就是Season枚举类的全部枚举值</span></span><br><span class="line">        EnumSet es1 = EnumSet.allOf(Season<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//输出[SPRING,SUMMER,FALL,WINTER]</span></span><br><span class="line">        System.out.println(es1);</span><br><span class="line">        <span class="comment">//创建一个EnumSet空集合，指定其集合元素是Season类的枚举值。</span></span><br><span class="line">        EnumSet es2 = EnumSet.noneOf(Season<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//输出[]</span></span><br><span class="line">        System.out.println(es2);</span><br><span class="line">        <span class="comment">//手动添加两个元素        es2.add(Season.WINTER);</span></span><br><span class="line">        es2.add(Season.SPRING);</span><br><span class="line">        <span class="comment">//输出[SPRING,WINTER]</span></span><br><span class="line">        System.out.println(es2);</span><br><span class="line">        <span class="comment">//以指定枚举值创建EnumSet集合</span></span><br><span class="line">        EnumSet es3 = EnumSet.of(Season.SUMMER , Season.WINTER);</span><br><span class="line">        <span class="comment">//输出[SUMMER,WINTER]</span></span><br><span class="line">        System.out.println(es3);</span><br><span class="line">        EnumSet es4 = EnumSet.range(Season.SUMMER , Season.WINTER);</span><br><span class="line">        <span class="comment">//输出[SUMMER,FALL,WINTER]</span></span><br><span class="line">        System.out.println(es4);</span><br><span class="line">        <span class="comment">//新创建的EnumSet集合的元素和es4集合的元素有相同类型，</span></span><br><span class="line">        <span class="comment">//es5的集合元素 + es4集合元素 = Season枚举类的全部枚举值</span></span><br><span class="line">        EnumSet es5 = EnumSet.complementOf(es4);</span><br><span class="line">        <span class="comment">//输出[SPRING]</span></span><br><span class="line">        System.out.println(es5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是Set集合类的编程应用场景。那么应该怎样选择何时使用这些集合类呢？</p><p>1) HashSet的性能总是比TreeSet好(特别是最常用的添加、查询元素等操作)，因为TreeSet需要额外的红黑树算法来维护集合元素的次序。只有当需要一个保持排序的Set时，才应该使用TreeSet，否则都应该使用HashSet</p><p>2) 对于普通的插入、删除操作，LinkedHashSet比HashSet要略慢一点，这是由维护链表所带来的开销造成的。不过，因为有了链表的存在，遍历LinkedHashSet会更快</p><p>3) EnumSet是所有Set实现类中性能最好的，但它只能保存同一个枚举类的枚举值作为集合元素</p><p>4) HashSet、TreeSet、EnumSet都是”线程不安全”的，通常可以通过Collections工具类的synchronizedSortedSet方法来”包装”该Set集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SortedSet s = Collections.synchronizedSortedSet(<span class="keyword">new</span> TreeSet(...));</span><br></pre></td></tr></table></figure><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>如果一开始就知道ArrayList集合需要保存多少元素，则可以在创建它们时就指定initialCapacity大小，这样可以减少重新分配的次数，提供性能，ArrayList还提供了如下方法来重新分配Object[]数组</p><p>1) ensureCapacity(int minCapacity): 将ArrayList集合的Object[]数组长度增加minCapacity</p><p>2) trimToSize(): 调整ArrayList集合的Object[]数组长度为当前元素的个数。程序可以通过此方法来减少ArrayList集合对象占用的内存空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List books = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="comment">//向books集合中添加三个元素</span></span><br><span class="line">        books.add(<span class="keyword">new</span> String(<span class="string">"轻量级Java EE应用"</span>));</span><br><span class="line">        books.add(<span class="keyword">new</span> String(<span class="string">"疯狂Java"</span>));</span><br><span class="line">        books.add(<span class="keyword">new</span> String(<span class="string">"疯狂Android"</span>));</span><br><span class="line">        System.out.println(books);</span><br><span class="line">        <span class="comment">//将新字符串对象插入在第二个位置</span></span><br><span class="line">        books.add(<span class="number">1</span> , <span class="keyword">new</span> String(<span class="string">"疯狂Ajax"</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; books.size() ; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(books.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除第三个元素</span></span><br><span class="line">        books.remove(<span class="number">2</span>);</span><br><span class="line">        System.out.println(books);</span><br><span class="line">        <span class="comment">//判断指定元素在List集合中位置：输出1，表明位于第二位</span></span><br><span class="line">        System.out.println(books.indexOf(<span class="keyword">new</span> String(<span class="string">"疯狂Ajax"</span>)));  <span class="comment">//①</span></span><br><span class="line">        <span class="comment">//将第二个元素替换成新的字符串对象</span></span><br><span class="line">        books.set(<span class="number">1</span>, <span class="keyword">new</span> String(<span class="string">"LittleHann"</span>));</span><br><span class="line">        System.out.println(books);</span><br><span class="line">        <span class="comment">//将books集合的第二个元素（包括）</span></span><br><span class="line">        <span class="comment">//到第三个元素（不包括）截取成子集合</span></span><br><span class="line">        System.out.println(books.subList(<span class="number">1</span> , <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>List集合类的编程应用场景。我们来梳理一下</p><ol><li><p>java提供的List就是一个”线性表接口”，ArrayList(基于数组的线性表)、LinkedList(基于链的线性表)是线性表的两种典型实现</p></li><li><p>因为数组以一块连续内存来保存所有的数组元素，所以数组在随机访问时性能最好。所以的内部以数组作为底层实现的集合在随机访问时性能最好。</p></li><li><p>内部以链表作为底层实现的集合在执行插入、删除操作时有很好的性能</p></li><li><p>进行迭代操作时，以链表作为底层实现的集合比以数组作为底层实现的集合性能好</p></li></ol><p>我们之前说过，Collection接口继承了Iterable接口，也就是说，我们以上学习到的所有的Collection集合类都具有”可遍历性”</p><p>Iterable接口也是java集合框架的成员，它隐藏了各种Collection实现类的底层细节，向应用程序提供了遍历Collection集合元素的统一编程接口:</p><p>1) boolean hasNext(): 是否还有下一个未遍历过的元素</p><p>2) Object next(): 返回集合里的下一个元素</p><p>3) void remove(): 删除集合里上一次next方法返回的元素</p><p><strong>iterator实现遍历:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个集合</span></span><br><span class="line">        Collection books = <span class="keyword">new</span> HashSet();</span><br><span class="line">        books.add(<span class="string">"轻量级Java EE应用"</span>);</span><br><span class="line">        books.add(<span class="string">"疯狂Java"</span>);</span><br><span class="line">        books.add(<span class="string">"疯狂Android"</span>);</span><br><span class="line">        <span class="comment">//获取books集合对应的迭代器</span></span><br><span class="line">        Iterator it = books.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//it.next()方法返回的数据类型是Object类型，</span></span><br><span class="line">            <span class="comment">//需要强制类型转换</span></span><br><span class="line">            String book = (String)it.next();</span><br><span class="line">            System.out.println(book);</span><br><span class="line">            <span class="keyword">if</span> (book.equals(<span class="string">"疯狂Java"</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//从集合中删除上一次next方法返回的元素                it.remove();</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//对book变量赋值，不会改变集合元素本身</span></span><br><span class="line">            book = <span class="string">"测试字符串"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(books);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码可以看出，iterator必须依附于Collection对象，若有一个iterator对象，必然有一个与之关联的Collection对象。</p><p>除了可以使用iterator接口迭代访问Collection集合里的元素之外，使用java5提供的foreach循环迭代访问集合元素更加便捷</p><p><strong>foreach实现遍历:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForeachTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个集合</span></span><br><span class="line">        Collection books = <span class="keyword">new</span> HashSet();</span><br><span class="line">        books.add(<span class="keyword">new</span> String(<span class="string">"轻量级Java EE应用"</span>));</span><br><span class="line">        books.add(<span class="keyword">new</span> String(<span class="string">"疯狂Java"</span>));</span><br><span class="line">        books.add(<span class="keyword">new</span> String(<span class="string">"疯狂Android"</span>));</span><br><span class="line">        <span class="keyword">for</span> (Object obj : books)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//此处的book变量也不是集合元素本身</span></span><br><span class="line">            String book = (String)obj;</span><br><span class="line">            System.out.println(book);</span><br><span class="line">            <span class="keyword">if</span> (book.equals(<span class="string">"疯狂Android"</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//下面代码会引发ConcurrentModificationException异常</span></span><br><span class="line">                <span class="comment">//books.remove(book);                  &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(books);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了Collection固有的iterator()方法，List还额外提供了一个listIterator()方法，该方法返回一个ListIterator对象，ListIterator接口继承了Iterator接口，提供了专门操作List的方法。ListIterator接口在Iterator接口的继承上增加了如下方法:</p><p>1) boolean hasPrevious(): 返回该迭代器关联的集合是否还有上一个元素</p><p>2) Object previous(): 返回该迭代器的上一个元素(向前迭代)</p><p>3) void add(): 在指定位置插入一个元素</p><p><strong>ListIterator实现遍历:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListIteratorTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String[] books = &#123;</span><br><span class="line">            <span class="string">"疯狂Java"</span>,</span><br><span class="line">            <span class="string">"轻量级Java EE应用"</span></span><br><span class="line">        &#125;;</span><br><span class="line">        List bookList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; books.length ; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            bookList.add(books[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ListIterator lit = bookList.listIterator();</span><br><span class="line">        <span class="keyword">while</span> (lit.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(lit.next());</span><br><span class="line">            lit.add(<span class="string">"-------分隔符-------"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"=======下面开始反向迭代======="</span>);</span><br><span class="line">        <span class="keyword">while</span>(lit.hasPrevious())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(lit.previous());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map实现"><a href="#Map实现" class="headerlink" title="Map实现"></a>Map实现</h3><h4 id="HashMap、Hashtable"><a href="#HashMap、Hashtable" class="headerlink" title="HashMap、Hashtable"></a>HashMap、Hashtable</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据count的值来判断两个对象是否相等。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj!=<span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            obj.getClass()==A<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        </span>&#123;</span><br><span class="line">            A a = (A)obj;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.count == a.count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据count来计算hashCode值。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//重写equals()方法，B对象与任何对象通过equals()方法比较都相等</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashtableTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Hashtable ht = <span class="keyword">new</span> Hashtable();</span><br><span class="line">        ht.put(<span class="keyword">new</span> A(<span class="number">60000</span>) , <span class="string">"疯狂Java"</span>);</span><br><span class="line">        ht.put(<span class="keyword">new</span> A(<span class="number">87563</span>) , <span class="string">"轻量级Java EE应用"</span>);</span><br><span class="line">        ht.put(<span class="keyword">new</span> A(<span class="number">1232</span>) , <span class="keyword">new</span> B());</span><br><span class="line">        System.out.println(ht);</span><br><span class="line">        <span class="comment">//只要两个对象通过equals比较返回true，</span></span><br><span class="line">        <span class="comment">//Hashtable就认为它们是相等的value。</span></span><br><span class="line">        <span class="comment">//由于Hashtable中有一个B对象，</span></span><br><span class="line">        <span class="comment">//它与任何对象通过equals比较都相等，所以下面输出true。</span></span><br><span class="line">        System.out.println(ht.containsValue(<span class="string">"测试字符串"</span>));  <span class="comment">//①</span></span><br><span class="line">        <span class="comment">//只要两个A对象的count相等，它们通过equals比较返回true，且hashCode相等</span></span><br><span class="line">        <span class="comment">//Hashtable即认为它们是相同的key，所以下面输出true。</span></span><br><span class="line">        System.out.println(ht.containsKey(<span class="keyword">new</span> A(<span class="number">87563</span>)));   <span class="comment">//②</span></span><br><span class="line">        <span class="comment">//下面语句可以删除最后一个key-value对</span></span><br><span class="line">        ht.remove(<span class="keyword">new</span> A(<span class="number">1232</span>));    <span class="comment">//③</span></span><br><span class="line">        <span class="comment">//通过返回Hashtable的所有key组成的Set集合，</span></span><br><span class="line">        <span class="comment">//从而遍历Hashtable每个key-value对</span></span><br><span class="line">        <span class="keyword">for</span> (Object key : ht.keySet())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(key + <span class="string">"----&gt;"</span>);</span><br><span class="line">            System.out.print(ht.get(key) + <span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用自定义类作为HashMap、Hashtable的key时，如果重写该类的equals(Object obj)和hashCode()方法，则应该保证两个方法的判断标准一致–当两个key通过equals()方法比较返回true时，两个key的hashCode()的返回值也应该相同</p><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMapTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LinkedHashMap scores = <span class="keyword">new</span> LinkedHashMap();</span><br><span class="line">        scores.put(<span class="string">"语文"</span> , <span class="number">80</span>);</span><br><span class="line">        scores.put(<span class="string">"英文"</span> , <span class="number">82</span>);</span><br><span class="line">        scores.put(<span class="string">"数学"</span> , <span class="number">76</span>);</span><br><span class="line">        <span class="comment">//遍历scores里的所有的key-value对</span></span><br><span class="line">        <span class="keyword">for</span> (Object key : scores.keySet())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(key + <span class="string">"------&gt;"</span> + scores.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">R</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">R</span><span class="params">(<span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"R[count:"</span> + count + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据count来判断两个对象是否相等。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj!=<span class="keyword">null</span></span><br><span class="line">            &amp;&amp; obj.getClass()==R<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        </span>&#123;</span><br><span class="line">            R r = (R)obj;</span><br><span class="line">            <span class="keyword">return</span> r.count == <span class="keyword">this</span>.count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据count属性值来判断两个对象的大小。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        R r = (R)obj;</span><br><span class="line">        <span class="keyword">return</span> count &gt; r.count ? <span class="number">1</span> :</span><br><span class="line">            count &lt; r.count ? -<span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMapTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TreeMap tm = <span class="keyword">new</span> TreeMap();</span><br><span class="line">        tm.put(<span class="keyword">new</span> R(<span class="number">3</span>) , <span class="string">"轻量级Java EE应用"</span>);</span><br><span class="line">        tm.put(<span class="keyword">new</span> R(-<span class="number">5</span>) , <span class="string">"疯狂Java"</span>);</span><br><span class="line">        tm.put(<span class="keyword">new</span> R(<span class="number">9</span>) , <span class="string">"疯狂Android"</span>);</span><br><span class="line">        System.out.println(tm);</span><br><span class="line">        <span class="comment">//返回该TreeMap的第一个Entry对象</span></span><br><span class="line">        System.out.println(tm.firstEntry());</span><br><span class="line">        <span class="comment">//返回该TreeMap的最后一个key值</span></span><br><span class="line">        System.out.println(tm.lastKey());</span><br><span class="line">        <span class="comment">//返回该TreeMap的比new R(2)大的最小key值。</span></span><br><span class="line">        System.out.println(tm.higherKey(<span class="keyword">new</span> R(<span class="number">2</span>)));</span><br><span class="line">        <span class="comment">//返回该TreeMap的比new R(2)小的最大的key-value对。</span></span><br><span class="line">        System.out.println(tm.lowerEntry(<span class="keyword">new</span> R(<span class="number">2</span>)));</span><br><span class="line">        <span class="comment">//返回该TreeMap的子TreeMap</span></span><br><span class="line">        System.out.println(tm.subMap(<span class="keyword">new</span> R(-<span class="number">1</span>) , <span class="keyword">new</span> R(<span class="number">4</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，类似于TreeSet中判断两个元素是否相等的标准，TreeMap中判断两个key相等的标准是:</p><p>1) 两个key通过compareTo()方法返回0</p><p>2) equals()放回true</p><p>我们在重写这两个方法的时候一定要保证它们的逻辑关系一致。</p><p>强调一下:</p><p>Set和Map的关系十分密切，java源码就是先实现了HashMap、TreeMap等集合，然后通过包装一个所有的value都为null的Map集合实现了Set集合类</p><p>以上就是Map集合类的编程应用场景。我们来梳理一下思路</p><p>1) HashMap和Hashtable的效率大致相同，因为它们的实现机制几乎完全一样。但HashMap通常比Hashtable要快一点，因为Hashtable需要额外的线程同步控制</p><p>2) TreeMap通常比HashMap、Hashtable要慢(尤其是在插入、删除key-value对时更慢)，因为TreeMap底层采用红黑树来管理key-value对</p><p>3) 使用TreeMap的一个好处就是： TreeMap中的key-value对总是处于有序状态，无须专门进行排序操作</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Set </tag>
            
            <tag> List </tag>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HotSpot的算法实现</title>
      <link href="/2019/10/15/HotSpot%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/10/15/HotSpot%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2019/10/15/HotSpot%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/1.jpg" alt=" "></p><h2 id="1-枚举根节点"><a href="#1-枚举根节点" class="headerlink" title="1.枚举根节点"></a>1.枚举根节点</h2><p>　　在可达性分析中，可以作为GC Roots的节点有很多，但是现在很多应用仅仅方法区就有上百MB，如果逐个检查的话，效率就会变得不可接受。</p><p>　　而且，可达性分析必须在一个一致性的快照中进行-即整个分析期间，系统就像冻结了一样。否则如果一边分析，系统一边动态表化，得到的结果就没有准确性。这就导致了系统GC时必须停顿所有的Java执行线程。</p><p>　　目前主流Java虚拟机使用的都是准确式GC，所以当执行系统都停顿下来之后，并不需要一个不漏的检查完所有执行上下文和全局的引用位置，虚拟机应该有办法直接知道哪些地方存放着对象引用。在HotSpot实现中，使用一组称为 OopMap 的数据结构来达到这个目的。OopMap会在类加载完成的时候，记录对象内什么偏移量上是什么类型的数据，在JTI编译过程中，也会在特定的位置记录下栈和寄存器哪些位置是引用。这样，在GC扫描的时候就可以直接得到这些信息了。</p><h2 id="2-安全点"><a href="#2-安全点" class="headerlink" title="2.安全点"></a>2.安全点</h2><p>　　如果OopMap内容变化的指令非常多，HotSpot并不会为每条指令都产生OopMap，只是在特定的位置记录了这些信息，这些位置成为“安全点”（SafePoint）。程序执行时只有在达到安全点的时候才停顿开始GC。一般具有较长运行时间的指令才能被选为安全点，如方法调用、循环跳转、异常跳转等。</p><p>　　接下来要考虑的便是，如何在GC时保证所有的线程都“跑”到安全点上停顿下来。这里有两种方案： 抢先式中断 （Preemptive Suspension） 和主动式中断 （Voluntary Suspension）。</p><p>　　抢先式中断会把所有线程中断，如果某个线程不在安全点上，就恢复线程让它跑到安全点上。几乎没有虚拟机采用这种方式。</p><p>　　主动式中断思想是需要中断线程时，不直接对线程操作，而是设置一个GC标志，各个线程会轮询这个标志并在需要时自己中断挂起。这样，轮询标志的地方和安全点是重合的。</p><h2 id="3-安全区域"><a href="#3-安全区域" class="headerlink" title="3.安全区域"></a>3.安全区域</h2><p>　　安全点机制保证程序执行时，在不太长的时间内就会遇到可进入GC的安全点，但是，程序“不执行”的时候呢，程序不执行就是没有分配CPU时间，这时线程无法响应JVM的中断请求，JVM显然不太可能的等待线程重新被分配CPU时间。</p><p>　　安全区域是指一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。</p><p>　　在线程执行到安全区域代码时，首先标识自己进入安全区域，当这段时间里JVM发起GC，不用管标识为安全区域的线程了。在线程要离开安全区域时，要检查系统是否已经完成了根节点枚举，如果完成，线程继续执行，否则等待直到收到可以安全离开安全区域的信号为止。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机（JVM）你只要看这一篇就够了！</title>
      <link href="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/"/>
      <url>/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/JVM.png" alt="JVM"></p><h2 id="1-Java-内存区域与内存溢出异常"><a href="#1-Java-内存区域与内存溢出异常" class="headerlink" title="1.Java 内存区域与内存溢出异常"></a>1.Java 内存区域与内存溢出异常</h2><h3 id="1-1-运行时数据区域"><a href="#1-1-运行时数据区域" class="headerlink" title="1.1 运行时数据区域"></a>1.1 运行时数据区域</h3><blockquote><p>根据《Java 虚拟机规范(Java SE 7 版)》规定，Java 虚拟机所管理的内存如下图所示。</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.jpg" alt="Java虚拟机运行时数据区"></p><h4 id="1-1-1-程序计数器"><a href="#1-1-1-程序计数器" class="headerlink" title="1.1.1 程序计数器"></a>1.1.1 程序计数器</h4><blockquote><p>内存空间小，线程私有。字节码解释器工作是就是通过改变这个计数器的值来选取下一条需要执行指令的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成</p></blockquote><p>如果线程正在执行一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器的值则为 (Undefined)。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</p><h4 id="1-1-2-Java-虚拟机栈"><a href="#1-1-2-Java-虚拟机栈" class="headerlink" title="1.1.2 Java 虚拟机栈"></a>1.1.2 Java 虚拟机栈</h4><blockquote><p>线程私有，生命周期和线程一致。描述的是 Java 方法执行的内存模型：每个方法在执行时都会床创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。</p></blockquote><p>局部变量表：存放了编译期可知的各种基本类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference 类型)和 returnAddress 类型(指向了一条字节码指令的地址)</p><p>StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度。<br>OutOfMemoryError：如果虚拟机栈可以动态扩展，而扩展时无法申请到足够的内存。</p><h4 id="1-1-3-本地方法栈"><a href="#1-1-3-本地方法栈" class="headerlink" title="1.1.3 本地方法栈"></a>1.1.3 本地方法栈</h4><blockquote><p>区别于 Java 虚拟机栈的是，Java 虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。也会有 StackOverflowError 和 OutOfMemoryError 异常。</p></blockquote><h4 id="1-1-4-Java-堆"><a href="#1-1-4-Java-堆" class="headerlink" title="1.1.4 Java 堆"></a>1.1.4 Java 堆</h4><blockquote><p>对于绝大多数应用来说，这块区域是 JVM 所管理的内存中最大的一块。线程共享，主要是存放对象实例和数组。内部会划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)。可以位于物理上不连续的空间，但是逻辑上要连续。</p></blockquote><p>OutOfMemoryError：如果堆中没有内存完成实例分配，并且堆也无法再扩展时，抛出该异常。</p><h4 id="1-1-5-方法区"><a href="#1-1-5-方法区" class="headerlink" title="1.1.5 方法区"></a>1.1.5 方法区</h4><blockquote><p>属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p></blockquote><h4 id="1-1-6-运行时常量池"><a href="#1-1-6-运行时常量池" class="headerlink" title="1.1.6 运行时常量池"></a>1.1.6 运行时常量池</h4><blockquote><p>属于方法区一部分，用于存放编译期生成的各种字面量和符号引用。编译器和运行期(String 的 intern() )都可以将常量放入池中。内存有限，无法申请时抛出 OutOfMemoryError。</p></blockquote><h4 id="1-1-7-直接内存"><a href="#1-1-7-直接内存" class="headerlink" title="1.1.7 直接内存"></a>1.1.7 直接内存</h4><blockquote><p>非虚拟机运行时数据区的部分</p></blockquote><p>在 JDK 1.4 中新加入 NIO (New Input/Output) 类，引入了一种基于通道(Channel)和缓存(Buffer)的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。可以避免在 Java 堆和 Native 堆中来回的数据耗时操作。<br>OutOfMemoryError：会受到本机内存限制，如果内存区域总和大于物理内存限制从而导致动态扩展时出现该异常。</p><h3 id="1-2-HotSpot-虚拟机对象探秘"><a href="#1-2-HotSpot-虚拟机对象探秘" class="headerlink" title="1.2 HotSpot 虚拟机对象探秘"></a>1.2 HotSpot 虚拟机对象探秘</h3><blockquote><p>主要介绍数据是如何创建、如何布局以及如何访问的。</p></blockquote><h4 id="1-2-1-对象的创建"><a href="#1-2-1-对象的创建" class="headerlink" title="1.2.1 对象的创建"></a>1.2.1 对象的创建</h4><p>遇到 new 指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，执行相应的类加载。</p><p>类加载检查通过之后，为新对象分配内存(内存大小在类加载完成后便可确认)。在堆的空闲内存中划分一块区域(‘指针碰撞-内存规整’或‘空闲列表-内存交错’的分配方式)。</p><p>前面讲的每个线程在堆中都会有私有的分配缓冲区(TLAB)，这样可以很大程度避免在并发情况下频繁创建对象造成的线程不安全。</p><p>内存空间分配完成后会初始化为 0(不包括对象头)，接下来就是填充对象头，把对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息存入对象头。</p><p>执行 new 指令后执行 init 方法后才算一份真正可用的对象创建完成。</p><h4 id="1-2-2-对象的内存布局"><a href="#1-2-2-对象的内存布局" class="headerlink" title="1.2.2 对象的内存布局"></a>1.2.2 对象的内存布局</h4><blockquote><p>在 HotSpot 虚拟机中，分为 3 块区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)</p></blockquote><p>对象头(Header)：包含两部分，第一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，32 位虚拟机占 32 bit，64 位虚拟机占 64 bit。官方称为 ‘Mark Word’。第二部分是类型指针，即对象指向它的类的元数据指针，虚拟机通过这个指针确定这个对象是哪个类的实例。另外，如果是 Java 数组，对象头中还必须有一块用于记录数组长度的数据，因为普通对象可以通过 Java 对象元数据确定大小，而数组对象不可以。</p><p>实例数据(Instance Data)：程序代码中所定义的各种类型的字段内容(包含父类继承下来的和子类中定义的)。</p><p>对齐填充(Padding)：不是必然需要，主要是占位，保证对象大小是某个字节的整数倍。</p><h4 id="1-2-3-对象的访问定位"><a href="#1-2-3-对象的访问定位" class="headerlink" title="1.2.3 对象的访问定位"></a>1.2.3 对象的访问定位</h4><blockquote><p>使用对象时，通过栈上的 reference 数据来操作堆上的具体对象。</p></blockquote><p>通过句柄访问</p><blockquote><p>Java 堆中会分配一块内存作为句柄池。reference 存储的是句柄地址。详情见图。</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.jpg" alt="通过句柄访问对象"></p><p>使用直接指针访问</p><blockquote><p>reference 中直接存储对象地址</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/%E9%80%9A%E8%BF%87%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.jpg" alt="通过直接指针访问对象"></p><p>比较：使用句柄的最大好处是 reference 中存储的是稳定的句柄地址，在对象移动(GC)是只改变实例数据指针地址，reference 自身不需要修改。直接指针访问的最大好处是速度快，节省了一次指针定位的时间开销。如果是对象频繁 GC 那么句柄方法好，如果是对象频繁访问则直接指针访问好。</p><h2 id="2-垃圾回收器与内存分配策略"><a href="#2-垃圾回收器与内存分配策略" class="headerlink" title="2. 垃圾回收器与内存分配策略"></a>2. 垃圾回收器与内存分配策略</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><blockquote><p>程序计数器、虚拟机栈、本地方法栈 3 个区域随线程生灭(因为是线程私有)，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。而 Java 堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期才知道那些对象会创建，这部分内存的分配和回收都是动态的，垃圾回收期所关注的就是这部分内存。</p></blockquote><h3 id="2-2-对象已死吗"><a href="#2-2-对象已死吗" class="headerlink" title="2.2 对象已死吗"></a>2.2 对象已死吗</h3><blockquote><p>在进行内存回收之前要做的事情就是判断那些对象是‘死’的，哪些是‘活’的。</p></blockquote><h4 id="2-2-1-引用计数法"><a href="#2-2-1-引用计数法" class="headerlink" title="2.2.1 引用计数法"></a>2.2.1 引用计数法</h4><blockquote><p>给对象添加一个引用计数器。但是难以解决循环引用问题。</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/java%E5%A0%86%E6%A0%88%E5%BC%95%E7%94%A8.jpg" alt="java堆栈引用"></p><p>从图中可以看出，如果不下小心直接把 Obj1-reference 和 Obj2-reference 置 null。则在 Java 堆当中的两块内存依然保持着互相引用无法回收。</p><h4 id="2-2-2-可达性分析法"><a href="#2-2-2-可达性分析法" class="headerlink" title="2.2.2 可达性分析法"></a>2.2.2 可达性分析法</h4><blockquote><p>通过一系列的 ‘GC Roots’ 的对象作为起始点，从这些节点出发所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连的时候说明对象不可用。</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E6%B3%95.jpg" alt="可达性分析"></p><p>可作为 GC Roots 的对象：</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI(即一般说的 Native 方法) 引用的对象</li></ul><h4 id="2-2-3-引用"><a href="#2-2-3-引用" class="headerlink" title="2.2.3 引用"></a>2.2.3 引用</h4><blockquote><p>前面的两种方式判断存活时都与‘引用’有关。但是 JDK 1.2 之后，引用概念进行了扩充</p></blockquote><p>种引用强度一次逐渐减弱</p><p>强引用</p><blockquote><p>类似于 Object obj = new Object(); 创建的，只要强引用在就不回收。</p></blockquote><p>软引用</p><blockquote><p>SoftReference 类实现软引用。在系统要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。</p></blockquote><p>弱引用</p><blockquote><p>WeakReference 类实现弱引用。对象只能生存到下一次垃圾收集之前。在垃圾收集器工作时，无论内存是否足够都会回收掉只被弱引用关联的对象。</p></blockquote><p>虚引用</p><blockquote><p>PhantomReference 类实现虚引用。无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</p></blockquote><h4 id="2-2-4-生存还是死亡"><a href="#2-2-4-生存还是死亡" class="headerlink" title="2.2.4 生存还是死亡"></a>2.2.4 生存还是死亡</h4><p>即使在可达性分析算法中不可达的对象，也并非是“facebook”的，这时候它们暂时出于“缓刑”阶段，一个对象的真正死亡至少要经历两次标记过程：如果对象在进行中可达性分析后发现没有与 GC Roots 相连接的引用链，那他将会被第一次标记并且进行一次筛选，筛选条件是此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p><p>如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象竟会放置在一个叫做 F-Queue 的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。这里所谓的“执行”是指虚拟机会出发这个方法，并不承诺或等待他运行结束。finalize() 方法是对象逃脱死亡命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记，如果对象要在 finalize() 中成功拯救自己 —— 只要重新与引用链上的任何一个对象简历关联即可。</p><p>finalize() 方法只会被系统自动调用一次。</p><h4 id="2-2-5-回收方法区"><a href="#2-2-5-回收方法区" class="headerlink" title="2.2.5 回收方法区"></a>2.2.5 回收方法区</h4><blockquote><p>在堆中，尤其是在新生代中，一次垃圾回收一般可以回收 70% ~ 95% 的空间，而永久代的垃圾收集效率远低于此。<br>永久代垃圾回收主要两部分内容：废弃的常量和无用的类。</p></blockquote><p>判断废弃常量：一般是判断没有该常量的引用。</p><p>判断无用的类：要以下三个条件都满足</p><ul><li>该类所有的实例都已经回收，也就是 Java 堆中不存在该类的任何实例</li><li>加载该类的 ClassLoader 已经被回收</li><li>该类对应的 java.lang.Class 对象没有任何地方呗引用，无法在任何地方通过反射访问该类的方法</li></ul><h3 id="2-3-垃圾回收算法"><a href="#2-3-垃圾回收算法" class="headerlink" title="2.3 垃圾回收算法"></a>2.3 垃圾回收算法</h3><h4 id="2-3-1-标记-——-清除算法"><a href="#2-3-1-标记-——-清除算法" class="headerlink" title="2.3.1 标记 —— 清除算法"></a>2.3.1 标记 —— 清除算法</h4><blockquote><p>直接标记清除就可。</p></blockquote><p>两个不足：</p><ul><li>效率不高</li><li>空间会产生大量碎片</li></ul><h4 id="2-3-2-复制算法"><a href="#2-3-2-复制算法" class="headerlink" title="2.3.2 复制算法"></a>2.3.2 复制算法</h4><blockquote><p>把空间分成两块，每次只对其中一块进行 GC。当这块内存使用完时，就将还存活的对象复制到另一块上面。</p></blockquote><p>解决前一种方法的不足，但是会造成空间利用率低下。因为大多数新生代对象都不会熬过第一次 GC。所以没必要 1 : 1 划分空间。可以分一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另一块 Survivor 上，最后清理 Eden 和 Survivor 空间。大小比例一般是 8 : 1 : 1，每次浪费 10% 的 Survivor 空间。但是这里有一个问题就是如果存活的大于 10% 怎么办？这里采用一种分配担保策略：多出来的对象直接进入老年代。</p><h4 id="2-3-3-标记-整理算法"><a href="#2-3-3-标记-整理算法" class="headerlink" title="2.3.3 标记-整理算法"></a>2.3.3 标记-整理算法</h4><blockquote><p>不同于针对新生代的复制算法，针对老年代的特点，创建该算法。主要是把存活对象移到内存的一端。</p></blockquote><h4 id="2-3-4-分代回收"><a href="#2-3-4-分代回收" class="headerlink" title="2.3.4 分代回收"></a>2.3.4 分代回收</h4><blockquote><p>根据存活对象划分几块内存区，一般是分为新生代和老年代。然后根据各个年代的特点制定相应的回收算法。</p></blockquote><ul><li>新生代</li></ul><blockquote><p>每次垃圾回收都有大量对象死去，只有少量存活，选用复制算法比较合理。</p></blockquote><ul><li>老年代</li></ul><blockquote><p>老年代中对象存活率较高、没有额外的空间分配对它进行担保。所以必须使用 标记 —— 清除 或者 标记 —— 整理 算法回收。</p></blockquote><h3 id="2-4-HotSpot-的算法实现"><a href="#2-4-HotSpot-的算法实现" class="headerlink" title="2.4 HotSpot 的算法实现"></a>2.4 HotSpot 的算法实现</h3><p><a href="http://www.theoak.online/2019/10/15/HotSpot%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">HotSpot的算法实现</a></p><h3 id="2-5-垃圾回收器"><a href="#2-5-垃圾回收器" class="headerlink" title="2.5 垃圾回收器"></a>2.5 垃圾回收器</h3><blockquote><p>收集算法是内存回收的理论，而垃圾回收器是内存回收的实践。</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="HotSpot虚拟机的垃圾收集器"></p><p><strong>说明：</strong> 如果两个收集器之间存在连线说明他们之间可以搭配使用。</p><h4 id="2-5-1-Serial-收集器"><a href="#2-5-1-Serial-收集器" class="headerlink" title="2.5.1 Serial 收集器"></a>2.5.1 Serial 收集器</h4><blockquote><p>这是一个单线程收集器。意味着它只会使用一个 CPU 或一条收集线程去完成收集工作，并且在进行垃圾回收时必须暂停其它所有的工作线程直到收集结束。</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/Serial&SerialOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="Serial&amp;SerialOld收集器运行示意图"></p><h4 id="2-5-2-ParNew-收集器"><a href="#2-5-2-ParNew-收集器" class="headerlink" title="2.5.2 ParNew 收集器"></a>2.5.2 ParNew 收集器</h4><blockquote><p>可以认为是 Serial 收集器的多线程版本。</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/ParNew%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="ParNew收集器运行示意图"></p><p>并行：Parallel</p><blockquote><p>指多条垃圾收集线程并行工作，此时用户线程处于等待状态</p></blockquote><p>并发：Concurrent</p><blockquote><p>指用户线程和垃圾回收线程同时执行(不一定是并行，有可能是交叉执行)，用户进程在运行，而垃圾回收线程在另一个 CPU 上运行。</p></blockquote><h4 id="2-5-3-Parallel-Scavenge-收集器"><a href="#2-5-3-Parallel-Scavenge-收集器" class="headerlink" title="2.5.3 Parallel Scavenge 收集器"></a>2.5.3 Parallel Scavenge 收集器</h4><blockquote><p>这是一个新生代收集器，也是使用复制算法实现，同时也是并行的多线程收集器。</p></blockquote><p>CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程所停顿的时间，而 Parallel Scavenge 收集器的目的是达到一个可控制的吞吐量(Throughput = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间))。</p><p>作为一个吞吐量优先的收集器，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整停顿时间。这就是 GC 的自适应调整策略(GC Ergonomics)。</p><h4 id="2-5-4-Serial-Old-收集器"><a href="#2-5-4-Serial-Old-收集器" class="headerlink" title="2.5.4 Serial Old 收集器"></a>2.5.4 Serial Old 收集器</h4><blockquote><p>收集器的老年代版本，单线程，使用 标记 —— 整理。</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/Serial&SerialOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="SerialOld收集器运行示意图"></p><h4 id="2-5-5-Parallel-Old-收集器"><a href="#2-5-5-Parallel-Old-收集器" class="headerlink" title="2.5.5 Parallel Old 收集器"></a>2.5.5 Parallel Old 收集器</h4><blockquote><p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本。多线程，使用 标记 —— 整理</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/ParallelOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="ParallelOld收集器运行示意图"></p><h4 id="2-5-6-CMS-收集器"><a href="#2-5-6-CMS-收集器" class="headerlink" title="2.5.6 CMS 收集器"></a>2.5.6 CMS 收集器</h4><blockquote><p>CMS (Concurrent Mark Sweep) 收集器是一种以获取最短回收停顿时间为目标的收集器。基于 标记 —— 清除 算法实现。</p></blockquote><p>运作步骤:</p><ul><li>初始标记(CMS initial mark)：标记 GC Roots 能直接关联到的对象</li><li>并发标记(CMS concurrent mark)：进行 GC Roots Tracing</li><li>重新标记(CMS remark)：修正并发标记期间的变动部分</li><li>并发清除(CMS concurrent sweep)</li></ul><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/ConcurrentMarkSweep%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="ConcurrentMarkSweep收集器运行示意图"></p><p>缺点：对 CPU 资源敏感、无法收集浮动垃圾、标记 —— 清除 算法带来的空间碎片</p><h4 id="2-5-7-G1-收集器"><a href="#2-5-7-G1-收集器" class="headerlink" title="2.5.7 G1 收集器"></a>2.5.7 G1 收集器</h4><blockquote><p>面向服务端的垃圾回收器。</p></blockquote><p>优点：并行与并发、分代收集、空间整合、可预测停顿。</p><p>运作步骤:</p><ul><li>初始标记(Initial Marking)</li><li>并发标记(Concurrent Marking)</li><li>最终标记(Final Marking)</li><li>筛选回收(Live Data Counting and Evacuation)</li></ul><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/G1%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="G1收集器运行示意图"></p><h3 id="2-6-内存分配与回收策略"><a href="#2-6-内存分配与回收策略" class="headerlink" title="2.6 内存分配与回收策略"></a>2.6 内存分配与回收策略</h3><h4 id="2-6-1-对象优先在-Eden-分配"><a href="#2-6-1-对象优先在-Eden-分配" class="headerlink" title="2.6.1 对象优先在 Eden 分配"></a>2.6.1 对象优先在 Eden 分配</h4><blockquote><p>对象主要分配在新生代的 Eden 区上，如果启动了本地线程分配缓冲区，将线程优先在 (TLAB) 上分配。少数情况会直接分配在老年代中。</p></blockquote><p>一般来说 Java 堆的内存模型如下图所示：</p><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/java%E5%A0%86%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.jpg" alt="java堆的内存模型"></p><p>新生代 GC (Minor GC)</p><blockquote><p>发生在新生代的垃圾回收动作，频繁，速度快。</p></blockquote><p>老年代 GC (Major GC / Full GC)</p><blockquote><p>发生在老年代的垃圾回收动作，出现了 Major GC 经常会伴随至少一次 Minor GC(非绝对)。Major GC 的速度一般会比 Minor GC 慢十倍以上。</p></blockquote><h4 id="2-6-2-大对象直接进入老年代"><a href="#2-6-2-大对象直接进入老年代" class="headerlink" title="2.6.2 大对象直接进入老年代"></a>2.6.2 大对象直接进入老年代</h4><h4 id="2-6-3-长期存活的对象将进入老年代"><a href="#2-6-3-长期存活的对象将进入老年代" class="headerlink" title="2.6.3 长期存活的对象将进入老年代"></a>2.6.3 长期存活的对象将进入老年代</h4><h4 id="2-6-4-动态对象年龄判定"><a href="#2-6-4-动态对象年龄判定" class="headerlink" title="2.6.4 动态对象年龄判定"></a>2.6.4 动态对象年龄判定</h4><h4 id="2-6-5-空间分配担保"><a href="#2-6-5-空间分配担保" class="headerlink" title="2.6.5 空间分配担保"></a>2.6.5 空间分配担保</h4><h2 id="3-Java-内存模型与线程"><a href="#3-Java-内存模型与线程" class="headerlink" title="3. Java 内存模型与线程"></a>3. Java 内存模型与线程</h2><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/%E5%A4%84%E7%90%86%E5%99%A8%E3%80%81%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E3%80%81%E4%B8%BB%E5%86%85%E5%AD%98%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB.jpg" alt="处理器、高速缓存、主内存间的交互关系"></p><h3 id="3-1-Java-内存模型"><a href="#3-1-Java-内存模型" class="headerlink" title="3.1 Java 内存模型"></a>3.1 Java 内存模型</h3><h4 id="3-1-1-主内存和工作内存之间的交互"><a href="#3-1-1-主内存和工作内存之间的交互" class="headerlink" title="3.1.1 主内存和工作内存之间的交互"></a>3.1.1 主内存和工作内存之间的交互</h4><table><thead><tr><th align="center">操作</th><th align="center">作用对象</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">lock</td><td align="center">主内存</td><td align="center">把一个变量标识为一条线程独占的状态</td></tr><tr><td align="center">unlock</td><td align="center">主内存</td><td align="center">把一个处于锁定状态的变量释放出来，释放后才可被其他线程锁定</td></tr><tr><td align="center">read</td><td align="center">主内存</td><td align="center">把一个变量的值从主内存传输到线程工作内存中，以便 load 操作使用</td></tr><tr><td align="center">load</td><td align="center">工作内存</td><td align="center">把 read 操作从主内存中得到的变量值放入工作内存中</td></tr><tr><td align="center">use</td><td align="center">工作内存</td><td align="center">把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量值的字节码指令时将会执行这个操作</td></tr><tr><td align="center">assign</td><td align="center">工作内存</td><td align="center">把一个从执行引擎接收到的值赋接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</td></tr><tr><td align="center">store</td><td align="center">工作内存</td><td align="center">把工作内存中的一个变量的值传送到主内存中，以便 write 操作</td></tr><tr><td align="center">write</td><td align="center">工作内存</td><td align="center">把 store 操作从工作内存中得到的变量的值放入主内存的变量中</td></tr></tbody></table><h4 id="3-1-2-对于-volatile-型变量的特殊规则"><a href="#3-1-2-对于-volatile-型变量的特殊规则" class="headerlink" title="3.1.2 对于 volatile 型变量的特殊规则"></a>3.1.2 对于 volatile 型变量的特殊规则</h4><blockquote><p>关键字 volatile 是 Java 虚拟机提供的最轻量级的同步机制。</p></blockquote><p>一个变量被定义为 volatile 的特性：</p><p>保证此变量对所有线程的可见性。但是操作并非原子操作，并发情况下不安全。</p><blockquote><p>果不符合 运算结果并不依赖变量当前值，或者能够确保只有单一的线程修改变量的值 和 变量不需要与其他的状态变量共同参与不变约束 就要通过加锁(使用 synchronize 或 java.util.concurrent 中的原子类)来保证原子性。</p></blockquote><p>禁止指令重排序优化。</p><blockquote><p>通过插入内存屏障保证一致性。</p></blockquote><h4 id="3-1-3-对于-long-和-double-型变量的特殊规则"><a href="#3-1-3-对于-long-和-double-型变量的特殊规则" class="headerlink" title="3.1.3 对于 long 和 double 型变量的特殊规则"></a>3.1.3 对于 long 和 double 型变量的特殊规则</h4><blockquote><p>Java 要求对于主内存和工作内存之间的八个操作都是原子性的，但是对于 64 位的数据类型，有一条宽松的规定：允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虚拟机实现选择可以不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性。这就是 long 和 double 的非原子性协定。</p></blockquote><h4 id="3-1-4-原子性、可见性与有序性"><a href="#3-1-4-原子性、可见性与有序性" class="headerlink" title="3.1.4 原子性、可见性与有序性"></a>3.1.4 原子性、可见性与有序性</h4><ul><li>原子性(Atomicity)</li></ul><blockquote><p>由 Java 内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store 和 write。大致可以认为基本数据类型的操作是原子性的。同时 lock 和 unlock 可以保证更大范围操作的原子性。而 synchronize 同步块操作的原子性是用更高层次的字节码指令 monitorenter 和 monitorexit 来隐式操作的。</p></blockquote><ul><li>可见性(Visibility)</li></ul><blockquote><p>是指当一个线程修改了共享变量的值，其他线程也能够立即得知这个通知。主要操作细节就是修改值后将值同步至主内存(volatile 值使用前都会从主内存刷新)，除了 volatile 还有 synchronize 和 final 可以保证可见性。同步块的可见性是由“对一个变量执行 unlock 操作之前，必须先把此变量同步会主内存中( store、write 操作)”这条规则获得。而 final 可见性是指：被 final 修饰的字段在构造器中一旦完成，并且构造器没有把 “this” 的引用传递出去( this 引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象)，那在其他线程中就能看见 final 字段的值。</p></blockquote><ul><li>有序性(Ordering)</li></ul><blockquote><p>如果在被线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。前半句指“线程内表现为串行的语义”，后半句是指“指令重排”现象和“工作内存与主内存同步延迟”现象。Java 语言通过 volatile 和 synchronize 两个关键字来保证线程之间操作的有序性。volatile 自身就禁止指令重排，而 synchronize 则是由“一个变量在同一时刻指允许一条线程对其进行 lock 操作”这条规则获得，这条规则决定了持有同一个锁的两个同步块只能串行的进入。</p></blockquote><h4 id="3-1-5-先行发生原则"><a href="#3-1-5-先行发生原则" class="headerlink" title="3.1.5 先行发生原则"></a>3.1.5 先行发生原则</h4><blockquote><p>也就是 happens-before 原则。这个原则是判断数据是否存在竞争、线程是否安全的主要依据。先行发生是 Java 内存模型中定义的两项操作之间的偏序关系。</p></blockquote><p>天然的先行发生关系</p><table><thead><tr><th align="center">规则</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">程序次序规则</td><td align="center">在一个线程内，代码按照书写的控制流顺序执行</td></tr><tr><td align="center">管程锁定规则</td><td align="center">一个 unlock 操作先行发生于后面对同一个锁的 lock 操作</td></tr><tr><td align="center">volatile 变量规则</td><td align="center">volatile 变量的写操作先行发生于后面对这个变量的读操作</td></tr><tr><td align="center">线程启动规则</td><td align="center">Thread 对象的 start() 方法先行发生于此线程的每一个动作线程终止规则</td></tr><tr><td align="center">线程中断规则</td><td align="center">对线程 interrupt() 方法调用优先发生于被中断线程的代码检测到中断事件的发生(通过 Thread.interrupted() 方法检测)</td></tr><tr><td align="center">对象终结规则</td><td align="center">一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始</td></tr><tr><td align="center">传递性</td><td align="center">如果操作 A 先于 操作 B 发生，操作 B 先于 操作 C 发生，那么操作 A 先于 操作 C</td></tr></tbody></table><h3 id="3-2-Java-与线程"><a href="#3-2-Java-与线程" class="headerlink" title="3.2 Java 与线程"></a>3.2 Java 与线程</h3><h4 id="3-2-1-线程的实现"><a href="#3-2-1-线程的实现" class="headerlink" title="3.2.1 线程的实现"></a>3.2.1 线程的实现</h4><p>使用内核线程实现</p><blockquote><p>直接由操作系统内核支持的线程，这种线程由内核完成切换。程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口 —— 轻量级进程(LWP)，轻量级进程就是我们通常意义上所讲的线程，每个轻量级进程都有一个内核级线程支持。</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0.jpg" alt="内核线程实现"></p><p>使用用户线程实现</p><blockquote><p>广义上来说，只要不是内核线程就可以认为是用户线程，因此可以认为轻量级进程也属于用户线程。狭义上说是完全建立在用户空间的线程库上的并且内核系统不可感知的。</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0.jpg" alt="用户线程实现"></p><p>使用用户线程夹加轻量级进程混合实现</p><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/%E6%B7%B7%E5%90%88%E5%AE%9E%E7%8E%B0.jpg" alt="混合实现"></p><p>Java 线程实现</p><blockquote><p>平台不同实现方式不同，可以认为是一条 Java 线程映射到一条轻量级进程。</p></blockquote><h4 id="3-2-2-Java-线程调度"><a href="#3-2-2-Java-线程调度" class="headerlink" title="3.2.2 Java 线程调度"></a>3.2.2 Java 线程调度</h4><p>协同式线程调度</p><blockquote><p>线程执行时间由线程自身控制，实现简单，切换线程自己可知，所以基本没有线程同步问题。坏处是执行时间不可控，容易阻塞。</p></blockquote><p>抢占式线程调度</p><blockquote><p>每个线程由系统来分配执行时间。</p></blockquote><h4 id="3-2-3-状态转换"><a href="#3-2-3-状态转换" class="headerlink" title="3.2.3 状态转换"></a>3.2.3 状态转换</h4><p>五种状态：</p><ul><li>新建(new)</li></ul><blockquote><p>创建后尚未启动的线程。</p></blockquote><ul><li>运行(Runable)</li></ul><blockquote><p>Runable 包括了操作系统线程状态中的 Running 和 Ready，也就是出于此状态的线程有可能正在执行，也有可能正在等待 CPU 为他分配时间。</p></blockquote><ul><li>无限期等待(Waiting)</li></ul><blockquote><p>出于这种状态的线程不会被 CPU 分配时间，它们要等其他线程显示的唤醒。</p></blockquote><p>以下方法会然线程进入无限期等待状态：<br>没有设置 Timeout 参数的 Object.wait() 方法。<br>没有设置 Timeout 参数的 Thread.join() 方法。<br>LookSupport.park() 方法。</p><ul><li>限期等待(Timed Waiting)</li></ul><blockquote><p>处于这种状态的线程也不会分配时间，不过无需等待配其他线程显示地唤醒，在一定时间后他们会由系统自动唤醒。</p></blockquote><p>以下方法会让线程进入限期等待状态：<br>Thread.sleep() 方法。<br>设置了 Timeout 参数的 Object.wait() 方法。<br>设置了 Timeout 参数的 Thread.join() 方法。<br>LockSupport.parkNanos() 方法。<br>LockSupport.parkUntil() 方法。</p><ul><li>阻塞(Blocked)</li></ul><blockquote><p>线程被阻塞了，“阻塞状态”和“等待状态”的区别是：“阻塞状态”在等待着获取一个排他锁，这个时间将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。</p></blockquote><ul><li>结束(Terminated)</li></ul><blockquote><p>已终止线程的线程状态。</p></blockquote><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.jpg" alt="线程状态转换图"></p><h2 id="4-虚拟机类加载机制"><a href="#4-虚拟机类加载机制" class="headerlink" title="4. 虚拟机类加载机制"></a>4. 虚拟机类加载机制</h2><blockquote><p>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、装换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。</p></blockquote><p>在 Java 语言中，类型的加载、连接和初始化过程都是在程序运行期间完成的。</p><h3 id="4-1-类加载时机"><a href="#4-1-类加载时机" class="headerlink" title="4.1 类加载时机"></a>4.1 类加载时机</h3><p>类的生命周期( 7 个阶段)</p><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E6%97%B6%E6%9C%9F.jpg" alt="类的生命时期"></p><p>其中加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的。解析阶段可以在初始化之后再开始(运行时绑定或动态绑定或晚期绑定)。</p><p>以下五种情况必须对类进行初始化(而加载、验证、准备自然需要在此之前完成)：</p><ul><li>遇到 new、getstatic、putstatic 或 invokestatic 这 4 条字节码指令时没初始化触发初始化。使用场景：使用 new 关键字实例化对象、读取一个类的静态字段(被 final 修饰、已在编译期把结果放入常量池的静态字段除外)、调用一个类的静态方法。</li><li>使用 java.lang.reflect 包的方法对类进行反射调用的时候。</li><li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需先触发其父类的初始化。</li><li>当虚拟机启动时，用户需指定一个要加载的主类(包含 main() 方法的那个类)，虚拟机会先初始化这个主类。</li><li>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需先触发其初始化。</li></ul><p>举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SuperClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">1127</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"ConstClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD = <span class="string">"hello world!"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  output : SuperClass init!</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 通过子类引用父类的静态对象不会导致子类的初始化</span></span><br><span class="line"><span class="comment">         * 只有直接定义这个字段的类才会被初始化</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  output :</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 通过数组定义来引用类不会触发此类的初始化</span></span><br><span class="line"><span class="comment">         * 虚拟机在运行时动态创建了一个数组类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(ConstClass.HELLOWORLD);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  output :</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 常量在编译阶段会存入调用类的常量池当中，本质上并没有直接引用到定义类常量的类，</span></span><br><span class="line"><span class="comment">         * 因此不会触发定义常量的类的初始化。</span></span><br><span class="line"><span class="comment">         * “hello world” 在编译期常量传播优化时已经存储到 NotInitialization 常量池中了。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-类的加载过程"><a href="#4-2-类的加载过程" class="headerlink" title="4.2 类的加载过程"></a>4.2 类的加载过程</h3><h4 id="4-2-1-加载"><a href="#4-2-1-加载" class="headerlink" title="4.2.1 加载"></a>4.2.1 加载</h4><ul><li>通过一个类的全限定名来获取定义次类的二进制流(ZIP 包、网络、运算生成、JSP 生成、数据库读取)。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法去这个类的各种数据的访问入口。</li></ul><p>数组类的特殊性：数组类本身不通过类加载器创建，它是由 Java 虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型最终是要靠类加载器去创建的，数组创建过程如下：</p><ul><li>如果数组的组件类型是引用类型，那就递归采用类加载加载。</li><li>如果数组的组件类型不是引用类型，Java 虚拟机会把数组标记为引导类加载器关联。</li><li>数组类的可见性与他的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为 public。</li></ul><p>内存中实例的 java.lang.Class 对象存在方法区中。作为程序访问方法区中这些类型数据的外部接口。<br>加载阶段与连接阶段的部分内容是交叉进行的，但是开始时间保持先后顺序。</p><h4 id="4-2-2-验证"><a href="#4-2-2-验证" class="headerlink" title="4.2.2 验证"></a>4.2.2 验证</h4><blockquote><p>是连接的第一步，确保 Class 文件的字节流中包含的信息符合当前虚拟机要求。</p></blockquote><p>文件格式验证</p><ul><li>是否以魔数 0xCAFEBABE 开头</li><li>主、次版本号是否在当前虚拟机处理范围之内</li><li>常量池的常量是否有不被支持常量的类型（检查常量 tag 标志）</li><li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量</li><li>CONSTANT_Utf8_info 型的常量中是否有不符合 UTF8 编码的数据</li><li>Class 文件中各个部分集文件本身是否有被删除的附加的其他信息</li></ul><p>只有通过这个阶段的验证后，字节流才会进入内存的方法区进行存储，所以后面 3 个验证阶段全部是基于方法区的存储结构进行的，不再直接操作字节流。</p><p>元数据验证</p><ul><li>这个类是否有父类（除 java.lang.Object 之外）</li><li>这个类的父类是否继承了不允许被继承的类（final 修饰的类）</li><li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法</li><li>类中的字段、方法是否与父类产生矛盾（覆盖父类 final 字段、出现不符合规范的重载）</li></ul><p>这一阶段主要是对类的元数据信息进行语义校验，保证不存在不符合 Java 语言规范的元数据信息。</p><p>字节码验证</p><ul><li>保证任意时刻操作数栈的数据类型与指令代码序列都配合工作（不会出现按照 long 类型读一个 int 型数据）</li><li>保证跳转指令不会跳转到方法体以外的字节码指令上</li><li>保证方法体中的类型转换是有效的（子类对象赋值给父类数据类型是安全的，反过来不合法的）</li></ul><p>这是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。这个阶段对类的方法体进行校验分析，保证校验类的方法在运行时不会做出危害虚拟机安全的事件。</p><p>符号引用验证</p><ul><li>符号引用中通过字符创描述的全限定名是否能找到对应的类</li><li>在指定类中是否存在符方法的字段描述符以及简单名称所描述的方法和字段</li><li>符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问</li></ul><p>最后一个阶段的校验发生在迅疾将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，还有以上提及的内容。<br>符号引用的目的是确保解析动作能正常执行，如果无法通过符号引用验证将抛出一个 java.lang.IncompatibleClass.ChangeError 异常的子类。如 java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError 等。</p><h4 id="4-2-3-准备"><a href="#4-2-3-准备" class="headerlink" title="4.2.3 准备"></a>4.2.3 准备</h4><blockquote><p>这个阶段正式为类分配内存并设置类变量初始值，内存在方法去中分配(含 static 修饰的变量不含实例变量)。</p></blockquote><p>public static int value = 1127;<br>这句代码在初始值设置之后为 0，因为这时候尚未开始执行任何 Java 方法。而把 value 赋值为 1127 的 putstatic 指令是程序被编译后，存放于 clinit() 方法中，所以初始化阶段才会对 value 进行赋值。</p><p>基本数据类型的零值</p><table><thead><tr><th align="center">数据类型</th><th align="center">零值</th><th align="center">数据类型</th><th align="center">零值</th></tr></thead><tbody><tr><td align="center">int</td><td align="center">0</td><td align="center">boolean</td><td align="center">false</td></tr><tr><td align="center">long</td><td align="center">0L</td><td align="center">float</td><td align="center">0.0f</td></tr><tr><td align="center">short</td><td align="center">(short) 0</td><td align="center">double</td><td align="center">0.0d</td></tr><tr><td align="center">char</td><td align="center">‘\u0000’</td><td align="center">reference</td><td align="center">null</td></tr><tr><td align="center">byte</td><td align="center">(byte) 0</td><td align="center"></td><td align="center"></td></tr></tbody></table><p><strong>特殊情况：</strong> 如果类字段的字段属性表中存在 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 1127。</p><h4 id="4-2-4-解析"><a href="#4-2-4-解析" class="headerlink" title="4.2.4 解析"></a>4.2.4 解析</h4><blockquote><p>这个阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p></blockquote><p>符号引用<br>符号引用以一组符号来描述所引用的目标，符号可以使任何形式的字面量。<br>直接引用<br>直接引用可以使直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用和迅疾的内存布局实现有关</p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行，分别对应于常量池的 7 种常量类型。</p><h4 id="4-2-5-初始化"><a href="#4-2-5-初始化" class="headerlink" title="4.2.5 初始化"></a>4.2.5 初始化</h4><blockquote><p>前面过程都是以虚拟机主导，而初始化阶段开始执行类中的 Java 代码。</p></blockquote><h3 id="4-3-类加载器"><a href="#4-3-类加载器" class="headerlink" title="4.3 类加载器"></a>4.3 类加载器</h3><blockquote><p>通过一个类的全限定名来获取描述此类的二进制字节流。</p></blockquote><h4 id="4-3-1-双亲委派模型"><a href="#4-3-1-双亲委派模型" class="headerlink" title="4.3.1 双亲委派模型"></a>4.3.1 双亲委派模型</h4><blockquote><p>从 Java 虚拟机角度讲，只存在两种类加载器：一种是启动类加载器（C++ 实现，是虚拟机的一部分）；另一种是其他所有类的加载器（Java 实现，独立于虚拟机外部且全继承自 java.lang.ClassLoader）</p></blockquote><p>启动类加载器<br>加载 lib 下或被 -Xbootclasspath 路径下的类</p><p>扩展类加载器<br>加载 lib/ext 或者被 java.ext.dirs 系统变量所指定的路径下的类</p><p>引用程序类加载器<br>ClassLoader负责，加载用户路径上所指定的类库。</p><p><img src="/2019/10/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89%E4%BD%A0%E5%8F%AA%E8%A6%81%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.jpg" alt="类加载过程"></p><p>除顶层启动类加载器之外，其他都有自己的父类加载器。<br>工作过程：如果一个类加载器收到一个类加载的请求，它首先不会自己加载，而是把这个请求委派给父类加载器。只有父类无法完成时子类才会尝试加载。</p><h4 id="4-3-2-破坏双亲委派模型"><a href="#4-3-2-破坏双亲委派模型" class="headerlink" title="4.3.2 破坏双亲委派模型"></a>4.3.2 破坏双亲委派模型</h4><p>keyword：线程上下文加载器(Thread Context ClassLoader)</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的static关键字解析</title>
      <link href="/2019/09/23/Java%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/"/>
      <url>/2019/09/23/Java%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;static关键字是很多朋友在编写代码和阅读代码时碰到的比较难以理解的一个关键字，我打算写这边博客的起因是在牛客上刷到一道题，特别强调static关键词的重要性，使我意识到我在这方面的基础有着很大的方面欠缺，于是打算查阅资料进行补充。<br><img src="/2019/09/23/Java%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/static.png" alt="static"></p><hr><h3 id="一、static关键字的用途"><a href="#一、static关键字的用途" class="headerlink" title="一、static关键字的用途"></a>一、static关键字的用途</h3><a id="more"></a><p>&emsp;查阅资料，有这样一句话说明了static方法的的特殊之处</p><blockquote><p>“static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。”</p></blockquote><p>&emsp;可以看出static关键字的基本作用，简而言之，一句话来描述就是：</p><blockquote><p>方便在没有创建对象的情况下来进行调用（方法/变量）。</p></blockquote><p>&emsp;被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。</p><p>&emsp;static可以用来修饰类的成员方法、类的成员变量，另外可以编写static代码块来优化程序性能。</p><h4 id="（1）static方法"><a href="#（1）static方法" class="headerlink" title="（1）static方法"></a>（1）static方法</h4><p>&emsp;static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。<br>&emsp;虽然在静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法/变量的。举个简单的例子：<br><img src="/2019/09/23/Java%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F.png" alt="静态方法调用非静态成员变量"><br>&emsp;在上面的代码中，由于print2方法是独立于对象存在的，可以直接用过类名调用。假如说可以在静态方法中访问非静态方法/变量的话，那么如果在main方法中有下面一条语句：</p><p>&emsp;MyStr.print2();</p><p>&emsp;此时对象都没有，str2根本就不存在，所以就会产生矛盾了。同样对于方法也是一样，由于你无法预知在print1方法中是否访问了非静态成员变量，所以也禁止在静态成员方法中访问非静态成员方法。</p><p>&emsp;而对于非静态成员方法，它访问静态成员方法/变量显然是毫无限制的。</p><p>&emsp;因此，如果说想在不创建对象的情况下调用某个方法，就可以将这个方法设置为static。我们最常见的static方法就是main方法，至于为什么main方法必须是static的，现在就很清楚了。因为程序在执行main方法的时候没有创建任何对象，因此只有通过类名来访问。</p><h4 id="（2）static变量"><a href="#（2）static变量" class="headerlink" title="（2）static变量"></a>（2）static变量</h4><p>&emsp;static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</p><p>&emsp;static成员变量的初始化顺序按照定义的顺序进行初始化</p><h4 id="（3）static代码块"><a href="#（3）static代码块" class="headerlink" title="（3）static代码块"></a>（3）static代码块</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date birthDate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Date birthDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthDate = birthDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isBornBoomer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date startDate = Date.valueOf(<span class="string">"1997"</span>);</span><br><span class="line">        Date endDate = Date.valueOf(<span class="string">"1999"</span>);</span><br><span class="line">        <span class="keyword">return</span> birthDate.compareTo(startDate)&gt;=<span class="number">0</span> &amp;&amp; birthDate.compareTo(endDate) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isBornBoomer是用来这个人是否是1997-1999年出生的，而每次isBornBoomer被调用的时候，都会生成startDate和birthDate两个对象，造成了空间浪费，如果改成这样效率会更好：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date birthDate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Date startDate,endDate;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        startDate = Date.valueOf(<span class="string">"1997"</span>);</span><br><span class="line">        endDate = Date.valueOf(<span class="string">"1999"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Date birthDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthDate = birthDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isBornBoomer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birthDate.compareTo(startDate)&gt;=<span class="number">0</span> &amp;&amp; birthDate.compareTo(endDate) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</p><hr><h3 id="二、static关键字的误区"><a href="#二、static关键字的误区" class="headerlink" title="二、static关键字的误区"></a>二、static关键字的误区</h3><h4 id="1-static关键字会改变类中成员的访问权限吗"><a href="#1-static关键字会改变类中成员的访问权限吗" class="headerlink" title="1.static关键字会改变类中成员的访问权限吗"></a>1.static关键字会改变类中成员的访问权限吗</h4><p>比较容易java中的static与C/C++中的static关键字的功能混淆。在这里只需要记住一点：与C/C++中的static不同，Java中的static关键字不会影响到变量或者方法的作用域。在Java中能够影响到访问权限的只有private、public、protected（包括包访问权限）这几个关键字。看下面的例子就明白了：<br><img src="/2019/09/23/Java%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/static%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8D%E5%8F%AF%E6%94%B9%E5%8F%98%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90.jpg" alt="static关键字不可改变成员变量访问权限"></p><p>提示’age’ has private access in ‘person’，这说明static关键字并不会改变变量和方法的访问权限。</p><h4 id="2-能通过this访问静态成员变量吗"><a href="#2-能通过this访问静态成员变量吗" class="headerlink" title="2.能通过this访问静态成员变量吗"></a>2.能通过this访问静态成员变量吗</h4><p>虽然对于静态方法来说没有this，那么在非静态方法中能够通过this访问静态成员变量吗？先看下面的一个例子，这段代码输出的结果是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">33</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Main().printValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">3</span>;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">33</span></span><br></pre></td></tr></table></figure><p>这里面主要考察队this和static的理解。this代表什么？this代表当前对象，那么通过new Main()来调用printValue的话，当前对象就是通过new Main()生成的对象。而static变量是被对象所享有的，因此在printValue中的this.value的值毫无疑问是33。在printValue方法内部的value是局部变量，根本不可能与this关联，所以输出结果是33。在这里永远要记住一点：静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够）</p><h4 id="3-static能作用于局部变量么"><a href="#3-static能作用于局部变量么" class="headerlink" title="3.static能作用于局部变量么"></a>3.static能作用于局部变量么</h4><p>　　在C/C++中static是可以作用域局部变量的，但是在Java中切记：static是不允许用来修饰局部变量。不要问为什么，这是Java语法的规定。<br>局部变量最好不要设成静态变量，局变变量是有生命周期的，用完后JAVA很快就回收资源了。如果设成静态变量，那JAVA怎么回收被其占用的内存。</p><hr><h3 id="三、常见的笔试面试题"><a href="#三、常见的笔试面试题" class="headerlink" title="三、常见的笔试面试题"></a>三、常见的笔试面试题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"base static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"base constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">base <span class="keyword">static</span></span><br><span class="line">test <span class="keyword">static</span></span><br><span class="line">base constructor</span><br><span class="line">test constructor</span><br></pre></td></tr></table></figure><p>代码具体的执行过程，在执行开始，先要寻找到main方法，因为main方法是程序的入口，但是在执行main方法之前，必须先加载Test类，而在加载Test类的时候发现Test类继承自Base类，因此会转去先加载Base类，在加载Base类的时候，发现有static块，便执行了static块。在Base类加载完成之后，便继续加载Test类，然后发现Test类中也有static块，便执行static块。在加载完所需的类之后，便开始执行main方法。在main方法中执行new Test()的时候会先调用父类的构造器，然后再调用自身的构造器。因此，便出现了上面的输出结果。</p><hr><p>2.这段代码的输出结果是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">"Test"</span>);</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"person static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"person "</span>+str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">"MyClass"</span>);</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"myclass static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"myclass constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test <span class="keyword">static</span></span><br><span class="line">myclass <span class="keyword">static</span></span><br><span class="line">person <span class="keyword">static</span></span><br><span class="line">person Test</span><br><span class="line">test constructor</span><br><span class="line">person MyClass</span><br><span class="line">myclass constructor</span><br></pre></td></tr></table></figure><p>首先加载Test类，因此会执行Test类中的static块。接着执行new MyClass()，而MyClass类还没有被加载，因此需要加载MyClass类。在加载MyClass类的时候，发现MyClass类继承自Test类，但是由于Test类已经被加载了，所以只需要加载MyClass类，那么就会执行MyClass类的中的static块。在加载完之后，就通过构造器来生成对象。而在生成对象的时候，必须先初始化父类的成员变量，因此会执行Test中的Person person = new Person()，而Person类还没有被加载过，因此会先加载Person类并执行Person类中的static块，接着执行父类的构造器，完成了父类的初始化，然后就来初始化自身了，因此会接着执行MyClass中的Person person = new Person()，最后执行MyClass的构造器。</p><hr><p>3.这段代码的输出结果是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test static 1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test static 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test <span class="keyword">static</span> <span class="number">1</span></span><br><span class="line">test <span class="keyword">static</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>虽然在main方法中没有任何语句，但是还是会输出，原因上面已经讲述过了。另外，static块可以出现类中的任何地方（只要不是方法内部，记住，任何方法内部都不行），并且执行是按照static块的顺序执行的。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> static </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo从零开始搭建个人博客</title>
      <link href="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo+github.jpg" alt="hexo+github"></p><h3 id="1-什么是-Hexo"><a href="#1-什么是-Hexo" class="headerlink" title="1.什么是 Hexo"></a>1.什么是 Hexo</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页<br>具体参考<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">Hexo官方文档</a><br><a href="http://www.theoak.online" target="_blank" rel="noopener">Hexo博客</a></p><a id="more"></a><h3 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2.安装Git"></a>2.安装Git</h3><p>我一直不太喜欢在cmd中操作各种命令，所以挑了这个比较好使的Git, 我的是windows环境，所以下载windows版本并安装就可以了。</p><ul><li><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">下载地址</a></li><li>安装步骤：双击下载好的exe文件，一路next就好啦</li><li>安装好后，打开gitbash，查看版本：<br>命令：git version (写这篇博客的时候最新版本：2.12.2)<br><img src="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/gitVersion.jpg" alt="Git版本"></li></ul><h3 id="3-安装NodeJs"><a href="#3-安装NodeJs" class="headerlink" title="3. 安装NodeJs"></a>3. 安装NodeJs</h3><p>Hexo是基于nodeJS环境的静态博客，里面的npm工具很有用啊，所以还是老老实实把这玩意儿装了吧</p><ul><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">下载地址</a>(说明：LTS为长期支持版，Current为当前最新版)</li><li>安装步骤：反正下载好msi文件后，双击打开安装，也是一路next，不过在Custom Setup这一步记得选 Add to PATH ,这样你就不用自己去配置电脑上环境变量了，装完在按 win + r 快捷键调出运行，然后输入cmd确定，在cmd中输入path可以看到你的node是否配置在里面（环境变量），没有的话你就自由发挥吧。</li><li>查看版本：<br><img src="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/node%E7%89%88%E6%9C%AC.jpg" alt="node版本"></li></ul><h3 id="4-安装hexo"><a href="#4-安装hexo" class="headerlink" title="4. 安装hexo"></a>4. 安装hexo</h3><p>后面的东西都是在gitbash中用npm工具安装就好了。</p><ul><li><p>先创建一个文件夹（用来存放所有blog的东西），然后cd到该文件夹下。</p></li><li><p>安装hexo命令：npm i -g hexo</p></li><li><p>安装完成后，查看版本：<br><img src="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Hexo%E7%89%88%E6%9C%AC.jpg" alt="hexo版本"></p></li><li><p>初始化命令：hexo init ，初始化完成之后打开所在的文件夹可以看到以下文件：<br><img src="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.jpg" alt="目录结构"></p></li><li><p>解释一下：</p><ul><li>node_modules：是依赖包</li><li>public：存放的是生成的页面</li><li>scaffolds：命令生成文章等的模板</li><li>source：用命令创建的各种文章</li><li>themes：主题</li><li>_config.yml：整个博客的配置</li><li>db.json：source解析所得到的</li><li>package.json：项目所需模块项目的配置信息</li></ul></li><li><p>做好这些前置工作之后接下来的就是各种配置了</p></li></ul><h3 id="5-桥接到github"><a href="#5-桥接到github" class="headerlink" title="5.桥接到github"></a>5.桥接到github</h3><ul><li><p>没账号的创建账号，有账号的看下面。</p></li><li><p>创建一个repo，名称为yourname.github.io, 其中yourname是你的github名称，按照这个规则创建才有用哦，如下：<br><img src="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/github%E4%BB%93%E5%BA%93.jpg" alt="github仓库"><br><img src="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95.jpg" alt="创建方法"></p></li><li><p>回到gitbash中，配置github账户信息（YourName和YourEail都替换成你自己的github用户名和注册github使用的邮箱）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;YourName&quot;</span><br><span class="line">git config --global user.email &quot;YourEmail&quot;</span><br></pre></td></tr></table></figure></li><li><p>创建SSH<br>在gitbash中输入：ssh-keygen -t rsa -C “<a href="mailto:youremail@example.com">youremail@example.com</a>，生成ssh。然后按下图的方式找到id_rsa.pub文件的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;. ssh #检查本机已存在的ssh密钥</span><br></pre></td></tr></table></figure><p>如果提示：No such file or directory 说明你是第一次使用git。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure><p>然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：<br><img src="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E9%85%8D%E7%BD%AESSHKey.jpg" alt="配置SSHKey"><br>将刚复制的内容粘贴到key那里，title随便填，保存。</p></li></ul><h3 id="6-做到这里就快接近成功了"><a href="#6-做到这里就快接近成功了" class="headerlink" title="6.做到这里就快接近成功了"></a>6.做到这里就快接近成功了</h3><ul><li><p>用编辑器打开你的blog项目，修改_config.yml文件的一些配置(冒号之后都是有一个半角空格的)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:YourName&#x2F;YourName.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p>回到gitbash中，进入你的blog目录，分别执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server</span><br></pre></td></tr></table></figure></li></ul><p>注：hexo 3.0把服务器独立成个别模块，需要单独安装：npm i hexo-server。</p><p>打开浏览器输入：<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p><p>接着你就可以遇见天使的微笑了</p><h3 id="7-上传到github"><a href="#7-上传到github" class="headerlink" title="7. 上传到github"></a>7. 上传到github</h3><ul><li><p>先安装一波：npm install hexo-deployer-git –save（这样才能将你写好的文章部署到github服务器上并让别人浏览到）</p></li><li><p>执行命令(建议每次都按照如下步骤部署)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean #(或hexo cl)</span><br><span class="line">hexo generate #(或hexo g)</span><br><span class="line">hexo deploy #(或hexo d)部署到GitHub</span><br></pre></td></tr></table></figure><p><strong>注意</strong>deploy的过程中要输入你的username及passward。如下：<br><img src="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E9%83%A8%E7%BD%B2%E5%88%B0github.jpg" alt="部署到github"></p></li><li><p>在浏览器中输入<a href="http://yourgithubname.github.io" target="_blank" rel="noopener">http://yourgithubname.github.io</a>就可以看到你的个人博客啦，是不是很兴奋！</p></li><li><p>感觉gitbash中东西太多的时候输入clear命令清空。</p></li></ul><h3 id="8-绑定个人域名"><a href="#8-绑定个人域名" class="headerlink" title="8. 绑定个人域名"></a>8. 绑定个人域名</h3><ul><li>不想绑定的自行忽略</li><li>第一步购买域名：随便在哪个网站买一个就好了，小花是在* 阿里云购买的visugar.com, DNS也是顺道在那买的。</li><li>第二步添加CNAME：在项目的source文件夹下新建一个名为CNAME的文件，在里面添加你购买的域名，比如我添加的是visugar.com，只能添加一个哦。</li><li>到DNS中添加一条记录(域名解析)：<br><img src="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90.jpg" alt="域名解析"></li><li>其中ip地址为你的github的地址，可在cmd中ping一下就能看到(ping yourname.github.io)</li><li>接着再次部署一下，用你购买的域名打开，就可以看到你的博客啦</li></ul><h3 id="9-修改及配置主题"><a href="#9-修改及配置主题" class="headerlink" title="9. 修改及配置主题"></a>9. 修改及配置主题</h3><ul><li>hexo初始化之后默认的主题是landscape , 然后你可以去<a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo主题</a>里面找到你想要的主题。在github中搜索你要的主题名称，里面都会有该主题的如何使用的介绍，按着来就好了，反正就是改改改！我选的是icarus,看起来挺不错，至少是我喜欢的类型,简洁。<br><img src="/2019/09/14/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/icarus.jpg" alt="icarus"></li><li>在根目录下./_config.yml里theme：里配置上你需要的主题就可以了</li><li>跟该主题相关的配置在themes/icarus/_config.yml里面,然后根据你的需要在这就行了，可以修改前端的一些信息。</li><li>重新部署一下就OK啦！</li></ul><h3 id="10-常用hexo命令"><a href="#10-常用hexo命令" class="headerlink" title="10.常用hexo命令"></a>10.常用hexo命令</h3><ul><li>总结一些常用的hexo命令相信可以用到后期你还需了解些markdown语法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure><p>缩写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo n &#x3D;&#x3D; hexo new</span><br><span class="line">hexo g &#x3D;&#x3D; hexo generate</span><br><span class="line">hexo s &#x3D;&#x3D; hexo server</span><br><span class="line">hexo d &#x3D;&#x3D; hexo deploy</span><br></pre></td></tr></table></figure><p>组合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo s -g #生成并本地预览</span><br><span class="line">hexo d -g #生成并上传</span><br></pre></td></tr></table></figure><p>同时如需也可以使用&amp;&amp;组合hexo命令使用</p><p>如需了解跟多关注<a href="https://github.com/EricGerry" target="_blank" rel="noopener">github</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> node </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
